<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>111.二叉树的最小深度</title>
    <url>/2020/07/21/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<p>给定二叉树 [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS+递归"></a>DFS+递归</h2><p>参考二叉树的最大深度的题目, 该题的难点在于, 若一个节点只有一个子树, 那么应该不考虑不存在的子树情况.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minDepth = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">        minDepth = Math.min(minDepth(root.left), minDepth);</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">        minDepth = Math.min(minDepth(root.right), minDepth);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minDepth + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m1 = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> m2 = minDepth(root.right);</span><br><span class="line">        <span class="comment">//1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1</span></span><br><span class="line">        <span class="comment">//2.如果都不为空，返回较小深度+1</span></span><br><span class="line">        <span class="keyword">return</span> root.left == <span class="keyword">null</span> || root.right == <span class="keyword">null</span> ? m1 + m2 + <span class="number">1</span> : Math.min(m1,m2) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>114.二叉树展开为链表</title>
    <url>/2020/07/20/114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，原地将它展开为一个单链表。</p>
<p>例如，给定二叉树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>

<p>将其展开为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>这道题可以看作是, 从根节点开始遍历, 将左子树挂在右子树的位置, 然后将右子树挂在原左子树的最右节点的右子树位置.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 1 的左子树插入到右子树的地方</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2         5</span><br><span class="line">     &#x2F; \         \</span><br><span class="line">    3   4         6        </span><br><span class="line">&#x2F;&#x2F;将原来的右子树接到左子树的最右边节点</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2          </span><br><span class="line">     &#x2F; \          </span><br><span class="line">    3   4  </span><br><span class="line">         \</span><br><span class="line">          5</span><br><span class="line">           \</span><br><span class="line">            6</span><br><span class="line">            </span><br><span class="line"> &#x2F;&#x2F;将 2 的左子树插入到右子树的地方</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2          </span><br><span class="line">       \          </span><br><span class="line">        3       4  </span><br><span class="line">                 \</span><br><span class="line">                  5</span><br><span class="line">                   \</span><br><span class="line">                    6   </span><br><span class="line">        </span><br><span class="line"> &#x2F;&#x2F;将原来的右子树接到左子树的最右边节点</span><br><span class="line">    1</span><br><span class="line">     \</span><br><span class="line">      2          </span><br><span class="line">       \          </span><br><span class="line">        3      </span><br><span class="line">         \</span><br><span class="line">          4  </span><br><span class="line">           \</span><br><span class="line">            5</span><br><span class="line">             \</span><br><span class="line">              6         </span><br><span class="line">  </span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>

<p>根据这样的思路, 编写代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode temp = cur.right;</span><br><span class="line">            cur.right = cur.left;</span><br><span class="line">            cur.left = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode cur2 = cur;</span><br><span class="line">            <span class="keyword">while</span> (cur2.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                cur2 = cur2.right;</span><br><span class="line">            &#125;</span><br><span class="line">            cur2.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后序遍历-递归"><a href="#后序遍历-递归" class="headerlink" title="后序遍历+递归"></a>后序遍历+递归</h2><p>一开始我是想用先序遍历做的, 因为展开后的顺序就是先序遍历的结果. 每遍历到一个节点就让上一个节点的右指针指向当前节点. 做法是创建一个全局变量<code>pre</code>它表示的是上一个节点. 遍历到一个节点, 就让它称为<code>pre</code>的右儿子, 但是有个问题就是, 当把节点2放在<code>pre</code>的右边后, 节点5就要消失了, 再也找不回来. 退栈时右边本来应该是节点5, 但是不存在了.</p>
<p>所以只能用后序遍历的方法, 从底向上地连接链表. 连接顺序改变一下即可, 遍历到当前节点时, 令其右指针指向上一个节点. 遍历的顺序改为先遍历右子树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode tail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            flatten(root.right);</span><br><span class="line">            flatten(root.left);</span><br><span class="line">            </span><br><span class="line">            root.right = tail;</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">            tail = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>109.有序链表转换二叉搜索树</title>
    <url>/2020/07/20/109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="先序遍历-递归"><a href="#先序遍历-递归" class="headerlink" title="先序遍历+递归"></a>先序遍历+递归</h2><p>先将链表转换成一个列表, 然后按照先序遍历的顺序, 二分查找生成节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc109</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(list, <span class="number">0</span>, list.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">recur</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(list.get(mid));</span><br><span class="line">        root.left = recur(list, l, mid-<span class="number">1</span>);</span><br><span class="line">        root.right = recur(list, mid+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>不将链表转换成列表, 使用快慢指针的方法也能实现对应的功能, 目的就是为了找出中点嘛</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(head, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(ListNode head, ListNode tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// mid</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != tail &amp;&amp; fast.next != tail) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        root.left = helper(head, slow);</span><br><span class="line">        root.right = helper(slow.next, tail);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>173.二叉搜索树迭代器</title>
    <url>/2020/07/16/173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p>
<p>调用 <code>next()</code> 将返回二叉搜索树中的下一个最小的数。</p>
<p><strong>示例：</strong></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/bst-tree.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BSTIterator iterator &#x3D; new BSTIterator(root);</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 3</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 7</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 9</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 15</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 20</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS-列表"><a href="#DFS-列表" class="headerlink" title="DFS + 列表"></a>DFS + 列表</h2><p>需要写一个构造器, 然后实现两个方法. 因为要输出的是下一个最小的节点, 所以很容易想到中序遍历, 然后一个一个输出.</p>
<p><strong>大致思路为:</strong></p>
<ol>
<li>写构造器, 当传入一个二叉搜索树时, 直接将其中序遍历, 并将结果用列表存放</li>
<li>初始化一个变量, 时刻记录当前输出到哪里, 即再次调用<code>next()</code> 和<code>hasNext()</code> 时要查看的位置</li>
<li>当调用<code>next()</code> , 指针移动一位, 当调用<code>hasNext()</code>, 指针不动</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">                inOrder(root.left);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">                inOrder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the next smallest number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(++index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> whether we have a next smallest number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index != list.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>124.二叉树中的最大路径和</title>
    <url>/2020/07/17/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="后序遍历-递归-沿用官方"><a href="#后序遍历-递归-沿用官方" class="headerlink" title="后序遍历 + 递归(沿用官方)"></a>后序遍历 + 递归(沿用官方)</h2><p>采用自底向上的遍历方式. </p>
<p>这道题考虑的不是一条自上而下的路径而是任意起点到任意终点.</p>
<p>首先，考虑实现一个简化的函数 <code>maxGain(node)</code>，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。</p>
<p>具体而言，该函数的计算如下。</p>
<ul>
<li><p>空节点的最大贡献值等于 0。</p>
</li>
<li><p>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）。</p>
</li>
</ul>
<p>例如，考虑如下二叉树。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> -10</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>叶节点 9、15、7的最大贡献值分别为 9、15、7。</p>
<p>得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 2020 的最大贡献值等于 20+max(15,7) =35，节点 -10−10 的最大贡献值等于 -10+max(9,35)=25。</p>
<p>上述计算过程是递归的过程，因此，对根节点调用函数 maxGain，即可得到每个节点的最大贡献值。</p>
<p>根据函数 maxGain 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 maxSum 存储最大路径和，在递归过程中更新 maxSum 的值，最后得到的 maxSum 的值即为二叉树中的最大路径和。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/dfbdfabae.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/qegehtjfmgcjnfbdvsd.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/hgfdcvbg.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/23ty45hegsf.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/2345tygvc.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/cvfdxc.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/iuhgb.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc124</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftGain = Math.max(maxGain(root.left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightGain = Math.max(maxGain(root.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = leftGain + rightGain + root.val;</span><br><span class="line">        maxSum = Math.max(temp, maxSum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.val + Math.max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>130.被围绕的区域</title>
    <url>/2020/07/21/130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p>
<p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p>运行你的函数后，矩阵变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X解释:</span><br></pre></td></tr></table></figure>

<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS + 递归"></a>DFS + 递归</h2><p>这道题与岛屿问题很相似, 但是要考虑边界问题, 而且边界问题要在填充操作之前考虑.</p>
<p>所以思路为:</p>
<ol>
<li>先在边界上寻找所有的’O’, 并把它所连接的所有’O’都先标记为’#’, 表示不能转换成’X’</li>
<li>遍历整个二位数组, 此时再遍历的话所有的’O’就都是可以被转换的字符了, 然后把’#’再变回来</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc130</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="keyword">int</span> cols;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board==<span class="keyword">null</span>||board.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        rows = board.length;</span><br><span class="line">        cols = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isEdge = i == <span class="number">0</span> || j == <span class="number">0</span> || i == rows - <span class="number">1</span> || j == cols - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (isEdge &amp;&amp; board[i][j] == <span class="string">'O'</span>)</span><br><span class="line">                    dfs(board, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>)</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'#'</span>)</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || board[i][j] == <span class="string">'X'</span> || board[i][j] == <span class="string">'#'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        dfs(board, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(board, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(board, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>在广度优先遍历的基础上, 使用队列结构, 将每个符合条件的位置都入队</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pos</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        Pos(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">            <span class="keyword">this</span>.j = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 从边缘第一个是o的开始搜索</span></span><br><span class="line">                <span class="keyword">boolean</span> isEdge = i == <span class="number">0</span> || j == <span class="number">0</span> || i == m - <span class="number">1</span> || j == n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (isEdge &amp;&amp; board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    bfs(board, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'#'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Pos&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> Pos(i, j));</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Pos current = queue.poll();</span><br><span class="line">            <span class="comment">// 上</span></span><br><span class="line">            <span class="keyword">if</span> (current.i - <span class="number">1</span> &gt;= <span class="number">0</span> </span><br><span class="line">                &amp;&amp; board[current.i - <span class="number">1</span>][current.j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pos(current.i - <span class="number">1</span>, current.j));</span><br><span class="line">                board[current.i - <span class="number">1</span>][current.j] = <span class="string">'#'</span>;</span><br><span class="line">              	<span class="comment">// 没有continue.</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下</span></span><br><span class="line">            <span class="keyword">if</span> (current.i + <span class="number">1</span> &lt;= board.length - <span class="number">1</span> </span><br><span class="line">                &amp;&amp; board[current.i + <span class="number">1</span>][current.j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pos(current.i + <span class="number">1</span>, current.j));</span><br><span class="line">                board[current.i + <span class="number">1</span>][current.j] = <span class="string">'#'</span>;      </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span> (current.j - <span class="number">1</span> &gt;= <span class="number">0</span> </span><br><span class="line">                &amp;&amp; board[current.i][current.j - <span class="number">1</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pos(current.i, current.j - <span class="number">1</span>));</span><br><span class="line">                board[current.i][current.j - <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span> (current.j + <span class="number">1</span> &lt;= board[<span class="number">0</span>].length - <span class="number">1</span> </span><br><span class="line">                &amp;&amp; board[current.i][current.j + <span class="number">1</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pos(current.i, current.j + <span class="number">1</span>));</span><br><span class="line">                board[current.i][current.j + <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>199.二叉树的右视图</title>
    <url>/2020/07/19/199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p> 在层序遍历的题目中, 在从上到下打印二叉树Ⅱ的基础上, 把每一层的最后一个元素放进一个列表中即可. </p>
<p>因为每到了新的一层, 队列中元素的数量就是该层节点数, 所以可以简单地找出这层最后一个元素.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    TreeNode cur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> levelNums = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNums; i++) &#123;</span><br><span class="line">            cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (i == levelNums - <span class="number">1</span>)</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.left!=<span class="keyword">null</span>)</span><br><span class="line">                queue.add(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right!=<span class="keyword">null</span>)</span><br><span class="line">                queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>思路： 我们按照 「根结点 -&gt; 右子树 -&gt; 左子树」 的顺序访问，就可以保证每层都是最先访问最右边的节点的。</p>
<p>（与先序遍历 「根结点 -&gt; 左子树 -&gt; 右子树」 正好相反，先序遍历每层最先访问的是最左边的节点）</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/199_fig1.png" alt=""></p>
<p>对于这张图中的情况, 节点8之后并不会直接遍历到节点9, 而是会遍历到节点2, 但是此时递归传递的<code>depth</code> 是1, 而<code>res.size()</code>为4, 所以不会加入到结果列表中, 直到遍历至节点9</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>); <span class="comment">// 从根节点开始访问，根节点深度是0</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先访问 当前节点，再递归地访问 右子树 和 左子树。</span></span><br><span class="line">        <span class="keyword">if</span> (depth == res.size()) &#123;   <span class="comment">// 如果当前节点所在深度还没有出现在res里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中。</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">        dfs(root.right, depth);</span><br><span class="line">        dfs(root.left, depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>200.岛屿数量</title>
    <url>/2020/07/19/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;]</span><br><span class="line">]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;1&#39;,&#39;1&#39;]</span><br><span class="line">]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ul>
<li><p>目标是找到矩阵中 “岛屿的数量” ，上下左右相连的 1 都被认为是连续岛屿。</p>
</li>
<li><p>dfs方法： 设目前指针指向一个岛屿中的某一点 (i, j)，寻找包括此点的岛屿边界。</p>
</li>
<li><p>从 (i, j) 向此点的上下左右 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 做深度搜索。</p>
<ul>
<li><p>终止条件：</p>
<ul>
<li>(i, j) 越过矩阵边界;</li>
<li>grid[i][j] == 0，代表此分支已越过岛屿边界。</li>
</ul>
</li>
<li><p>搜索岛屿的同时，执行 grid[i][j] = ‘0’，即将岛屿所有节点删除，以免之后重复搜索相同岛屿。</p>
</li>
</ul>
</li>
<li><p>主循环：<br>遍历整个矩阵，当遇到 grid[i][j] == ‘1’ 时，从此点开始做深度优先搜索 dfs，岛屿数 count + 1 且在深度优先搜索中删除此岛屿。<br>最终返回岛屿数 count 即可。</p>
</li>
</ul>
<p>总体思路就是一旦找到一个1, 那么就向四周搜索, 把所有附近的1全部变成0, 有扫雷游戏的感觉, 就是扩散. </p>
<p>如果再碰到1, 那么这个1跟之前的岛屿是没有关系的, 说明是另外的一个新岛屿</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc200</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><ul>
<li>主循环和思路一类似，不同点是在于搜索某岛屿边界的方法不同。</li>
<li>bfs 方法：<ul>
<li>借用一个队列 queue，判断队列首部节点 (i, j) 是否未越界且为 1：</li>
<li>若是则置零（删除岛屿节点），并将此节点上下左右节点 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 加入队列；</li>
<li>若不是则跳过此节点；</li>
<li>循环 pop 队列首节点，直到整个队列为空，此时已经遍历完此岛屿。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            i = cur[<span class="number">0</span>];</span><br><span class="line">            j = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; grid.length &amp;&amp; j &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>, j&#125;);</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i - <span class="number">1</span>, j&#125;);</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j + <span class="number">1</span>&#125;);</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j - <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另一个版本的BFS代码:</strong></p>
<p>这个版本的亮点在于入队元素的处理, 不是将整个坐标数组入队, 而是巧妙地变成一个整数, 出队后再经过简单的运算还原</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//           x-1,y</span></span><br><span class="line">        <span class="comment">//  x,y-1    x,y      x,y+1</span></span><br><span class="line">        <span class="comment">//           x+1,y</span></span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        rows = grid.length;</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果是岛屿中的一个点，并且没有被访问过</span></span><br><span class="line">                <span class="comment">// 从坐标为 (i,j) 的点开始进行广度优先遍历</span></span><br><span class="line">                <span class="keyword">if</span> (!marked[i][j] &amp;&amp; grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    <span class="comment">// 小技巧：把坐标转换为一个数字</span></span><br><span class="line">                    <span class="comment">// 否则，得用一个数组存，在 Python 中，可以使用 tuple 存</span></span><br><span class="line">                    queue.addLast(i * cols + j);</span><br><span class="line">                    <span class="comment">// 注意：这里要标记上已经访问过</span></span><br><span class="line">                    marked[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">int</span> cur = queue.removeFirst();</span><br><span class="line">                        <span class="keyword">int</span> curX = cur / cols;</span><br><span class="line">                        <span class="keyword">int</span> curY = cur % cols;</span><br><span class="line">                        <span class="comment">// 得到 4 个方向的坐标</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                            <span class="keyword">int</span> newX = curX + directions[k][<span class="number">0</span>];</span><br><span class="line">                            <span class="keyword">int</span> newY = curY + directions[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="comment">// 如果不越界、没有被访问过、并且还要是陆地，我就继续放入队列，放入队列的同时，要记得标记已经访问过</span></span><br><span class="line">                            <span class="keyword">if</span> (inArea(newX, newY) &amp;&amp; grid[newX][newY] == <span class="string">'1'</span> &amp;&amp; !marked[newX][newY]) &#123;</span><br><span class="line">                                queue.addLast(newX * cols + newY);</span><br><span class="line">                                <span class="comment">// 【特别注意】在放入队列以后，要马上标记成已经访问过，语义也是十分清楚的：反正只要进入了队列，你迟早都会遍历到它</span></span><br><span class="line">                                <span class="comment">// 而不是在出队列的时候再标记</span></span><br><span class="line">                                <span class="comment">// 【特别注意】如果是出队列的时候再标记，会造成很多重复的结点进入队列，造成重复的操作，这句话如果你没有写对地方，代码会严重超时的</span></span><br><span class="line">                                marked[newX][newY] = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inArea</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 等于号这些细节不要忘了</span></span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>153.寻找旋转排序数组中的最小值</title>
    <url>/2020/07/04/153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>因为不存在重复的数字, 所以只需要考虑大于和等于的情况, 比较对象为<code>nums[right]</code></p>
<ol>
<li><p>循环二分： 设置 <code>i</code>,<code>j</code> 指针分别指向<code>numbers</code> 数组左右两端，<code>m = (i + j) / 2</code> 为每次二分的中点（ “/“ 代表向下取整除法），可分为以下三种情况：</p>
<ol>
<li><p>当<code>numbers[m] &gt; numbers[j]</code>时： <code>m</code> 一定在 左排序数组 中，即旋转点 <code>x</code>一定在<code>[m + 1, j]</code>闭区间内，因此执行<code>i = m + 1</code>；</p>
</li>
<li><p>当 <code>numbers[m] &lt; numbers[j]</code>时： <code>m</code> 一定在 右排序数组 中，即旋转点 <code>x</code> 一定在<code>[i, m]</code> 闭区间内，因此执行<code>j = m</code>；</p>
</li>
</ol>
</li>
<li><p>返回值： 当<code>i = j</code>时跳出二分循环，并返回 <code>numbers[i]</code>即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>207.课程表</title>
    <url>/2020/07/21/207-%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]</p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<p><strong>示例1:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ol>
<li>输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。</li>
<li>你可以假定输入的先决条件中没有重复的边。</li>
<li>1 &lt;= numCourses &lt;= 10^5</li>
</ol>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>解题思路：</strong></p>
<ul>
<li><strong>本题可约化为：</strong> 课程安排图是否是 <strong>有向无环图(DAG)</strong>。即课程间规定了前置条件，但不能构成任何环路，否则课程前置条件将不成立。</li>
<li>思路是通过 <strong>拓扑排序</strong> 判断此课程安排图是否是 <strong>有向无环图(DAG)</strong> .<strong>拓扑排序原理：</strong> 对 DAG 的顶点进行排序，使得对每一条有向边 (u, v)，均有 u（在排序记录中）比 v 先出现。亦可理解为对某点 v而言，只有当 v的所有源点均出现了，v才能出现。</li>
<li>通过课程前置条件列表 <code>prerequisites</code> 可以得到课程安排图的 <strong>邻接表</strong> <code>adjacency</code>，以降低算法时间复杂度，以下两种方法都会用到邻接表。</li>
</ul>
<h2 id="入度表BFS"><a href="#入度表BFS" class="headerlink" title="入度表BFS"></a>入度表BFS</h2><ol>
<li>统计课程安排图中每个节点的入度，生成 入度表 indegrees。</li>
<li>借助一个队列 queue，将所有入度为 0 的节点入队。</li>
<li>当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre：<ol>
<li>并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 -1，即 indegrees[cur] -= 1。</li>
<li>当入度 -1后邻接节点 cur 的入度为 0，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。</li>
</ol>
</li>
<li>在每次 pre 出队时，执行 numCourses–；<ul>
<li>若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。</li>
<li>因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。</li>
</ul>
</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/90794a4bf4034a277621d9ca33f2df25c40f7ff0d9d47044396c44d166920a99-Picture1.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/bd2f99fca16bd3a626153945a28ea8a75b151e6404d5525ad30202e19caab05c-Picture2.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/cb061aa43f1fcd9ca23069a5712a58a5ace8636deaaab3e1536d14d173b0cdde-Picture3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/66300cbc4c966c866cd56934b74caaa1770cc25c8d80edf4c41eb00f67699155-Picture4.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/7dc96bec8f3a5bb2b8bd75a3c7343b2753a70aedf3a7ffefa0019aa235fb9174-Picture5.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/b907e91e670a0a077154f0b7b2a483f19cd6952f790ed2f1a3bab9ce389ca408-Picture6.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] indegrees = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; adjcency = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        adjcency.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] cp : prerequisites) &#123;</span><br><span class="line">        indegrees[cp[<span class="number">0</span>]]++;</span><br><span class="line">        adjcency.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegrees[i] == <span class="number">0</span>)</span><br><span class="line">            queue.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre = queue.poll();</span><br><span class="line">        numCourses--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cur : adjcency.get(pre)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--indegrees[cur] == <span class="number">0</span>)</span><br><span class="line">                queue.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p><strong>算法流程：</strong></p>
<ol>
<li><p>借助一个标志列表 <code>flags</code>，用于判断每个节点 <code>i</code> （课程）的状态：</p>
<ol>
<li>未被 DFS 访问：<code>i == 0</code>；</li>
<li>已被<strong>其他节点启动</strong>的 DFS 访问：<code>i == -1</code>；</li>
<li>已被<strong>当前节点启动</strong>的 DFS 访问：<code>i == 1</code>。</li>
</ol>
</li>
<li><p>对 <code>numCourses</code> 个节点依次执行 DFS，判断每个节点起步 DFS 是否存在环，若存在环直接返回 False。DFS 流程；</p>
<ol>
<li><p>终止条件：</p>
<ul>
<li>当 <code>flag[i] == -1</code>，说明当前访问节点已被其他节点启动的 DFS 访问，无需再重复搜索，直接返回 True</li>
<li>当 <code>flag[i] == 1</code>，说明在本轮 DFS 搜索中节点 <code>i</code> 被第 22 次访问，即 <strong>课程安排图有环</strong> ，直接返回 False</li>
</ul>
</li>
<li><p>将当前访问节点 <code>i</code> 对应 <code>flag[i]</code> 置 11，即标记其被本轮 DFS 访问过；</p>
</li>
<li><p>递归访问当前节点 <code>i</code> 的所有邻接节点 <code>j</code>，当发现环直接返回 False</p>
</li>
<li><p>当前节点所有邻接节点已被遍历，并没有发现环，则将当前节点 <code>flag</code> 置为 -1 并返回 True</p>
</li>
</ol>
</li>
<li><p>若整个图 DFS 结束并未发现环，返回 True。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">            adjacency.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">int</span>[] flags = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] cp : prerequisites)</span><br><span class="line">            adjacency.get(cp[<span class="number">1</span>]).add(cp[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">            <span class="keyword">if</span>(!dfs(adjacency, flags, i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; adjacency, <span class="keyword">int</span>[] flags, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flags[i] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(flags[i] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        flags[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer j : adjacency.get(i))</span><br><span class="line">            <span class="keyword">if</span>(!dfs(adjacency, flags, j)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        flags[i] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>287.寻找重复数</title>
    <url>/2020/07/03/287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>之所以不使用暴力遍历查找和哈希表记录, 是因为时间复杂度或者空间复杂度超出要求.</p>
<p>使用<code>cnt[i]</code>表示<code>nums[]</code>数组中小于等于<code>i</code> 的数有多少个, 假设我们重复的数是<code>target</code>, 那么<code>[1, target-1]</code>里的所有数满足<code>cnt[i]&lt;=i</code>, <code>[target, n]</code>里的所有数满足<code>cnt[i]&gt;i</code>, 具有单调性.</p>
<p>以示例1为例, 列出每个数字的<code>cnt</code>值:</p>
<table>
<thead>
<tr>
<th align="center">nums</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cnt</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>示例中重复的整数是2, 我们可以看到[1, 1]中的数满足<code>cnt[i]&lt;=i</code>, [2, 4]中的数满足<code>cnt[i]&gt;i</code></p>
<p>一旦知道了<code>cnt[i]</code>数组的单调性和以上的大小关系, 就可以使用二分查找来找到重复的数. 对于所有测试用例, 考虑一下两种情况:</p>
<ul>
<li>如果测试用例的数组中 <code>target</code> 出现了两次，其余的数各出现了一次，这个时候肯定满足上文提及的性质，因为小于<code>target</code> 的数 <code>i</code>满足<code>cnt[i]=i</code>，大于等于<code>target</code> 的数 <code>j</code>满足 <code>cnt[j]=j+1</code></li>
<li>如果测试用例的数组中<code>target</code>出现了三次及以上，那么必然有一些数不在 <code>nums[]</code>数组中了，这个时候相当于我们用 <code>target</code> 去替换了这些数，我们考虑替换的时候对 <code>cnt[]</code>数组的影响。如果替换的数<code>i</code>小于 <code>target</code>，那么 <code>[i,target-1]</code> 的 <code>cnt</code> 值均减一，其他不变，满足条件。如果替换的数 <code>j</code>大于等于 <code>target</code>，那么<code>[target, j-1]</code>的 <code>cnt</code> 值均加一，其他不变，亦满足条件。</li>
</ul>
<p><strong>总结来说就是, 对于每个区间[left, right], 根据<code>mid</code>计算出<code>cnt</code>的值, 然后比较<code>mid</code>和<code>cnt</code>的大小, 以比较的结果调整左右边界</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= mid) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= mid) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>29.两数相除</title>
    <url>/2020/07/04/29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line">解释: 10&#x2F;3 &#x3D; truncate(3.33333..) &#x3D; truncate(3) &#x3D; 3</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">输出: -2</span><br><span class="line">解释: 7&#x2F;-3 &#x3D; truncate(-2.33333..) &#x3D; -2</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>首先想到的是对被除数循环递减, 记录能减多少次就好了, 但是明显效率太低.</p>
<p>那么这个循环递减的过程就可以使用移位运算优化一下.<strong>计算机在做移位时效率很高, 向左移1位相当于乘以2, 向右移1位相当于除以2</strong></p>
<p>设循环初始值为<code>i = 31</code>, 每次循环都比较<code>dividend&gt;&gt;i</code> 和 <code>devisor</code>的大小, 起初结果肯定是小于关系. 一旦变成了等于或大于关系, 则说明商至少是<code>2^i</code></p>
<p>以100除以3为例说明:</p>
<p><code>i</code>从31, 30, …,开始循环, 当<code>i=5</code>时, 有<code>(100&gt;&gt;5)&gt;=3</code>, 即<code>100/32&gt;=3</code>, 说明100中至少有32个3, 然后让余数4继续完成遍历.</p>
<p>这样的方法最多只只需要遍历31个数字即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> negative = (dividend ^ divisor) &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> t = Math.abs((<span class="keyword">long</span>) dividend);</span><br><span class="line">        <span class="keyword">long</span> d = Math.abs((<span class="keyword">long</span>) divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((t &gt;&gt; i) &gt;= d) &#123;</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                t -= d &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? -res : res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>315.计算右侧小于当前元素的个数</title>
    <url>/2020/07/08/315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [5,2,6,1]</span><br><span class="line">输出: [2,1,1,0] </span><br><span class="line">解释:</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1).</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1).</span><br><span class="line">6 的右侧有 1 个更小的元素 (1).</span><br><span class="line">1 的右侧有 0 个更小的元素.</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>这道题目要想到二分查找的一个性质: 在一个排序数组中, 可以通过二分查找目标值的左边界来表示数组中有多少个元素小于目标值</p>
<p>比如一个数组为:<code>[1, 2, 2, 4, 5, 6]</code>, 查找数字<code>4</code>的返回值是<code>3</code>, 结果不言而喻.</p>
<p>那么我们需要想办法创造出排序数组的条件.</p>
<p>首先初始化一个空的列表用于存放遍历后的元素, 因为这道题目是考察右侧有多少个更小的元素, 所以要从右往左遍历, 这能保证每遍历到一个元素, 列表中的元素都位于它的右边, 只需要在它们之间查找即可.</p>
<p>二分查找的结果即为元素右边有多少更小的值, 并将其插入到合适的位置使列表仍然是有序的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res.addFirst(binarySearch(list, nums[i]));</span><br><span class="line">            list.add(binarySearch(list, nums[i]), nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (list.get(mid) &gt;= target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (list.get(mid) &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在做这道题时因为要用到向列表中某个位置插入元素, 找响应的<code>insert()</code> 方法, 怎么也找不到, 原来直接用<code>add()</code> 方法就好了, 如果只填一个元素, 默认为列表尾部添加元素, 如果在前面写上索引, 即为在指定位置插入元素, 剩余元素后移.</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>240.搜索二维矩阵Ⅱ</title>
    <url>/2020/07/08/240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E2%85%A1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。<br>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p>
<p><strong>示例一</strong>：</p>
<p>给定 target = 5，返回 true。</p>
<p><strong>示例二</strong>：</p>
<p>给定 target = 20，返回 false。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="左下角出发遍历法"><a href="#左下角出发遍历法" class="headerlink" title="左下角出发遍历法"></a>左下角出发遍历法</h2><p>根据本文所描述的特征, 每一行从左到右递增, 每一列从上到下递增, 所以可以根据贪婪思想决定每一步怎么走, 即:</p>
<ul>
<li>当<code>matrix[i][j]&gt;target</code>, 则直接删除改行数组, <code>i--</code>, 因为只能往上走才能找到更小的数</li>
<li>当<code>matrix[i][j]&lt;target</code>, 则直接删除该列数组, <code>j++</code>, 因为只能往右走才能找到更大的数</li>
<li>若相等, 直接返回<code>true</code></li>
</ul>
<p>越界说明没找到, 返回<code>false</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt;= matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二分查找-较慢"><a href="#二分查找-较慢" class="headerlink" title="二分查找(较慢)"></a>二分查找(较慢)</h2><p>因为矩阵已经排过序, 所以可采用二分查找的方法.</p>
<p>思路是遍历每一行的数组进行查找, 每当遍历到新的一行, 如果该行第一个元素都比目标值大, 那么直接返回<code>false</code>, 因为这已经是目前还没有遍历的数中最小的了.</p>
<p>如果该行数组最右的元素都比目标值小, 则直接开始遍历下一行, 因为这已经是这一行最大的数了, 没有查找的必要.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix2</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>]&gt;target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][matrix[<span class="number">0</span>].length-<span class="number">1</span>]&lt;target)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> col = binarySearch1(matrix[i], target);</span><br><span class="line">            <span class="keyword">if</span> (col!=-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span>[] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid]&lt;target) i = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid]&gt;target) j = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>654.最大二叉树</title>
    <url>/2020/07/18/654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ol>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
<li>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</li>
</ol>
<p><strong>示例 ：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,2,1,6,0,5]</span><br><span class="line">输出：返回下面这棵树的根节点：</span><br><span class="line"></span><br><span class="line">      6</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     5</span><br><span class="line">    \    &#x2F; </span><br><span class="line">     2  0   </span><br><span class="line">       \</span><br><span class="line">        1</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="先序遍历-递归"><a href="#先序遍历-递归" class="headerlink" title="先序遍历+递归"></a>先序遍历+递归</h2><p>这道题经过在大脑中模拟一下二叉树的构建过程可知, 自顶向下更加直观, 所以使用先序遍历的思想. 将左侧数组作为左子树, 右侧数组作为右子树, 这明显递归的过程更加直观</p>
<p><strong>递归思路:</strong></p>
<ol>
<li><strong>终止条件:</strong> 当数组搜索的左右边界相等时, 递归终止<code>l = r</code></li>
<li><strong>递归过程:</strong> <ol>
<li>查找出当前数组中的最大值索引, 然后以最大值创建树节点,</li>
<li>调用 <code>construct(nums, l, max_i)</code> 创建根节点的左孩子。递归执行此操作，创建根节点的整个左子树</li>
<li>类似的，调用 <code>construct(nums, max_i + 1, r)</code> 创建根节点的右子树</li>
</ol>
</li>
<li><strong>返回值:</strong> 返回创建的<code>root</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc654</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> max_i = maxIndex(nums, l, r);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[max_i]);</span><br><span class="line">        root.left = recur(nums, l, max_i);</span><br><span class="line">        root.right = recur(nums, max_i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxIndex</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_i = l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[max_i])</span><br><span class="line">                max_i = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>617.合并二叉树</title>
    <url>/2020/07/19/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="先序遍历-递归"><a href="#先序遍历-递归" class="headerlink" title="先序遍历+递归"></a>先序遍历+递归</h2><p>刚开始分析时想造一棵新的树, 这样的思路很麻烦. 正确的做法是对其中一棵树进行改造比如( t1 )</p>
<ul>
<li><p>若t1为null, 则返回t2</p>
</li>
<li><p>若t2为null, 则返回t1</p>
</li>
<li><p>若两个节点都不为空, 则将两个节点的值相加赋给t1</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc617</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line"></span><br><span class="line">        t1.val += t2.val;</span><br><span class="line">        t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>32.最长有效括号</title>
    <url>/2020/07/04/32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>刚做这道题时忽略了题目中<strong>子串</strong>的要求, 直接求了共有多少有效括号, 提交后才发现.</p>
<p>首先想到的还是用栈来解决有效括号的问题, 这道题麻烦在必须是子串才可以, 字符前后需要建立联系.</p>
<p>具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：</p>
<ul>
<li>对于遇到的每个<code>(</code> ，我们将它的下标放入栈中</li>
<li>对于遇到的每个<code>)</code>，我们先弹出栈顶元素表示匹配了当前右括号：<ul>
<li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</li>
<li>如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」</li>
</ul>
</li>
</ul>
<p>需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1−1 的元素。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/1.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/2.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/4.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/5.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/6.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/7.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/8.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/9.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/10.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/11.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>)</span><br><span class="line">                stack.push(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = Math.max(max, i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>99.恢复二叉搜索树</title>
    <url>/2020/07/18/99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>二叉搜索树中的两个节点被错误地交换。</p>
<p>请在不改变其结构的情况下，恢复这棵树。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  &#x2F;</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">输出: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  3</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>根据中序遍历是递增的这一性质, 这道题在中序遍历的基础上去做.</p>
<p>只有两个数被交换, 所以找到比上一个节点数值小的节点即可.</p>
<p>如下图所示, 中序遍历顺序是 4,2,3,1,我们只要找到节点4和节点1交换顺序即可!</p>
<p>这里我们有个规律发现这两个节点:</p>
<p>第一个节点,是第一个按照中序遍历时候前一个节点大于后一个节点,我们选取前一个节点,这里指节点4;</p>
<p>第二个节点,是在第一个节点找到之后, 后面出现前一个节点大于后一个节点,我们选择后一个节点,这里指节点1;</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/b4ee2fcef6391b0756e5d0e84540b448b9ac122a0efabc9ff505e4fdcdd3bc3c-1561339663404.png" alt=""></p>
<p>只要找到了这两个节点, 交换其数值即可, 不需要动结构.</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode firstNode = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode secondNode = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode preNode = <span class="keyword">new</span> TreeNode(Integer.MIN_VALUE);</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur=stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (firstNode==<span class="keyword">null</span>&amp;&amp;cur.val&lt;preNode.val) firstNode = preNode;</span><br><span class="line">        <span class="keyword">if</span> (firstNode!=<span class="keyword">null</span>&amp;&amp;cur.val&lt;preNode.val) secondNode = cur;</span><br><span class="line">        preNode = cur;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = firstNode.val;</span><br><span class="line">    firstNode.val = secondNode.val;</span><br><span class="line">    secondNode.val = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode firstNode = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode secondNode = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode preNode = <span class="keyword">new</span> TreeNode(Integer.MIN_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">int</span> temp = firstNode.val;</span><br><span class="line">        firstNode.val = secondNode.val;</span><br><span class="line">        secondNode.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            inOrder(root.left);</span><br><span class="line">            <span class="keyword">if</span> (firstNode==<span class="keyword">null</span>&amp;&amp;root.val&lt;preNode.val) firstNode = preNode;</span><br><span class="line">            <span class="keyword">if</span> (firstNode!=<span class="keyword">null</span>&amp;&amp;root.val&lt;preNode.val) secondNode = root;</span><br><span class="line">            preNode = root;</span><br><span class="line">            inOrder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>669.修剪二叉搜索树</title>
    <url>/2020/07/19/669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  0   2</span><br><span class="line"></span><br><span class="line">  L &#x3D; 1</span><br><span class="line">  R &#x3D; 2</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">    1</span><br><span class="line">      \</span><br><span class="line">       2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  0   4</span><br><span class="line">   \</span><br><span class="line">    2</span><br><span class="line">   &#x2F;</span><br><span class="line">  1</span><br><span class="line"></span><br><span class="line">  L &#x3D; 1</span><br><span class="line">  R &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">      3</span><br><span class="line">     &#x2F; </span><br><span class="line">   2   </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="先序遍历-递归"><a href="#先序遍历-递归" class="headerlink" title="先序遍历+递归"></a>先序遍历+递归</h2><p>直观上分析这道题目应该自顶向下修剪. 需要分析出来的要点在于:</p>
<ul>
<li>如果当前节点的值比给定的左边界还小, 那么返回该节点的右子树</li>
<li>如果当前节点的值比给定的右边界还大, 那么返回该节点的左子树</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc669</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val&lt;L)</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right, L, R);</span><br><span class="line">        <span class="keyword">if</span> (root.val&gt;R)</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left, L, R);</span><br><span class="line"></span><br><span class="line">        root.left = trimBST(root.left, L, R);</span><br><span class="line">        root.right = trimBST(root.right, L, R);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>96.不同的二叉搜索树</title>
    <url>/2020/07/16/96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>这道题需要动手推导, 根据下图的关系:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/5e13a34a242ad4a1a509b1c54fc17d2e4c81add7d8c5104f96b5f91293af8031-frame_00007.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/96bb714d079c7aef72465216b1f205cbf78865f6bcc3cf69691f7d46096196e0-frame_00010.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/69509ce7a83c6c57bc6fb611db21ef1a83c552cc4237e75fb338162c8e128c12-frame_00016.png" alt=""></p>
<p>可以总结出思路, 对于<code>n</code> 个节点来说, 每个节点都可以作为根节点, 每个节点作为根节点的所有情况加起来就是<code>n</code> 个节点的总数量. 比如图中的 n=3 的情况, 就是<strong>节点1作为根节点的情况 + 节点2作为根节点的情况 + 节点3作为根节点的情况</strong>. 而每个节点作为根节点时的可能性数量又等于左右子树的情况相乘. 这就是一个动态规划的问题, 因为每个状态都与前几个状态有关.</p>
<p><strong><em>G</em>(<em>n</em>)=<em>f</em>(1)+<em>f</em>(2)+<em>f</em>(3)+<em>f</em>(4)+…+<em>f</em>(<em>n</em>)</strong></p>
<p>其中</p>
<p><strong><em>f</em>(<em>i</em>)=<em>G</em>(<em>i</em>−1)∗<em>G</em>(<em>n</em>−<em>i</em>)</strong></p>
<p>综合两个公式可以得到 <code>卡特兰数</code>公式</p>
<p><strong><em>G(n) = G(0)G(n-1)+G(1)(n-2)+…+G(n-1)G(0)G(n)=G(0)G(n−1)+G(1)G(n−2)+…+G(n−1)G(0)</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc96</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发编程</title>
    <url>/2020/07/11/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="什么是JUC"><a href="#什么是JUC" class="headerlink" title="什么是JUC"></a>什么是JUC</h2><p>所谓JUC并发编程, 就是利用到了JDK中以下的三个关于多线程的包进行开发:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200712203137.png" alt=""></p>
<p>简称为 J U C.</p>
<p>一些业务无法通过普通的线程代码完成, 比如基础阶段的 <code>Thread</code></p>
<p><strong>Runnable</strong> : 没有返回值, 效率相较于Callable 相对较低</p>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><p>在操作系统中运行的程序就是进程, 比如QQ, 播放器, 游戏等</p>
<p>一个进程可以有多个线程, 如视频中同时听到声音, 看到图像, 看弹幕等等</p>
<p>需要注意的是, <strong>程序</strong>是指令和数据的有序集合, 是一个静态的概念, 执行程序的一次执行过程叫做<strong>进程</strong>, 这才是动态的概念</p>
<p>通常在一个进程中可以包含若干个线程, 线程是CPU调度和执行的单位</p>
<p><strong>核心概念:</strong></p>
<ul>
<li>在程序执行时, 即使没有创建线程, 后台也会有多个线程, 如主线程, gc线程;</li>
<li>main()称之为主线程, 为系统的入口, 用于执行整个程序</li>
<li>对同一份资源操作时, 会存在资源抢夺的问题, 需要加入并发控制</li>
<li>线程会带来额外的开销, 如CPU调度时间, 并发控制开销</li>
</ul>
<p><strong>java默认有几个线程?</strong></p>
<p>两个: main, GC</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA中配置Mysql出现时区问题解决方法</title>
    <url>/2020/07/18/IDEA%E4%B8%AD%E9%85%8D%E7%BD%AEMysql%E5%87%BA%E7%8E%B0%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>首先，出现该问题的原因是MySQL驱动jar中的默认时区是UTC。</p>
<p>UTC代表的是全球标准时间 ，但是我们使用的时间是北京时区也就是东八区，领先UTC八个小时。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/20191009101648442.png" alt=""></p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ol>
<li><p>进入命令窗口（Win + R），连接数据库 mysql -hlocalhost -uroot -p，回车，输入密码，回车，如图：</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/20191009102949109.png" alt=""></p>
</li>
<li><p>继续输入 show variables like’%time_zone’;  （注意不要漏掉后面的分号），回车，如图：</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/20191009103216457.png" alt=""></p>
<p>显示 SYSTEM 就是没有设置时区啦。</p>
</li>
<li><p>现在我们来设置时区。</p>
<p>输入set global time_zone = ‘+8:00’; 注意不要漏掉后面的分号），回车，如图：</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/20191009103329355.png" alt=""></p>
<p>这便是设置成功啦！重连即可</p>
</li>
</ol>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>因为时区不一致，所以提示Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezone’ property manually<br>服务器返回了无效的时区，去“高级”标签中手工设置“serverTimezon”属性值。<br><img src="http://qcxz71s06.bkt.clouddn.com/20190907165021112.png" alt=""></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>JVM原理</title>
    <url>/2020/07/12/JVM%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="JVM探究"><a href="#JVM探究" class="headerlink" title="JVM探究"></a>JVM探究</h1><ul>
<li>请你谈谈对JVM的理解? Java8虚拟机和之前的变化更新?</li>
<li>什么是OOM, 什么是栈溢出?怎么分析?</li>
<li>JVM的常用调优参数有哪些?</li>
<li>内存快照如何抓取, 怎么分析Dump文件?</li>
<li>谈谈JVM中, 类加载器的认识?</li>
</ul>
<h1 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h1><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200712210530.png" alt=""></p>
<h1 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h1><p><img src="http://qcxz71s06.bkt.clouddn.com/jvm.png" alt=""></p>
<p>所谓的JVM调优, 99%的情况下都是在<strong>方法区</strong>和<strong>堆</strong>中调的. 这之中绝大部分都是在调堆.</p>
<p>运行时数据区中的 <strong>栈, 本地方法栈, 程序计数器</strong>这三个部分不可能有垃圾</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>加载Class文件: new Student();</p>
<p>引用是在栈里, 具体的实例放在堆中</p>
<p>实例化一个Car类的过程：</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200712215554.png" alt=""></p>
<p>生成的实例对象包括各种属性放在堆中, 名字也就是地址放在栈中. 引用时根据栈中的地址去堆中引用</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200712214851.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car1 = <span class="keyword">new</span> Car();</span><br><span class="line">        Car car2 = <span class="keyword">new</span> Car();</span><br><span class="line">        Car car3 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends Car&gt; aClass1 = car1.getClass();</span><br><span class="line">        Class&lt;? extends Car&gt; aClass2 = car2.getClass();</span><br><span class="line">        Class&lt;? extends Car&gt; aClass3 = car3.getClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(aClass1);</span><br><span class="line">        System.out.println(aClass2);</span><br><span class="line">        System.out.println(aClass3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Car</span><br><span class="line">class Car</span><br><span class="line">class Car</span><br></pre></td></tr></table></figure>

<p><strong>类加载器的分类:</strong></p>
<ol>
<li>虚拟机自带的加载器</li>
<li>启动类(根)加载器: 负责加载%JAVA_HOME%\bin目录下的所有jar包，或者是-Xbootclasspath参数指定的路径；</li>
<li>扩展类加载器: 负责加载%JAVA_HOME%\bin\ext目录下的所有jar包，或者是java.ext.dirs参数指定的路径；</li>
<li>应用程序加载器: 负责加载用户类路径上所指定的类库，如果应用程序中没有自定义加载器，那么次加载器就为默认加载器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car1 = <span class="keyword">new</span> Car();</span><br><span class="line">        Car car2 = <span class="keyword">new</span> Car();</span><br><span class="line">        Car car3 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends Car&gt; aClass1 = car1.getClass();</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = aClass1.getClassLoader();</span><br><span class="line">        ClassLoader parent = classLoader.getParent();</span><br><span class="line">        ClassLoader parent1 = parent.getParent();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        System.out.println(parent);</span><br><span class="line">        System.out.println(parent1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@3fee733d</span><br><span class="line">jdk.internal.loader.ClassLoaders$PlatformClassLoader@723279cf</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><ol>
<li>类加载器收到类加载的请求</li>
<li>将这个请求向上委托给父类加载器去完成, 一直向上委托, 直到启动类加载器</li>
<li>启动类加载器检查是否能够加载当前这个类, 能加载就结束, 使用当前加载器, 否则, 抛出异常, 通知子加载器进行加载</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/1502173-20181029183937235-1542648599.png" alt=""></p>
<p>接下来举个例子：</p>
<p>大家所熟知的Object类，直接告诉大家，Object默认情况下是启动类加载器进行加载的。假设我也自定义一个Object，并且制定加载器为自定义加载器。现在你会发现自定义的Object可以正常编译，但是永远无法被加载运行。</p>
<p>这是因为申请自定义Object加载时，总是启动类加载器，而不是自定义加载器，也不会是其他的加载器。</p>
<h1 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h1><p>Java安全模型的核心就是Java沙箱, 沙箱是一个限制程序运行的环境. 沙箱机制就是将Java代码限定在虚拟机特定的运行范围中, 并且严格限制代码对本地系统资源访问, 通过这样的措施来保证对代码的有效隔离, 防止对本地系统造成破坏. 沙箱主要 <strong>限制系统的资源访问</strong> , CPU, 内存, 文件系统, 网络. 不同级别的沙箱对这些资源访问的限制也可以不一样</p>
<h1 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h1><p>在Java 的<code>Thread</code> 类中, 有这样的方法:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200713105125.png" alt=""></p>
<p>凡是带了<code>native</code> 关键字的, 说明java的作用范围达不到了, 会去调用底层c语言的库</p>
<p>会进入本地方法栈, 然后它会调用JNI(本地方法接口), 继而调用本地方法库</p>
<p>JNI的作用: 扩展Java的使用, 融合不同的编程语言为Java所用</p>
<h1 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h1><p>程序计数器: Program Counter Register</p>
<p>每个线程都有一个程序计数器, 是线程私有的, 就是一个指针, 指向方法区中的方法字节码(用来存储指向一条指令的地址, 也即将要执行的指令代码), 在执行引擎读取下一条指令, 是一个非常小的内存空间, 几乎可以忽略不计.</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区是被所有线程共享, 所有字段和方法字节码, 以及一些特殊方法, 如构造函数, 接口代码也在此定义, 简单说, 所有定义的方法的信息都保存在该区域, <strong>该区域属于共享区间</strong>;</p>
<p><strong>静态变量, 常量, 类信息(构造方法, 接口定义), 运行时的常量池存在方法区中, 但是实例变量存在堆内存中, 和方法区无关.</strong></p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈内存, 主管程序的运行, 生命周期和线程同步</p>
<p>线程结束, 栈内存也就释放, 对于栈来说, 不存在垃圾回收问题</p>
<p>一旦线程结束, 栈就Over</p>
<p>存放: 8大基本类型 + 对象引用 + 实例的方法</p>
<p>对象的实例化过程视频解析:</p>
<p><a href="https://www.bilibili.com/video/BV1HE411E7kY?from=search&amp;seid=7388971973574996958" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1HE411E7kY?from=search&amp;seid=7388971973574996958</a></p>
<h1 id="三种JVM"><a href="#三种JVM" class="headerlink" title="三种JVM"></a>三种JVM</h1><ul>
<li>Sun公司: HotSpot</li>
<li>BEA:  JRockit</li>
<li>IBM: J9VM</li>
</ul>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>Heap, 一个JVM只有一个堆内存, 堆内存的大小是可以调节的.</p>
<p>类加载器读取了类文件后, 一般会把什么东西放到堆中? 类, 方法, 常量, 变量</p>
<p>堆内存中还要细分为三个区域:</p>
<ul>
<li>新生区(伊甸园区)</li>
<li>养老区</li>
<li>永久区</li>
</ul>
<h2 id="新生区"><a href="#新生区" class="headerlink" title="新生区"></a>新生区</h2><p>类诞生, 成长的地方, 甚至死亡</p>
<p>伊甸园区, 所有的对象都是在 伊甸园 区</p>
<h2 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h2><p>这个区域常驻内存的, 用来存放JDK自身携带的Class对象, Interface元数据, 存储的是Java运行时的一些环境或类信息</p>
<ul>
<li>1.6之前 : 永久代, 常量池实在方法区</li>
<li>1.7: 永久代, 但是慢慢退化了, “去永久代”, 常量池在堆中</li>
<li>1.8之后 : 无永久代, 常量池在元空间</li>
</ul>
<p>默认情况下, JVM分配的总内存是电脑内存的1/4, 而初始化的内存为: 1/64</p>
<ol>
<li>JVM的体系结构</li>
<li>类加载器</li>
<li>双亲委派机制</li>
<li>沙箱安全机制</li>
<li>Native</li>
<li>PC寄存器</li>
<li>方法区</li>
<li>栈</li>
<li>三种JVM</li>
<li>堆</li>
<li>新生区</li>
<li>老年区</li>
<li>永久区</li>
<li>堆内存调优</li>
<li>GC<ol>
<li>常用算法</li>
</ol>
</li>
<li>JMM</li>
<li>总结</li>
</ol>
<ol>
<li>百度</li>
<li>思维导图</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC回顾</title>
    <url>/2020/07/17/JDBC%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p><strong>JDBC: java database connection</strong></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200717111846.png" alt=""></p>
<p>需要jar包的支持:</p>
<ul>
<li>java.sql</li>
<li>javax.sql</li>
<li>mysql-conneter-java… 连接驱动(必须导入)</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="普通步骤"><a href="#普通步骤" class="headerlink" title="普通步骤"></a>普通步骤</h3><ol>
<li><p>导入数据库依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加载驱动</p>
</li>
<li><p>连接数据库, 代表数据库</p>
</li>
<li><p>向数据库发送SQL的对象statement: CRUD</p>
</li>
<li><p>执行查询, 返回一个result</p>
</li>
<li><p>关闭连接</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//配置信息</span></span><br><span class="line">        String url = <span class="string">"jdbc:mysql://localhost:3306/book"</span>;</span><br><span class="line">        String username = <span class="string">"root"</span>;</span><br><span class="line">        String password = <span class="string">"root"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.加载驱动</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">//2. 连接数据库, 代表数据库</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//3. 向数据库发送SQL的对象Statement:CRUD</span></span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        <span class="comment">//4. 编写SQL</span></span><br><span class="line">        String sql = <span class="string">"select * from t_user;"</span>;</span><br><span class="line">        <span class="comment">//5. 执行SQL, 返回结果集</span></span><br><span class="line">        ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            System.out.println(<span class="string">"id="</span>+resultSet.getInt(<span class="string">"id"</span>));</span><br><span class="line">            System.out.println(<span class="string">"username="</span>+resultSet.getString(<span class="string">"username"</span>));</span><br><span class="line">            System.out.println(<span class="string">"password="</span>+resultSet.getString(<span class="string">"password"</span>));</span><br><span class="line">            System.out.println(<span class="string">"email="</span>+resultSet.getString(<span class="string">"email"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 关闭连接, 释放资源</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//配置信息</span></span><br><span class="line">        String url = <span class="string">"jdbc:mysql://localhost:3306/book?useUnicode=true&amp;characterEncoding=UTF8"</span>;</span><br><span class="line"><span class="comment">//        String url = "jdbc:mysql://localhost:3306/book";</span></span><br><span class="line">        String username = <span class="string">"root"</span>;</span><br><span class="line">        String password = <span class="string">"root"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.加载驱动</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">//2. 连接数据库, 代表数据库</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//3. 编写SQL</span></span><br><span class="line">        String sql = <span class="string">"insert into t_user(id, username, password, email) VALUES (?, ?, ?, ?);"</span>;</span><br><span class="line">        <span class="comment">//4. 预编译</span></span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        preparedStatement.setInt(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, <span class="string">"刘潇博"</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">3</span>, <span class="string">"asdff"</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">4</span>, <span class="string">"zsdff@xx.com"</span>);</span><br><span class="line">        <span class="comment">// 5. 执行</span></span><br><span class="line">        <span class="keyword">int</span> i = preparedStatement.executeUpdate();</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"插入成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6. 关闭连接, 释放资源</span></span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意, 插入中文字符时可能会变成问号, 先查看并修改数据库的字符集:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> book; //查看库的字符集</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book.t_user;//查看表的字符集</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FULL</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> book.t_user; //查看字段编码</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> book <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8; //修改库的字符集</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> book.t_user <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci; //修改表以及字符字段的字符集</span><br></pre></td></tr></table></figure>

<h1 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h1><p>要么都成功, 要么都失败</p>
<p>ACID原则: 保证数据的安全</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启事物</span><br><span class="line">事物提交</span><br><span class="line">事物回滚</span><br><span class="line">关闭事物</span><br></pre></td></tr></table></figure>

<p>创建一个表, 模拟转账:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span>    <span class="built_in">int</span> auto_increment</span><br><span class="line">        primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span>  <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="literal">null</span>,</span><br><span class="line">    money <span class="built_in">float</span>       <span class="literal">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>插入值:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">account</span>(<span class="keyword">name</span>, money) <span class="keyword">VALUES</span> (<span class="string">'A'</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">account</span>(<span class="keyword">name</span>, money) <span class="keyword">VALUES</span> (<span class="string">'B'</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">account</span>(<span class="keyword">name</span>, money) <span class="keyword">VALUES</span> (<span class="string">'C'</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>执行:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>; <span class="comment"># 开启事物</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span></span><br><span class="line"><span class="keyword">set</span> money=money - <span class="number">100</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'A'</span>;</span><br></pre></td></tr></table></figure>

<p>结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200717150152.png" alt=""></p>
<p>没有变化的原因是没有提交事物.</p>
<p>添加提交语句后:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>; <span class="comment"># 开启事物</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span></span><br><span class="line"><span class="keyword">set</span> money=money - <span class="number">100</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> ;</span><br></pre></td></tr></table></figure>

<p>结果达到预期, 不再贴出</p>
<p>在<code>commit</code>前加上<code>rollback</code> 就能保证无论出现什么错误或者做了什么操作都能回滚到开始事物时的状态.</p>
<p>在JDBC中编写如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//配置信息</span></span><br><span class="line">    String url = <span class="string">"jdbc:mysql://localhost:3306/book?useUnicode=true&amp;characterEncoding=UTF8"</span>;</span><br><span class="line">    <span class="comment">//        String url = "jdbc:mysql://localhost:3306/book";</span></span><br><span class="line">    String username = <span class="string">"root"</span>;</span><br><span class="line">    String password = <span class="string">"root"</span>;</span><br><span class="line">    Connection connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.加载驱动</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">//2. 连接数据库, 代表数据库</span></span><br><span class="line">        connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="comment">//3. 通知数据库开启事物, 默认是自动开启的, 给个false就手动开启了</span></span><br><span class="line">        connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"update account set money=money - 100 where name = 'A'"</span>;</span><br><span class="line">        connection.prepareStatement(sql).executeUpdate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 制造错误</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        String sql2 = <span class="string">"update account set money=money+100 where name = 'B'"</span>;</span><br><span class="line">        connection.prepareStatement(sql2).executeUpdate();</span><br><span class="line"></span><br><span class="line">        connection.commit();    <span class="comment">//以上两条SQL都执行成功了, 就提交事物</span></span><br><span class="line">        System.out.println(<span class="string">"success"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果出现异常, 就通知数据库执行回滚操作</span></span><br><span class="line">            connection.rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//6. 关闭连接, 释放资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是利用了Java的try/catch/finally的异常处理机制, 把<code>rollback</code> 操作放在catch语句中, 只要try 语句中出现了异常, 那么就会执行回滚操作, 并抛出异常, 把关闭连接的操作放在finally 语句中, 这是一定会执行的.</p>
<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200717152725.png" alt=""></p>
<p>可见, 抛出了异常, 数据库的表格也没有变化</p>
<p>如果将故意制造的异常删去, 则能够达到要求完成转账.</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Limit实现分页</title>
    <url>/2020/07/20/Limit%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>为什么要分页?</p>
<ul>
<li>减少数据的处理量</li>
</ul>
<p>语法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">limit</span> startIndex, pageSize;</span><br></pre></td></tr></table></figure>

<h2 id="使用SQL语句实现分页"><a href="#使用SQL语句实现分页" class="headerlink" title="使用SQL语句实现分页:"></a>使用SQL语句实现分页:</h2><ol>
<li><p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分页查询</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByLimit</span><span class="params">(Map&lt;String, Integer&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByLimit"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultMap</span>=<span class="string">"UserMap"</span>&gt;</span></span><br><span class="line">    select * from mybatis.user limit #&#123;startIndex&#125;, #&#123;pageSize&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByLimitTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"startIndex"</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">"pageSize"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = mapper.getUserByLimit(map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Opening JDBC Connection</span><br><span class="line">[org.apache.ibatis.datasource.pooled.PooledDataSource]-Created connection 1631086936.</span><br><span class="line">[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@61386958]</span><br><span class="line">[com.lxb.dao.UserMapper.getUserByLimit]-&#x3D;&#x3D;&gt;  Preparing: select * from mybatis.user limit ?, ?; </span><br><span class="line">[com.lxb.dao.UserMapper.getUserByLimit]-&#x3D;&#x3D;&gt; Parameters: 1(Integer), 2(Integer)</span><br><span class="line">[com.lxb.dao.UserMapper.getUserByLimit]-&lt;&#x3D;&#x3D;      Total: 2</span><br><span class="line">User&#123;id&#x3D;2, name&#x3D;&#39;John&#39;, password&#x3D;&#39;123456&#39;&#125;</span><br><span class="line">User&#123;id&#x3D;3, name&#x3D;&#39;Jay&#39;, password&#x3D;&#39;123456&#39;&#125;</span><br><span class="line">[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@61386958]</span><br><span class="line">[org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@61386958]</span><br><span class="line">[org.apache.ibatis.datasource.pooled.PooledDataSource]-Returned connection 1631086936 to pool.</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="RowBounds分页"><a href="#RowBounds分页" class="headerlink" title="RowBounds分页"></a>RowBounds分页</h2><p>不推荐, 在Mapper.xml中查询整个表单, 然后测试时摘取, 不高效</p>
<h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><p><a href="https://pagehelper.github.io/" target="_blank" rel="noopener">MyBatis分页插件 PageHelper</a></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200721163114.png" alt=""></p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java拾遗</title>
    <url>/2020/07/07/Java%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 语言基础中知识点繁多, 大多数只是在第一次学习时有印象, 但是因为长时间没有运用到会遗忘, 这篇博文就用来记录和总结遇到的生僻的知识点.</p>
<hr>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><code>abstract</code> 修饰符可以用来修饰方法, 也可以用来修饰类, 如果修饰方法, 那么该方法就是抽象方法; 如果修饰类, 那么该类就是抽象类.</p>
<ul>
<li>不能<code>new</code> 抽象类, 只能靠子类去实现它</li>
<li>抽象类中可以写普通方法</li>
<li>抽象方法必须在抽象类中</li>
</ul>
<hr>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>在接口中定义的常量会默认加上修饰符 <code>public static final</code>, 在实现了该接口的类中可以直接拿来用</li>
<li>在接口中定义的方法会默认加上修饰符 <code>pubilc abstract</code> </li>
<li>接口中没有构造方法, 这是不能被实例化的原因</li>
</ul>
<hr>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义以下的类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是外部类的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"这是内部类的方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个类中分别定义了各自的方法. 然后实例化外部类的对象, 对该类进行测试.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br><span class="line">        inner.in();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就要注意 <code>new</code> 内部类对象时写法上的区别了.</p>
<p>可以通过定义内部类的方法来获取外部类的私有属性, 修改外部类如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是外部类的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"这是内部类的方法"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过内部类的对象调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br><span class="line">        inner.in();</span><br><span class="line">        inner.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200707193414.png" alt=""></p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>在定义内部类时添加 <code>statc</code> 关键字即可. </p>
<p>因为创建内部类的方式与调用方法的步骤与成员内部类相同, 所以就不再赘述.</p>
<p>但是需要注意的是, 静态内部类是随外部类加载时创建的, 所以<strong>不能调用成员变量</strong>.</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>在外部类的方法中定义的类叫局部内部类.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"这是内部类的方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200707200724.png" alt=""></p>
<p><strong>Error</strong>:</p>
<p>通常是灾难性的致命的错误, 是程序员无法控制和处理的, 当出现这些异常时, JVM一般会终止线程</p>
<p><strong>Exception</strong>:</p>
<p>通常情况下是可以被程序处理, 并且在程序中应该尽可能的去处理这些异常</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>主动抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Demo01().test(a, b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(); <span class="comment">// 主动抛出异常, 一般在方法中使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>假设方法中处理不了这个异常, 直接在方法上抛出, 使用<code>throws</code> 关键字, 然后调用该方法时用<code>try-catch</code> 捕获处理</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>使用<code>try-catch</code>捕获异常并处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Demo01().test(a, b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"运算失败, 除数为0"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"调用结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> ArithmeticException</span>&#123;</span><br><span class="line">        System.out.println(a/b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运算失败, 除数为0</span><br><span class="line">调用结束</span><br></pre></td></tr></table></figure>

<h3 id="异常处理五个关键字"><a href="#异常处理五个关键字" class="headerlink" title="异常处理五个关键字"></a>异常处理五个关键字</h3><p><strong>try, catch, throw, throws, finally</strong></p>
<p>先看<code>try</code> , <code>catch</code>, <code>finally</code> 关键字的常见用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;   <span class="comment">// try监控区域</span></span><br><span class="line">        System.out.println(a / b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">// catch(想要捕获的异常类型)捕获异常</span></span><br><span class="line">        System.out.println(<span class="string">"程序出现异常, 变量b不能为0"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 处理善后工作</span></span><br><span class="line">        System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序出现异常, 变量b不能为0</span><br><span class="line">finally</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是<code>finally</code>, 不管是否能捕获到异常, 都会执行该代码块, 属于善后工作, 也可以不要</p>
<p>可以写多个<code>catch</code> 进行捕获, 如果要写多个的话,小的异常写上面, 层层递进, 大的写上面就给覆盖掉了</p>
<p><code>thow</code>和<code>throws</code> 的区别在于, 前者为方法中主动抛出异常, 后者是该方法中处理不了让调用该方法的方法通过<code>try-catch</code>处理.</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>创建自定义异常要继承<code>Exception</code> 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递数字 &gt; 10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detail = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toString: 异常的打印信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MyException&#123;"</span> + detail + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用该异常:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可能会存在异常的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"传递的参数为: "</span> + a);</span><br><span class="line">        <span class="keyword">if</span> (a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(a);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传递的参数为: 11</span><br><span class="line">MyException&#123;11&#125;</span><br></pre></td></tr></table></figure>



<p>在这段代码中, 判断<code>a&gt;10</code> 的时候抛出我们所定义的异常, 这里有两种处理方式, 一是在该方法中<code>try-catch</code> 进行异常的处理, 或者在方法层面抛出, 让该方法的调用者去<code>try-catch</code> 去处理. 这里采用的是第二种处理方法.</p>
<p>总之, 只要抛出了异常, 要么就地处理, 要么抛出去谁调用谁处理, 总是要还的.</p>
<p>以下是就地处理的代码和结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可能会存在异常的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"传递的参数为: "</span> + a);</span><br><span class="line">        <span class="keyword">if</span> (a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MyException(a);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传递的参数为: 11</span><br><span class="line">MyException&#123;11&#125;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p><strong>要注意输出的结果是不一样的!!</strong></p>
<hr>
<h2 id="类加载器与构造器的调用顺序"><a href="#类加载器与构造器的调用顺序" class="headerlink" title="类加载器与构造器的调用顺序"></a>类加载器与构造器的调用顺序</h2><p>今天遇到一个考察继承的题目, 牵涉到类加载器和构造器调用顺序的问题, 很有趣.</p>
<p><strong>问</strong>: new一个C02对象, 会输出什么信息?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n1 = getVal01();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"A02的一个静态代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"A02的第一个普通代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n3 = getVal02();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getVal01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal01"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal02"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A02的构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B02</span> <span class="keyword">extends</span> <span class="title">A02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n3 = getVal03();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"B02的一个静态代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n5 = getVal04();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"B02的第一个普通代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getVal03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal03"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal04"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B02的构造器"</span>);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C02</span> <span class="keyword">extends</span> <span class="title">B02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n6 = getVal06();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"C02的一个静态代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"C02的第一个普通代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n8 = getVal08();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getVal06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal06"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal08</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal08"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">C02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"C02的构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        C02 c = <span class="keyword">new</span> C02();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>:</p>
<p>这里有三个类,<code>A02</code>是父类, <code>B02</code>继承<code>A02</code>, <code>C02</code>继承<code>B02</code>. 每个类都有各自的静态代码块和无参构造器. </p>
<p>根据继承的特点可知, 当<code>new</code> 一个<code>C02</code>对象时, 会去调用<code>C02</code>的构造器, <code>C02</code>构造器第一行默认为<code>super()</code> , 即调用父类<code>B02</code>的构造器, 同理调用<code>A02</code> 的构造器, 然后顺序执行类<code>A02</code> 的代码 -&gt; <code>A02</code>构造器内的代码 -&gt; 顺序执行类<code>B02</code> 的代码 -&gt; <code>B02</code>构造器内的代码 -&gt; 顺序执行<code>C02</code> 的代码 -&gt; <code>C02</code> 构造器内的代码.</p>
<p>然而加了类构造器之后该是什么顺序呢?  直接贴结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getVal01</span><br><span class="line">A02的一个静态代码块..</span><br><span class="line">getVal03</span><br><span class="line">B02的一个静态代码块..</span><br><span class="line">getVal06</span><br><span class="line">C02的一个静态代码块..</span><br><span class="line">A02的第一个普通代码块..</span><br><span class="line">getVal02</span><br><span class="line">A02的构造器</span><br><span class="line">getVal04</span><br><span class="line">B02的第一个普通代码块..</span><br><span class="line">B02的构造器</span><br><span class="line">C02的第一个普通代码块..</span><br><span class="line">getVal08</span><br><span class="line">C02的构造器</span><br></pre></td></tr></table></figure>

<p>我们刚才分析的步骤是从第七行开始的, 后面全部严格按照分析的步骤打印信息, 所以可以得出结论: 类加载器工作的时间整体都在构造器之前.</p>
<p>不难看出, 类加载器的调用顺序与构造器是类似的, 也是从子类一路到父类, 然后再到子类. 更加严谨的调用顺序如下所述:</p>
<h3 id="类加载器调用顺序"><a href="#类加载器调用顺序" class="headerlink" title="类加载器调用顺序"></a>类加载器调用顺序</h3><p>JVM会用类加载器加载xxx.C02这个class文件</p>
<p>加载(class){</p>
<p>　　if(class有父类){</p>
<p>　　　　加载(superclass);</p>
<p>　　}</p>
<p>　　1.静态域申明,默认初始化为0,false,null</p>
<p>　　2.按照申明顺序(从上而下书写顺序)执行静态域(赋值)和静态代码块(执行代码块体),</p>
<p>　　　　二者等价,因此不可在静态代码块中<strong>使用</strong>位于代码块之后申明的静态域,但是<strong>可以初始化</strong></p>
<p>　　3.按照申明顺序加载静态方法</p>
<p>}</p>
<h3 id="构造器调用顺序"><a href="#构造器调用顺序" class="headerlink" title="构造器调用顺序"></a>构造器调用顺序</h3><ol>
<li><p>所有实例域初始化为默认值0,false,null</p>
</li>
<li><p>按照申明顺序执行域初始化及块初始化</p>
</li>
<li><p><strong>如果构造器”第一行”调用了其他构造器,则执行</strong></p>
</li>
<li><p>执行构造器体</p>
</li>
</ol>
<h3 id="方法调用顺序"><a href="#方法调用顺序" class="headerlink" title="方法调用顺序"></a>方法调用顺序</h3><ol>
<li><p>编译器查看对象的<strong>申明</strong>类型,找到它所有与方法名相同的方法</p>
</li>
<li><p>根据参数类型,找到相应”最合适”的父类方法可能会出现类型转换(向上转型)</p>
</li>
<li><p>如果是private,static,final,构造器 方法,那么已经确定就是该方法(这四种类型的方法没有多态特征),</p>
</li>
</ol>
<p>　　因为没有多态所以也叫静态绑定</p>
<ol start="4">
<li><p>如果是其他方式,采用动态绑定:JVM去寻找改类的实际类型中对应的最合适方法</p>
</li>
<li><p>执行调用</p>
</li>
</ol>
<p><strong>结合理论表述, 本题的顺序总结来说就是:</strong></p>
<ol>
<li>父类的静态代码块和静态属性(优先级一样，按定义顺序执行)</li>
<li>子类的静态代码块和静态属性(优先级一样，按定义顺序执行)</li>
<li>父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</li>
<li>子类的构造方法</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>接口</tag>
        <tag>内部类</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb小记</title>
    <url>/2020/07/05/JavaWeb%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h2><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li><p>编写一个类去实现Filter接口</p>
</li>
<li><p>实现过滤方法doFilter()</p>
</li>
<li><p>到web.xml中去配置Filter的拦截路径</p>
</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li><p>构造器方法</p>
</li>
<li><p>init 初始化方法</p>
<p> 第1,2步, 在web工程启动的时候执行(Filter已经创建)</p>
</li>
<li><p>doFilter 过滤方法</p>
<p> 第3步, 每次拦截到请求就会执行</p>
</li>
<li><p>destroy 销毁</p>
<p> 第4步, 停止web工程的时候,就会执行(停止web工程, 也会销毁Filter过滤器)</p>
</li>
</ol>
<h3 id="FilterConfig类"><a href="#FilterConfig类" class="headerlink" title="FilterConfig类"></a>FilterConfig类</h3><p>见名知义, 它是Filter过滤器的配置文件类</p>
<p>Tomcat 每次创建Filter的时候, 也会同时创建一个FilterConfig类, 这里包含了Filter配置文件的配置信息</p>
<p>FilterConfig类的作用是获取Filter过滤器的配置内容:</p>
<ol>
<li>获取Filter的名称 <code>filter-name</code>的内容</li>
</ol>
<pre><code>就是xml文件中`filter-name`的值</code></pre><ol>
<li><p>获取在Filter中配置的<code>init-param</code>初始化参数</p>
<p>  就是xml文件中自定义的’init-param’初始化参数</p>
</li>
<li><p>获取<code>ServletContext</code>对象</p>
<p> 获取ServletContext对象</p>
</li>
</ol>
<h3 id="FilterChain过滤器链"><a href="#FilterChain过滤器链" class="headerlink" title="FilterChain过滤器链"></a>FilterChain过滤器链</h3><p>  Filter:   过滤器</p>
<p>  Chain:   链, 链条</p>
<p>  FilterChain:   就是过滤器链(多个过滤器如何一起工作)</p>
<p>程序执行顺序:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/46a8eb9c7e647c684c0b92d098727b9b.png" alt=""></p>
<h3 id="Filter的拦截路径"><a href="#Filter的拦截路径" class="headerlink" title="Filter的拦截路径"></a>Filter的拦截路径</h3><ol>
<li>精确匹配</li>
</ol>
<pre><code>&lt;url-pattern&gt;/target.jsp&lt;/url-pattern&gt;

以上配置的路径, 表示请求地址必须为: http://ip:port/工程路径/target.jsp</code></pre><ol start="2">
<li><p>目录匹配</p>
<p> <url-pattern>/admin/*</url-pattern></p>
<p> 以上配置的路径, 表示请求地址必须为: <a href="http://ip:port/工程路径/admin/">http://ip:port/工程路径/admin/</a>*</p>
</li>
<li><p>后缀名匹配</p>
<p> <url-pattern>*.html</url-pattern></p>
<p> 以上配置的路径, 表示请求地址必须以 .html结尾才会拦截到</p>
</li>
</ol>
<p>Filter过滤器只关心请求的地址是否匹配,不关心请求的资源是否存在</p>
<h2 id="ThreadLocal-的使用"><a href="#ThreadLocal-的使用" class="headerlink" title="ThreadLocal 的使用"></a>ThreadLocal 的使用</h2><p>  ThreaLocal 的作用,它可以解决多线程的数据安全问题</p>
<p>  ThreaLocal 它可以给当前线程关联一个数据(可以是普通变量,可以是对象,也可以是数组,集合)</p>
<h3 id="ThreadLocal-的特点"><a href="#ThreadLocal-的特点" class="headerlink" title="ThreadLocal 的特点"></a>ThreadLocal 的特点</h3><ol>
<li><p>ThreadLocal 可以为当前线程关联一个数据. (它可以像Map一样存取数据, Key为当前线程)</p>
</li>
<li><p>每一个ThreadLocal对象, 只能为当前线程关联一个数据, 如果要为当前线程关联多个数据, 就需要使用多ThreadLocal对象实例</p>
</li>
<li><p>每个ThreadLocal对象实例定义的时候, 一般都是static 类型</p>
</li>
<li><p>ThreadLocal中保存的数据, 在线程销毁后.  会由JVM虚拟机自动释放.</p>
</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/0eaee7d2aeea706e84a7691e49a43806.png" alt=""></p>
<p>*<em>使用Filter过滤器统一给所有的 Service 方法都加上try-catch *</em></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3e75caf50d4eb4d75addbe3f17244f61.png" alt=""></p>
<p><strong>将所有异常都统一交给Tomcat，让Tomcat展示友好的错误信息页面</strong></p>
<p>在web.xml中我们可以通过错误页面配置来进行管理。</p>
<error-page>

</error-page>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是一种轻量级的数据交换格式。易于人阅读和编写，同时也易于机器解析和生成。JSON采用完全独立于语言的文本格式，而且很多语言都提供了对JSON的支持。</p>
<p>JSON是一种轻量级的数据交换格式, 轻量级指的是跟xml做比较.</p>
<p>数据交换指的是客户端和服务器之间业务数据的传递格式.</p>
<h3 id="JSON的定义"><a href="#JSON的定义" class="headerlink" title="JSON的定义"></a>JSON的定义</h3><p>JSON是由键值对组成, 并且由大括号包围, 每个键用引号引起来, 键和值之间使用冒号进行分隔, 多组键值对之间使用逗号进行分隔.</p>
<h3 id="JSON的访问"><a href="#JSON的访问" class="headerlink" title="JSON的访问"></a>JSON的访问</h3><p>json本身是一个对象, json中的key我们可以理解为是对象中的一个属性, json中的key 访问就跟访问对象的属性一样: json对象.key</p>
<h3 id="JSON-在-JAVA-中的应用"><a href="#JSON-在-JAVA-中的应用" class="headerlink" title="JSON 在 JAVA 中的应用"></a>JSON 在 JAVA 中的应用</h3><h4 id="javabean-和-json-的互转"><a href="#javabean-和-json-的互转" class="headerlink" title="javabean 和 json 的互转"></a>javabean 和 json 的互转</h4><ol>
<li><p>自定义一个<code>Javabean</code>, 创建一个示例对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"aaa!"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>Gson</code>对象, 并使用<code>toJson</code>方法将<code>person</code>对象转换成<code>json</code>对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">String personJsonString = gson.toJson(person);</span><br><span class="line">System.out.println(personJsonString);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704165732.png" alt=""></p>
</li>
<li><p>同样可以将字符串转换回<code>Person</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fromJson把json字符串转换回Java对象</span></span><br><span class="line"><span class="comment">// 第一个参数是json字符串</span></span><br><span class="line"><span class="comment">// 第二个参数是转换回去的Java对象</span></span><br><span class="line">Person person1 = gson.fromJson(personJsonString, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(person1);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
</li>
</ol>
<p>   <img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704165738.png" alt=""></p>
<p>   可以看出格式是使用了<code>Person</code>类的<code>toString</code>格式, 说明已经转回.</p>
<h4 id="List-和-json-的互传"><a href="#List-和-json-的互传" class="headerlink" title="List 和 json 的互传"></a>List 和 json 的互传</h4><ol>
<li><p>还是使用<code>Person</code>类,  定义多个示例对象放入<code>List</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"cx"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>Gson</code>对象, 依然使用<code>toJson</code>的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">String personListJsonString = gson.toJson(personList);</span><br><span class="line">System.out.println(personListJsonString);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704165836.png" alt=""></p>
</li>
<li><p>转回<code>Person</code>列表时, 还是使用<code>fromJson</code>方法, 但是第二个形参需要注意, <strong>不是</strong><code>personList.getClass()</code>, 那该将什么作为列表的格式呢.</p>
<blockquote>
<p>gson包自带了一个<code>TypeToken</code>类, 使用这个类可以解决困惑</p>
<ol>
<li><p>首先创建一个新的类<code>PersonListType</code>, 然后继承<code>TypeToken</code>类, 注意填入的泛型为需要转回的类型:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704164430.png" alt=""></p>
<p>这个类放在这里就可以了.</p>
</li>
<li><p>我们去看一下<code>TypeTokken</code>的源码, 可以看到一个关键的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法返回的就是我们所需要的格式, 因为是继承了这个类, 直接使用就可以了. 这样就解决了<code>fromJson()</code>方法中第二个形参写什么的问题.</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; list = gson.fromJson(personListJsonString, <span class="keyword">new</span> PersonListType().getType());</span><br><span class="line">        System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704165843.png" alt=""></p>
</li>
</ol>
<h4 id="Map-和-json-的互转"><a href="#Map-和-json-的互转" class="headerlink" title="Map 和 json 的互转"></a>Map 和 json 的互转</h4><ol>
<li><p>创建哈希表, 然后将<code>Person</code>示例对象添加进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Person&gt; personMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">personMap.put(<span class="number">1</span>, <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>));</span><br><span class="line">personMap.put(<span class="number">2</span>, <span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"cx"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>Gson</code>对象, 使用<code>toJson</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">String personMapJsonString = gson.toJson(personMap);</span><br><span class="line">System.out.println(personMapJsonString);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704171016.png" alt=""></p>
<p>这里就要注意与<code>List</code>互换的区别了. <code>List</code>转换成<code>json</code>对象时, 是将多个<code>json</code>对象放到一个列表中, 而<code>Map</code>转过去之后, 变成了嵌套的形式. </p>
</li>
<li><p>转回<code>Map</code>形式, 方法与上面类似, 也是定义一个继承<code>TypeToken</code>的类, 然后将其放入<code>fromJson</code>方法的第二个形参中.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Person&gt; map = gson.fromJson(personMapJsonString, <span class="keyword">new</span> PersonMapType().getType());</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704182530.png" alt=""></p>
</li>
</ol>
<h4 id="使用匿名内部类进行代码优化"><a href="#使用匿名内部类进行代码优化" class="headerlink" title="使用匿名内部类进行代码优化"></a>使用匿名内部类进行代码优化</h4><p>在与<code>List</code>和<code>Map</code>结构进行互换时, 都有专门定义一个类, 但都只是在声明时使用了一次, 所以可以使用匿名内部类来优化代码.以转回<code>Map</code>为例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Person&gt; map = gson.fromJson(personMapJsonString, <span class="keyword">new</span> TypeToken&lt;HashMap&lt;Integer, Person&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<h3 id="JSON-vs-XML"><a href="#JSON-vs-XML" class="headerlink" title="JSON vs XML"></a>JSON vs XML</h3><p>JSON 和 XML 都用于接收 web 服务端的数据, 在写法上有所不同</p>
<p>Json实例:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sites"</span>: [</span><br><span class="line">    &#123; <span class="attr">"name"</span>:<span class="string">"github"</span> , <span class="attr">"url"</span>:<span class="string">"www.github.com"</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">"name"</span>:<span class="string">"google"</span> , <span class="attr">"url"</span>:<span class="string">"www.google.com"</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">"name"</span>:<span class="string">"微博"</span> , <span class="attr">"url"</span>:<span class="string">"www.weibo.com"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML实例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sites</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>github<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.runoob.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>google<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.google.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>微博<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.weibo.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sites</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>两者的相同之处:</p>
<ul>
<li>JSON 和 XML 数据都是 “自我描述” ，都易于理解。</li>
<li>JSON 和 XML 数据都是有层次的结构</li>
<li>JSON 和 XML 数据可以被大多数编程语言使用</li>
</ul>
<p>两者不同之处:</p>
<ul>
<li>JSON 不需要结束标签</li>
<li>JSON 更加简短</li>
<li>JSON 读写速度更快</li>
<li>JSON 可以使用数组</li>
</ul>
<p>最大的不同之处:</p>
<p>XML 需要使用 XML 解析器来解析，JSON 可以使用标准的 JavaScript 函数来解析。</p>
<ul>
<li><p><code>JSON.parse()</code>: 将一个 JSON 字符串转换为 JavaScript 对象。</p>
</li>
<li><p><code>JSON.stringify()</code>: 于将 JavaScript 值转换为 JSON 字符串。</p>
</li>
</ul>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="AJAX定义"><a href="#AJAX定义" class="headerlink" title="AJAX定义"></a>AJAX定义</h3><p>AJAX即”Asynchronous Javascript And XML”(异步 JavaScript和XML), 是指一种创建交互式网页应用的网页开发技术.</p>
<p><strong>AJAX是一种浏览器通过js异步发起请求, 局部更新页面的技术</strong></p>
<p>异步请求能大大提升用户体验, 不同请求各自响应, 不需要排队等候</p>
<p>AJAX请求局部更新, 浏览器地址栏不会发生变化, 局部更新不会舍弃原来页面的内容</p>
<h3 id="原生AJAX实例"><a href="#原生AJAX实例" class="headerlink" title="原生AJAX实例"></a>原生AJAX实例</h3><ol>
<li><p>编写<code>AjaxServlet</code>类, 让它继承<code>BaseServlet</code>类。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705114824.png" alt=""></p>
<p>然后在<code>web.xml</code>文件中修改配置</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705115150.png" alt=""></p>
</li>
<li><p>在<code>ajax.html</code>页面中编写js代码设置<code>ajax</code>请求, 这里要用到<code>.open()</code>方法, 然后用<code>.send()</code>方法来发送请求.注释中写明了具体的步骤.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"cache-control"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Expires"</span> <span class="attr">content</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 在这里使用JavaScript语言发起Ajax请求, 访问服务器AjaxServlet中的javaScriptAjax</span></span></span><br><span class="line"><span class="actionscript">			<span class="function"><span class="keyword">function</span> <span class="title">ajaxRequest</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 				1、我们首先要创建XMLHttpRequest </span></span></span><br><span class="line"><span class="actionscript">				<span class="keyword">var</span> xmlhttprequest = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 				2、调用open方法设置请求参数</span></span></span><br><span class="line"><span class="actionscript">				xmlhttprequest.open(<span class="string">"Get"</span>, <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet?action=javaScriptAjax"</span>, <span class="literal">true</span>)</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 				3、调用send方法发送请求</span></span></span><br><span class="line">				xmlhttprequest.send();</span><br><span class="line"><span class="actionscript"><span class="comment">// 				4、在send方法前绑定onreadystatechange事件，处理请求完成后的操作。</span></span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>	</span><br><span class="line">		<span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"ajaxRequest()"</span>&gt;</span>ajax request<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div01"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>AjaxServlet</code>中编写请求处理方法. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">javaScriptAjax</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ajax请求过来了"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>点击<code>html</code>页面的请求按钮之后, 控制台输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705141743.png" alt=""></p>
<p>说明能够正确接收到网页发送的<code>ajax</code>请求.</p>
</li>
<li><p>向客户端发送信息, 采用<code>json</code>字符串的形式. 如果需要获取来自服务器的相应, 使用<code>XMLHttpRequest</code>对象的<code>responseText</code>或<code>responseXML</code>属性.</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>responseText</td>
<td>获得字符串形式的响应数据</td>
</tr>
<tr>
<td>responseXML</td>
<td>获得XML形式的响应数据</td>
</tr>
</tbody></table>
<p>当请求被发送到服务器时, 需要执行一些基于响应的任务. 每当<code>readyState</code>改变时, 就会触发<code>onreadystatechange</code>事件.</p>
<p><code>readyState</code>属性存有<code>XMLHttpRequest</code>的状态信息</p>
<p>下面是<code>XMLHttpRequest</code>对象的三个重要属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>onreadystatechange</td>
<td>存储函数(或函数名), 每当readyState属性改变时, 就会调用该函数</td>
</tr>
<tr>
<td>readyState</td>
<td>存有XMLHttpRequest的状态.从0到4发生变化</td>
</tr>
<tr>
<td>status</td>
<td>200:”OK”, 404:”未找到页面”</td>
</tr>
</tbody></table>
<p>其中<code>readyState</code>的值表达的含义为:</p>
<ul>
<li>0: 请求未初始化</li>
<li>1: 服务器连接已建立</li>
<li>2: 请求已接收</li>
<li>3: 请求处理中</li>
<li>4: 请求已完成, 且响应已就绪</li>
</ul>
<p>也就是说我们从客户端向服务器发送了请求, 服务器处理完成后发出了响应, 这个过程中都伴随着这三个属性的变化. </p>
<p>对服务器响应所执行的任务我们写在<code>onreadystatechange</code>事件中, 这里理所应当地添加上状态已就绪的条件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttprequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (xmlhttprequest.readyState == <span class="number">4</span> &amp;&amp; xmlhttprequest.status == <span class="number">200</span>) &#123;</span><br><span class="line">                    alert(xmlhttprequest.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是, <code>onreadystatechange</code>事件要在<code>send()</code>方法之前绑定.</p>
<p>这里传给客户端的信息为一个<code>Person</code>实例, 在<code>AjaxServlet</code>程序中编写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">javaScriptAjax</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ajax请求过来了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line">        </span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>页面输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705150355.png" alt=""></p>
<p>把返回的数据显示在页面上:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttprequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (xmlhttprequest.readyState == <span class="number">4</span> &amp;&amp; xmlhttprequest.status == <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="built_in">document</span>.getElementById(<span class="string">"div01"</span>).innerHTML = xmlhttprequest.responseText;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>页面为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705150625.png" alt=""></p>
<p>对返回的<code>json</code>对象进行操作, 提取对象中的值:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttprequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (xmlhttprequest.readyState == <span class="number">4</span> &amp;&amp; xmlhttprequest.status == <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="keyword">let</span> jsonObj = <span class="built_in">JSON</span>.parse(xmlhttprequest.responseText);</span><br><span class="line">                    <span class="built_in">document</span>.getElementById(<span class="string">"div01"</span>).innerHTML = <span class="string">"编号: "</span>+ jsonObj.id + <span class="string">", 姓名: "</span>+ jsonObj.name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>页面为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705151411.png" alt=""></p>
</li>
</ol>
<h3 id="jQuery-中的-AJAX-请求"><a href="#jQuery-中的-AJAX-请求" class="headerlink" title="jQuery 中的 AJAX 请求"></a>jQuery 中的 AJAX 请求</h3><p>一般不会写原生的AJAX请求, 更多的是依托与框架.</p>
<h4 id="ajax-方法"><a href="#ajax-方法" class="headerlink" title="$.ajax 方法"></a><code>$.ajax</code> 方法</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>表示请求的地址</td>
</tr>
<tr>
<td>type</td>
<td>表示请求的类型GET或POST</td>
</tr>
<tr>
<td>data</td>
<td>表示发送给服务器的数据</td>
</tr>
<tr>
<td>success</td>
<td>请求响应, 响应的回调函数</td>
</tr>
<tr>
<td>dataType</td>
<td>响应的数据类型, 常用的类型有: text 表示纯文本, xml 表示xml数据 , json 表示json对象</td>
</tr>
</tbody></table>
<p>在<code>html</code> 页面中添加相应的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax请求</span></span><br><span class="line">            $(<span class="string">"#ajaxBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url: <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet"</span>,</span><br><span class="line">                    data: <span class="string">"action=jQueryAjax"</span>,</span><br><span class="line">                    type: <span class="string">"GET"</span>,</span><br><span class="line">                    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        alert(<span class="string">"服务器返回的数据是: "</span> + data);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    dataType: <span class="string">"text"</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>success</code> 后跟的<code>function</code> 括号中要写入服务器返回的数据. </p>
<p>在<code>AjaxServlet</code> 类中编写请求处理方法, 为了区别于上面的原生<code>AJAX</code>实例, 再写一个<code>jQueryAjax</code> 方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQueryAjax</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQueryAjax == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705160736.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705161352.png" alt=""></p>
<p>依然是对返回的<code>JSON</code> 字符串进行操作, 使它显示得更直观.</p>
<p>在页面中合适的地方添加<code>&lt;div&gt;&lt;/div&gt;</code>块, 然后修改<code>success</code> 属性:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// alert("服务器返回的数据是: " + data);</span></span><br><span class="line">                        <span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">                        $(<span class="string">"msg"</span>).html(<span class="string">"编号: "</span> + jsonObj.id + <span class="string">" , 姓名:"</span> + jsonObj.name);</span><br><span class="line">                    &#125;,</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705162117.png" alt=""></p>
<p><strong>如果<code>dataType</code> 属性填的是<code>json</code>, 会自动转为<code>json</code> 对象, 不需要再手动转换.</strong></p>
<h4 id="get-方法和-post-方法"><a href="#get-方法和-post-方法" class="headerlink" title="$.get 方法和 $.post 方法"></a><code>$.get</code> 方法和 <code>$.post</code> 方法</h4><blockquote>
<p>这两个方法本质就是把上面的方法中的<code>type</code> 属性固定下来</p>
</blockquote>
<p><strong>$.get方法</strong></p>
<p>通过远程 HTTP GET 请求载入信息</p>
<p>这是一个简单的GET请求功能以取代复杂的<code>$.ajax</code>. 请求成功时可调用回调函数. 如果需要在出错时执行函数, 需要使用<code>$.ajax</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>请求的地址</td>
</tr>
<tr>
<td>data</td>
<td>发送的数据</td>
</tr>
<tr>
<td>callback</td>
<td>成功的回调函数</td>
</tr>
<tr>
<td>type</td>
<td>返回的数据类型</td>
</tr>
</tbody></table>
<p>比<code>$.ajax</code> 少了<code>type</code>属性, 因为方式已经确定</p>
<p>在<code>html</code>页面中编写:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax--get请求</span></span><br><span class="line">            $(<span class="string">"#getBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// get请求</span></span><br><span class="line">                $.<span class="keyword">get</span>(</span><br><span class="line">                    "http://localhost:8080/json_ajax_i18n/ajaxServlet",</span><br><span class="line">                    "action=jQueryGet",</span><br><span class="line">                    function (data) &#123;</span><br><span class="line">                        <span class="comment">// alert("服务器返回的数据是: " + data);</span></span><br><span class="line">                        $(<span class="string">"#msg"</span>).html(<span class="string">"get 编号: "</span> + data.id + <span class="string">" , 姓名:"</span> + data.name);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"json"</span></span><br><span class="line">                );</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>在<code>AjaxServlet</code>类中编写<code>get</code> 请求处理方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQueryGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQueryGet == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705165624.png" alt=""></p>
<p><strong>$.post</strong>方法</p>
<p>函数调用的属性与<code>get</code>一模一样, 直接贴出代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax--post请求</span></span><br><span class="line">            $(<span class="string">"#postBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// post请求</span></span><br><span class="line">                $.post(</span><br><span class="line">                    <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet"</span>,</span><br><span class="line">                    <span class="string">"action=jQueryPost"</span>,</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// alert("服务器返回的数据是: " + data);</span></span><br><span class="line">                        $(<span class="string">"#msg"</span>).html(<span class="string">"post 编号: "</span> + data.id + <span class="string">" , 姓名:"</span> + data.name);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"json"</span></span><br><span class="line">                );</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQueryPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQueryPost == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705165818.png" alt=""></p>
<h4 id="getJSON-方法"><a href="#getJSON-方法" class="headerlink" title="$.getJSON 方法"></a><code>$.getJSON</code> 方法</h4><p>通过 GET 请求载入 JSON 数据</p>
<blockquote>
<p>本质上就是<code>$.get</code> 方法中的<code>dataType</code>属性被固定成<code>json</code> </p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>请求的地址</td>
</tr>
<tr>
<td>data</td>
<td>发送的数据</td>
</tr>
<tr>
<td>callback</td>
<td>成功的回调函数</td>
</tr>
</tbody></table>
<p>直接贴代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax--getJson请求</span></span><br><span class="line">            $(<span class="string">"#getJSONBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 调用</span></span><br><span class="line">                $.getJSON(</span><br><span class="line">                    <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet"</span>,</span><br><span class="line">                    <span class="string">"action=jQueryGetJson"</span>,</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// alert("服务器返回的数据是: " + data);</span></span><br><span class="line">                        $(<span class="string">"#msg"</span>).html(<span class="string">"getJson 编号: "</span> + data.id + <span class="string">" , 姓名:"</span> + data.name);</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQueryGetJson</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQueryGetJson == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705211905.png" alt=""></p>
<h4 id="serialize-方法"><a href="#serialize-方法" class="headerlink" title="serialize()方法"></a><code>serialize()</code>方法</h4><p>可以把表单中所有表单项的内容都获取到, 并以 name=value&amp;name=value 的形式进行拼接.</p>
<p>首先创建一个表单:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form01"</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    下拉单选：<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"single"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Single"</span>&gt;</span>Single<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Single2"</span>&gt;</span>Single2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    下拉多选：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"multiple"</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span> <span class="attr">value</span>=<span class="string">"Multiple"</span>&gt;</span>Multiple<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Multiple2"</span>&gt;</span>Multiple2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span> <span class="attr">value</span>=<span class="string">"Multiple3"</span>&gt;</span>Multiple3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    复选：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"check"</span> <span class="attr">value</span>=<span class="string">"check1"</span>/&gt;</span> check1</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"check"</span> <span class="attr">value</span>=<span class="string">"check2"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span> check2<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    单选：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"radio1"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span> radio1</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"radio2"</span>/&gt;</span> radio2<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit"</span>&gt;</span>提交--serialize()<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表单效果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705212249.png" alt=""></p>
<p>之前的做法是将整个表单都提交, 现在只需要提交键值即可.</p>
<p>在按钮的单击事件中添加:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert($(<span class="string">"#form01"</span>).serialize());</span><br></pre></td></tr></table></figure>

<p>然后随便填写表单, 输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705213127.png" alt=""></p>
<p>已经获取参数并拼接好.</p>
<p>修改客户端代码将所有参数都发给服务器:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.getJSON(</span><br><span class="line">                    <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet"</span>,</span><br><span class="line">                    <span class="string">"action=jQuerySerialize&amp;"</span> + $(<span class="string">"#form01"</span>).serialize(),</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        $(<span class="string">"#msg"</span>).html(<span class="string">"jQuerySerialize 编号: "</span> + data.id + <span class="string">" , 姓名:"</span> + data.name);</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br></pre></td></tr></table></figure>

<p>然后在服务器端接收:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQuerySerialize</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQuerySerialize == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"用户名: "</span> + req.getParameter(<span class="string">"username"</span>));</span><br><span class="line">        System.out.println(<span class="string">"密码: "</span> + req.getParameter(<span class="string">"password"</span>));</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>随便填写表单, 输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705214305.png" alt=""></p>
<h2 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h2><p>国际化三要素:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705231026.png" alt=""></p>
]]></content>
      <categories>
        <category>Javaweb</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
        <tag>Filter</tag>
        <tag>Json</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-多对一和一对多的处理</title>
    <url>/2020/07/22/Mybatis-%E5%A4%9A%E5%AF%B9%E4%B8%80%E5%92%8C%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<ul>
<li><p>多个学生, 对应一个老师</p>
</li>
<li><p>对于学生而言, 多个学生, 关联一个老师 [多对一]</p>
</li>
<li><p>对于老师而言, 一个老师有很多学生 [一对多]</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200722152318.png" alt=""></p>
</li>
</ul>
<h1 id="复杂查询环境搭建"><a href="#复杂查询环境搭建" class="headerlink" title="复杂查询环境搭建"></a>复杂查询环境搭建</h1><p>创建<code>teacher</code> 表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`teacher`</span> (</span><br><span class="line"> <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> teacher (<span class="string">`id`</span>, <span class="string">`name`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'lxb'</span>);</span><br></pre></td></tr></table></figure>

<p>创建<code>student</code> 表:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line"> <span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"> <span class="string">`tid`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"> <span class="keyword">KEY</span> <span class="string">`fktid`</span> (<span class="string">`tid`</span>),</span><br><span class="line"> <span class="keyword">CONSTRAINT</span> <span class="string">`fktid`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`tid`</span>) <span class="keyword">REFERENCES</span> <span class="string">`teacher`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`tid`</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'小明'</span>, <span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`tid`</span>) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'小红'</span>, <span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`tid`</span>) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'小张'</span>, <span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`tid`</span>) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">'小李'</span>, <span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`student`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`tid`</span>) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">'小王'</span>, <span class="string">'1'</span>);</span><br></pre></td></tr></table></figure>

<p>新建一个Maven项目, 设置好核心配置文件, 新建<code>teacher</code>和<code>student</code>类</p>
<p>然后老师对应一个Mapper接口, 学生对应一个Mapper接口</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200722155054.png" alt=""></p>
<h1 id="多对一处理"><a href="#多对一处理" class="headerlink" title="多对一处理"></a>多对一处理</h1><p><strong>查询所有的学生信息, 以及对应的老师的信息</strong></p>
<p>查询所使用的SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s.id, s.name, t.name <span class="keyword">from</span> student s , teacher t  <span class="keyword">where</span> s.tid = t.id;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>编写接口中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getStudents</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Mapper中编写SQL语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudents"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    select * from student s , teacher t  where s.tid = t.id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line">   </span><br><span class="line">    StudentMapper mapper = sqlSession.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    List&lt;Student&gt; students = mapper.getStudents();</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200722171858.png" alt=""></p>
<p>可以看到无法正确输出老师的信息</p>
</li>
</ol>
<h2 id="按照查询嵌套处理"><a href="#按照查询嵌套处理" class="headerlink" title="按照查询嵌套处理"></a>按照查询嵌套处理</h2><p><strong>相当于子查询</strong></p>
<ol>
<li><p>查询所有的学生信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudents"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    select * from mybatis.student ;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据查询出来的学生的tid, 寻找对应的老师</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    select * from mybatis.teacher where id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来的工作只是把这两个语句联系起来</p>
</li>
<li><p>使用resultMap来进行关联</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudents"</span> <span class="attr">resultMap</span>=<span class="string">"StudentTeacher"</span>&gt;</span></span><br><span class="line">    select * from mybatis.student ;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"StudentTeacher"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">column</span>=<span class="string">"tid"</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"Teacher"</span> 			   <span class="attr">select</span>=<span class="string">"getTeacher"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    select * from mybatis.teacher where id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>意思就是把student表中的<code>tid</code>属性绑定上一个Java对象, 这个对象的类型是<code>Teacher</code> , 并且是由<code>getTeacher</code>方法查询出来的</p>
<p>结果为：</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200722192339.png" alt=""></p>
</li>
</ol>
<h2 id="按照结果嵌套处理"><a href="#按照结果嵌套处理" class="headerlink" title="按照结果嵌套处理"></a>按照结果嵌套处理</h2><p><strong>相当于联表查询</strong></p>
<ol>
<li><p>新创建一个方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Student&gt; <span class="title">getStudents2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Mapper中进行绑定</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent2"</span> <span class="attr">resultMap</span>=<span class="string">"StudentTeacher2"</span>&gt;</span></span><br><span class="line">    select s.id sid, s.name sname, t.name tname</span><br><span class="line">    from mybatis.student s,mybatis.teacher t</span><br><span class="line">    where s.tid = t.id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"StudentTeacher2"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"sid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"sname"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">column</span>=<span class="string">"tid"</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"tname"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里没有将SQL语句进行嵌套, 而是直接把每个对应的属性写死</p>
</li>
<li><p>测试与输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line">    StudentMapper mapper = sqlSession.getMapper(StudentMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    List&lt;Student&gt; studentList = mapper.getStudents2();</span><br><span class="line">    <span class="keyword">for</span> (Student student : studentList) &#123;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200722201548.png" alt=""></p>
</li>
</ol>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven环境搭建</title>
    <url>/2020/07/15/Maven%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>为什么要学习这个技术</strong></p>
<ol>
<li><p>在Javaweb开发中, 需要使用大量的jar包, 我们手动去导入</p>
</li>
<li><p>如何能够让一个东西自动帮我们导入和配置这个jar包</p>
<p>由此, Maven诞生了</p>
</li>
</ol>
<p><strong>Maven项目架构管理工具</strong></p>
<p>我们目前用来就是导入jar包的</p>
<p><strong>核心思想:</strong><br>约定大于配置!</p>
<ul>
<li>有约束, 不要去违反</li>
<li>Maven会规定好该如何去编写我们的Java代码</li>
</ul>
<h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>进入官网</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716093403.png" alt=""></p>
<ol start="2">
<li>选择下载</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200715215433.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200715215558.png" alt=""></p>
<p>下载完成后解压即可.</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ol>
<li>配置系统环境变量</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716093827.png" alt=""></p>
<ol start="2">
<li>编辑path变量</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716093838.png" alt=""></p>
<ol start="3">
<li>配置好以后测试是否完成</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200715221700.png" alt=""></p>
<h2 id="阿里云镜像"><a href="#阿里云镜像" class="headerlink" title="阿里云镜像"></a>阿里云镜像</h2><ul>
<li>加速我们的下载</li>
<li>国内建议使用阿里云镜像</li>
</ul>
<p>打开conf目录下的settings.xml文件, 修改如下:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716095513.png" alt=""></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*,!jeecg,!jeecg-snapshots<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><p>在本地建立一个仓库</p>
<ol>
<li>在目录下新建文件夹作为本地仓库</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716094843.png" alt=""></p>
<ol start="2">
<li>在settings.xml文件中进行修改</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716095005.png" alt=""></p>
<h1 id="IDEA里的Maven操作"><a href="#IDEA里的Maven操作" class="headerlink" title="IDEA里的Maven操作"></a>IDEA里的Maven操作</h1><h2 id="创建一个MavenWeb项目"><a href="#创建一个MavenWeb项目" class="headerlink" title="创建一个MavenWeb项目"></a>创建一个MavenWeb项目</h2><ol>
<li>新建Maven项目, 选择一个模板</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716100008.png" alt=""></p>
<ol start="2">
<li>填写项目信息</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716100404.png" alt=""></p>
<p>​        GroupId:  组名</p>
<p>​        ArtifactId: 项目名</p>
<ol start="3">
<li>填写Maven目录信息</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716100914.png" alt=""></p>
<ol start="4">
<li><p>等待项目初始化完毕</p>
</li>
<li><p>观察Maven仓库中多了什么东西</p>
</li>
</ol>
<p><img src="C:%5CUsers%5Clxb%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20200716104455.png" alt="QQ截图20200716104455"></p>
<h2 id="IDEA中的Maven设置"><a href="#IDEA中的Maven设置" class="headerlink" title="IDEA中的Maven设置"></a>IDEA中的Maven设置</h2><p>IDEA项目创建成功后, 看一眼设置</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716104702.png" alt=""></p>
<p>到这里, Maven在IDEA中的配置就完成了</p>
<h2 id="创建一个普通的Maven项目"><a href="#创建一个普通的Maven项目" class="headerlink" title="创建一个普通的Maven项目"></a>创建一个普通的Maven项目</h2><p>这次不勾选模板</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716105926.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716111928.png" alt=""></p>
<p>一个干净的Maven项目</p>
<h2 id="标记文件夹功能"><a href="#标记文件夹功能" class="headerlink" title="标记文件夹功能"></a>标记文件夹功能</h2><p>Maven项目中每个目录都有各自的作用, 如果单纯新建一个空目录是不能新建Class类文件的, 做法是将新建的目录标记为特定的类型:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716112439.png" alt=""></p>
<h2 id="在IDEA中配置TOMCAT"><a href="#在IDEA中配置TOMCAT" class="headerlink" title="在IDEA中配置TOMCAT"></a>在IDEA中配置TOMCAT</h2><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716135757.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716135843.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716140906.png" alt=""></p>
<p>因为新建的WEB项目中的web.xml文件初试版本号与本地版本号不一致, 所以需要去看一下.</p>
<p>IDEA默认初试为2.3, 打开以下地址:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\tomcat\apache-tomcat-8.0.50\webapps\ROOT\WEB-INF</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment">  contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment">  this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment">  The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment">  (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment">  the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">"3.1"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Welcome to Tomcat<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">     Welcome to Tomcat</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到是3.1的版本, 直接全部复制, 把IDEA中的web.xml文件替换掉.</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716152626.png" alt=""></p>
<p>配置好之后就可以正常启动Tomcat服务器了. 网址中端口号之后的字符就是自定义的项目映射地址</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716140245.png" alt=""></p>
<h2 id="Maven部件"><a href="#Maven部件" class="headerlink" title="Maven部件"></a>Maven部件</h2><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716141521.png" alt=""></p>
<h2 id="porm文件"><a href="#porm文件" class="headerlink" title="porm文件"></a>porm文件</h2><p>porm.xml是Maven的核心配置文件</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716154947.png" alt=""></p>
<p>需要什么包, 直接去Maven仓库里搜索, 然后将依赖语句添加到这里即可</p>
<h1 id="更多Maven讲解"><a href="#更多Maven讲解" class="headerlink" title="更多Maven讲解"></a>更多Maven讲解</h1><ol>
<li>构建一个普通的Maven项目, 删掉里面的<code>src</code>目录, 这个空工程就是Maven主工程, 往里创建<code>Moudel</code>即可. </li>
<li>新建一个servlet子模块, 会有父模块的选项</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716185339.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716185653.png" alt=""></p>
<p>​        可以看到列表中多了一个Maven模块    </p>
<ol start="3">
<li><p>关于Maven父子工程的理解:</p>
<ul>
<li>每创建一个子模块, 都会自带一个porm.xml文件</li>
<li>在父项目的porm.xml文件中会多出</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>servlet01<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在子项目的porm.xml文件中有</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-learning04<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>父项目的jar包子项目可以直接使用</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis使用注解</title>
    <url>/2020/07/22/Mybatis%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>使用注解可以代替通过xml文件映射, 在接口中使用注解引用sql语句, 然后核心配置文件中, 将该类放入映射器.</p>
<h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><ol>
<li><p>定义接口, 写入sql语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法存在多个参数, 所有的参数前面必须加上@Param(" ")注解</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getUserByID</span><span class="params">(@Param(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在核心配置文件中将该类加入映射器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.lxb.dao.UserMapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUsersTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    List&lt;User&gt; users = mapper.getUsers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByIDTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    User user = mapper.getUserByID(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够正常输出</p>
</li>
</ol>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ol>
<li><pre><code class="java"><span class="meta">@Insert</span>(<span class="string">"insert into user(id, name, pwd) values (#{id}, #{name}, #{pwd})"</span>)
<span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;
&lt;!--￼<span class="number">3</span>--&gt;

注意这里没有手动提交事物是因为在`openSession()`的方法中传入了`<span class="keyword">true</span>` 来自动提交事物
</code></pre>
</li>
</ol>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ol>
<li><pre><code class="java"><span class="meta">@Update</span>(<span class="string">"update user set name = #{name}, pwd=#{pwd} where id=#{id}"</span>)
<span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;
&lt;!--￼<span class="number">4</span>--&gt;
</code></pre>
</li>
</ol>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ol>
<li><pre><code class="java"><span class="meta">@Delete</span>(<span class="string">"delete from user where id=#{id}"</span>)
<span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(@Param(<span class="string">"id"</span>)</span> <span class="keyword">int</span> id)</span>;
&lt;!--￼<span class="number">5</span>--&gt;
</code></pre>
</li>
</ol>
<h1 id="关于-Param-注解"><a href="#关于-Param-注解" class="headerlink" title="关于@Param()注解"></a>关于@Param()注解</h1><ul>
<li>基本类型的参数或者String类型, 需要加上</li>
<li>引用类型不需要加</li>
<li>如果只有一个基本类型的话, 可以忽略, 但是建议加上</li>
<li>我们在SQL中引用的就是这里设定的属性名</li>
</ul>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis日志</title>
    <url>/2020/07/20/Mybatis%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="日志工厂"><a href="#日志工厂" class="headerlink" title="日志工厂"></a>日志工厂</h1><p>如果一个数据库操作出现了异常, 我们需要排错, 日志就是最好的帮手</p>
<p>以前: sout println</p>
<p>现在: 日志工厂 !</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200720152350.png" alt=""></p>
<ul>
<li><strong>SLF4J</strong> </li>
<li><strong>LOG4J</strong> </li>
<li>LOG4J2 </li>
<li>JDK_LOGGING </li>
<li>COMMONS_LOGGING </li>
<li><strong>STDOUT_LOGGING</strong> </li>
<li>NO_LOGGING</li>
</ul>
<p>在Mybatis中具体使用哪一个日志实现, 在设置中设定</p>
<h2 id="STDOUT-LOGGING"><a href="#STDOUT-LOGGING" class="headerlink" title="STDOUT_LOGGING"></a>STDOUT_LOGGING</h2><p>这是一个标准的日志工厂实现, 可以直接用.</p>
<ol>
<li><p>在核心配置文件中添加settings标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Opening JDBC Connection</span><br><span class="line">Created connection 1073763441.</span><br><span class="line">Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@40005471]</span><br><span class="line">&#x3D;&#x3D;&gt;  Preparing: select * from mybatis.user where id &#x3D; ?; </span><br><span class="line">&#x3D;&#x3D;&gt; Parameters: 2(Integer)</span><br><span class="line">&lt;&#x3D;&#x3D;    Columns: id, name, pwd</span><br><span class="line">&lt;&#x3D;&#x3D;        Row: 2, John, 123456</span><br><span class="line">&lt;&#x3D;&#x3D;      Total: 1</span><br><span class="line">User&#123;id&#x3D;2, name&#x3D;&#39;John&#39;, password&#x3D;&#39;123456&#39;&#125;</span><br><span class="line">Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@40005471]</span><br><span class="line">Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@40005471]</span><br><span class="line">Returned connection 1073763441 to pool.</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="LOG4J"><a href="#LOG4J" class="headerlink" title="LOG4J"></a>LOG4J</h2><p>Log4j是<a href="https://baike.baidu.com/item/Apache/8512995" target="_blank" rel="noopener">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p>
<ol>
<li><p>导入log4j的包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建properties配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG,console,file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台输出的相关设置</span></span><br><span class="line"><span class="meta">log4j.appender.console</span> = <span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.Target</span> = <span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.console.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">[%c]-%m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#文件输出的相关设置</span></span><br><span class="line"><span class="meta">log4j.appender.file</span> = <span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.file.File</span>=<span class="string">./log/xlb.log</span></span><br><span class="line"><span class="meta">log4j.appender.file.MaxFileSize</span>=<span class="string">10mb</span></span><br><span class="line"><span class="meta">log4j.appender.file.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="string">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#日志输出级别</span></span><br><span class="line"><span class="meta">log4j.logger.org.mybatis</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.Statement</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.ResultSet</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在核心配置文件中修改相关语句:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接运行刚才的测试文件:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200720160554.png" alt=""></p>
</li>
</ol>
<p><strong>简单使用</strong></p>
<ol>
<li><p>在要使用log4j的包, 应该选择阿帕奇的包, 而不是JDK自带的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志对象, 加载参数为当前类的class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Logger logger = Logger.getLogger(UserMapperTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志级别:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log4jTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    logger.info(<span class="string">"info: 进入了log4jTest"</span>);</span><br><span class="line">    logger.debug(<span class="string">"debug: 进入了log4jTest"</span>);</span><br><span class="line">    logger.error(<span class="string">"error: 进入了log4j"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[INFO][20-07-20][com.lxb.dao.UserMapperTest]info: 进入了log4jTest</span><br><span class="line">[DEBUG][20-07-20][com.lxb.dao.UserMapperTest]debug: 进入了log4jTest</span><br><span class="line">[ERROR][20-07-20][com.lxb.dao.UserMapperTest]error: 进入了log4j</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的增删改查操作</title>
    <url>/2020/07/19/Mybatis%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h1><p>selcet, 选择, 查询语句</p>
<p>对以下代码分析:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lxb.dao.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserList"</span> <span class="attr">resultType</span>=<span class="string">"com.lxb.pojo.User"</span>&gt;</span></span><br><span class="line">        select * from mybatis.user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>id: 就是对应的namespace中的方法名</p>
</li>
<li><p>resultType: SQL语句执行的返回值</p>
</li>
<li><p>parameterType: 传入参数的类型</p>
</li>
</ul>
<p>再来写一个根据<code>id</code> 查询的例子:</p>
<ol>
<li><p>在接口中添加方法名:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取全部用户</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>UserMapper.xml</code> 文件中添加标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.lxb.pojo.User"</span>&gt;</span></span><br><span class="line">    select * from mybatis.user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在测试类中进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    User user = mapper.getUserById(<span class="number">2</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭SqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200719190734.png" alt=""></p>
<p>比之前方便太多了!!</p>
</li>
</ol>
<h1 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h1><ol>
<li><p>在接口中添加方法名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取全部用户</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>UserMapper.xml</code> 文件中添加标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.lxb.pojo.User"</span>&gt;</span></span><br><span class="line">    insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在测试类中进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    mapper.addUser(<span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">"啦啦啦"</span>, <span class="string">"89746"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭SqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是结果并没有添加成功：</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200719192012.png" alt=""></p>
<p><strong>这是因为增删改必须要提交事物</strong></p>
</li>
<li><p>添加提交事务的语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    mapper.addUser(<span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">"啦啦啦"</span>, <span class="string">"89746"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事物</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭SqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再进行查询, 就发现成功了, 不再贴出来</p>
</li>
</ol>
<h1 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h1><ol>
<li><p>在接口中添加方法名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取全部用户</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>UserMapper.xml</code> 文件中添加标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.lxb.pojo.User"</span>&gt;</span></span><br><span class="line">    update mybatis.user set name = #&#123;name&#125;,pwd = #&#123;pwd&#125; where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在测试类中进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    mapper.updateUser(<span class="keyword">new</span> User(<span class="number">4</span>, <span class="string">"呵呵呵"</span>, <span class="string">"74155"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事物</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭SqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200719193210.png" alt=""></p>
</li>
</ol>
<h1 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h1><ol>
<li><p>在接口中添加方法名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取全部用户</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>UserMapper.xml</code> 文件中添加标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">    delete from mybatis.user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在测试类中进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    mapper.deleteUser(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事物</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭SqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果为：</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200719193951.png" alt=""></p>
</li>
</ol>
<h1 id="自动提交事物"><a href="#自动提交事物" class="headerlink" title="自动提交事物"></a>自动提交事物</h1><p>在使用openSession() 方法时, 可以传入一个布尔值, 来控制是否开启自动提交事物, 源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SqlSession <span class="title">openSession</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果这样设置, 就不需要在添加, 删除, 修改操作后手动提交了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="传递MAP"><a href="#传递MAP" class="headerlink" title="传递MAP"></a>传递MAP</h1><p>对于插入或者修改操作, 如果一个对象有非常多的字段(属性), 那么按照之前的方法写SQL语句的话就会非常臃肿. </p>
<p><strong>或者说如果想要修改某些属性, 如果不用map的话就需要新建一个对象进行传递, 使用map就解决了整个问题, 需要改动什么就传什么</strong></p>
<ol>
<li><p>在接口中添加方法名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取全部用户</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据id查询用户</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insert一个用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运用万能的map</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser2</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除用户</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>UserMapper.xml</code> 文件中添加标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--传递map中的key--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser2"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在测试类中进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"id"</span>, <span class="number">4</span>);</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"sdlfew"</span>);</span><br><span class="line">    map.put(<span class="string">"pwd"</span>, <span class="string">"5498764"</span>);</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    mapper.addUser2(map);</span><br><span class="line">    sqlSession.commit();</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>Map传递参数, 直接在SQL中取出KEY即可 <strong>parameterType=”map”</strong></p>
<p>对象传递参数, 直接在SQL中取出对象的属性即可 <strong>parameterType=”Object”</strong></p>
<p><strong>多个参数用Map, 或者注解</strong></p>
<h1 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h1><ol>
<li><p>在接口中添加方法名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取全部用户</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>UserMapper.xml</code> 文件中添加标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserLike"</span> <span class="attr">resultType</span>=<span class="string">"com.lxb.pojo.User"</span>&gt;</span></span><br><span class="line">    select * from user where name like #&#123;value&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在测试类中进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserLike</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    List&lt;User&gt; users = mapper.getUserLike(<span class="string">"J%"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出为</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200720101611.png" alt=""></p>
</li>
</ol>
<p><strong>注意传入参数要加通配符</strong></p>
<ul>
<li><p>要么在Java代码中传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; users = mapper.getUserLike(<span class="string">"J%"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>要么在SQL拼接中使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">select * from user where name like "%"#&#123;value&#125;"%";</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="ResultMap-结果集映射"><a href="#ResultMap-结果集映射" class="headerlink" title="ResultMap 结果集映射"></a>ResultMap 结果集映射</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>解决属性名和字段名不一致的问题</p>
<p>新建一个项目, 验证这个问题</p>
<ol>
<li><p>在<code>User</code> 类中将<code>pwd</code> 字段改为 <code>password</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = mapper.getUserById(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User&#123;id&#x3D;2, name&#x3D;&#39;John&#39;, password&#x3D;&#39;null&#39;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>解决方法: <strong>起别名</strong></p>
<ol>
<li><p>把sql语句改为:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, pwd <span class="keyword">as</span> <span class="keyword">password</span> <span class="keyword">from</span> mybatis.user <span class="keyword">where</span> <span class="keyword">id</span> = <span class="comment">#&#123;id&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结果集映射</p>
</li>
</ol>
<h2 id="结果集映射的使用"><a href="#结果集映射的使用" class="headerlink" title="结果集映射的使用"></a>结果集映射的使用</h2><ol>
<li><p>在UserMapper.xml文件中添加resultMap标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"pwd"</span> <span class="attr">property</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>只修改不一样的属性字段也可以</p>
</li>
<li><p>在select标签中绑定resultMap</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"UserMap"</span>&gt;</span></span><br><span class="line">    select * from mybatis.user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不需要在使用<code>resultType</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis配置解析</title>
    <url>/2020/07/20/Mybatis%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h1><p><strong><em>mybatis-config.xml</em></strong></p>
<p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：</p>
<ul>
<li>configuration（配置）<ul>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties" target="_blank" rel="noopener">properties（属性）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings" target="_blank" rel="noopener">settings（设置）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases" target="_blank" rel="noopener">typeAliases（类型别名）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="noopener">typeHandlers（类型处理器）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory" target="_blank" rel="noopener">objectFactory（对象工厂）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins" target="_blank" rel="noopener">plugins（插件）</a></li>
<li>environments（环境配置）<ul>
<li>environment（环境变量）<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider" target="_blank" rel="noopener">databaseIdProvider（数据库厂商标识）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers" target="_blank" rel="noopener">mappers（映射器）</a></li>
</ul>
</li>
</ul>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景。</p>
<p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p>
<p>所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader, environment);</span><br><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader, environment, properties);</span><br></pre></td></tr></table></figure>

<p>environments 元素定义了如何配置环境。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">value</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意一些关键点:</p>
<ul>
<li>默认使用的环境 ID（比如：default=”development”）。</li>
<li>每个 environment 元素定义的环境 ID（比如：id=”development”）。</li>
<li>事务管理器的配置（比如：type=”JDBC”）。</li>
<li>数据源的配置（比如：type=”POOLED”）。</li>
</ul>
<p>默认环境和环境 ID 顾名思义。 环境可以随意命名，但务必保证默认的环境 ID 要匹配其中一个环境 ID。</p>
<p><strong>事务管理器（transactionManager）</strong></p>
<p>在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）：</p>
<ul>
<li>JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。</li>
<li>MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 </li>
</ul>
<p><strong>数据源（dataSource）</strong></p>
<p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p>
<ul>
<li>大多数 MyBatis 应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。</li>
</ul>
<p>有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>可以通过Properties属性来实现引用配置文件. 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。 <strong><em>db.properties</em></strong></p>
<ol>
<li><p>在资源目录中新建properties文件:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p>注意properties文件中<code>url</code> 不需要<code>amp;</code></p>
</li>
<li><p>在核心配置文件中引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以在核心配置文件的properties标签里面写键值对, 但是优先使用外部配置文件</p>
</li>
</ol>
<h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Author"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Author"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Blog"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Blog"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Comment"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Comment"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Post"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Post"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Section"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Section"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Tag"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Tag"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当这样配置时，<code>Blog</code> 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com.lxb.pojo.User"</span> <span class="attr">alias</span>=<span class="string">"User"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：      <strong>但默认是小写</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.lxb.pojo"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果实体类比较少, 使用第一种方式</p>
<p>如果实体类十分多, 使用第二种方式</p>
<p>第一种可以DIY别名, 第二种默认首字母变小写, 但是可用注解DIY别名, 如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias</span>(<span class="string">"author"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一些为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。</p>
<table>
<thead>
<tr>
<th align="left">别名</th>
<th align="left">映射的类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_byte</td>
<td align="left">byte</td>
</tr>
<tr>
<td align="left">_long</td>
<td align="left">long</td>
</tr>
<tr>
<td align="left">_short</td>
<td align="left">short</td>
</tr>
<tr>
<td align="left">_int</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">_integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">_double</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">_float</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">_boolean</td>
<td align="left">boolean</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">String</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">integer</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Double</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left">date</td>
<td align="left">Date</td>
</tr>
<tr>
<td align="left">decimal</td>
<td align="left">BigDecimal</td>
</tr>
<tr>
<td align="left">bigdecimal</td>
<td align="left">BigDecimal</td>
</tr>
<tr>
<td align="left">object</td>
<td align="left">Object</td>
</tr>
<tr>
<td align="left">map</td>
<td align="left">Map</td>
</tr>
<tr>
<td align="left">hashmap</td>
<td align="left">HashMap</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">List</td>
</tr>
<tr>
<td align="left">arraylist</td>
<td align="left">ArrayList</td>
</tr>
<tr>
<td align="left">collection</td>
<td align="left">Collection</td>
</tr>
<tr>
<td align="left">iterator</td>
<td align="left">Iterator</td>
</tr>
</tbody></table>
<h1 id="设置-官方文档"><a href="#设置-官方文档" class="headerlink" title="设置 (官方文档)"></a>设置 (官方文档)</h1><p>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项设置的含义、默认值等。</p>
<table>
<thead>
<tr>
<th align="left">设置名</th>
<th align="left">描述</th>
<th align="left">有效值</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cacheEnabled</td>
<td align="left">全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</td>
<td align="left">true | false</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">lazyLoadingEnabled</td>
<td align="left">延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td>
<td align="left">true | false</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">aggressiveLazyLoading</td>
<td align="left">开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 <code>lazyLoadTriggerMethods</code>)。</td>
<td align="left">true | false</td>
<td align="left">false （在 3.4.1 及之前的版本中默认为 true）</td>
</tr>
<tr>
<td align="left">multipleResultSetsEnabled</td>
<td align="left">是否允许单个语句返回多结果集（需要数据库驱动支持）。</td>
<td align="left">true | false</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">useColumnLabel</td>
<td align="left">使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。</td>
<td align="left">true | false</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">useGeneratedKeys</td>
<td align="left">允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。</td>
<td align="left">true | false</td>
<td align="left">False</td>
</tr>
<tr>
<td align="left">autoMappingBehavior</td>
<td align="left">指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。</td>
<td align="left">NONE, PARTIAL, FULL</td>
<td align="left">PARTIAL</td>
</tr>
<tr>
<td align="left">autoMappingUnknownColumnBehavior</td>
<td align="left">指定发现自动映射目标未知列（或未知属性类型）的行为。<code>NONE</code>: 不做任何反应<code>WARNING</code>: 输出警告日志（<code>&#39;org.apache.ibatis.session.AutoMappingUnknownColumnBehavior&#39;</code> 的日志等级必须设置为 <code>WARN</code>）<code>FAILING</code>: 映射失败 (抛出 <code>SqlSessionException</code>)</td>
<td align="left">NONE, WARNING, FAILING</td>
<td align="left">NONE</td>
</tr>
<tr>
<td align="left">defaultExecutorType</td>
<td align="left">配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。</td>
<td align="left">SIMPLE REUSE BATCH</td>
<td align="left">SIMPLE</td>
</tr>
<tr>
<td align="left">defaultStatementTimeout</td>
<td align="left">设置超时时间，它决定数据库驱动等待数据库响应的秒数。</td>
<td align="left">任意正整数</td>
<td align="left">未设置 (null)</td>
</tr>
<tr>
<td align="left">defaultFetchSize</td>
<td align="left">为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。</td>
<td align="left">任意正整数</td>
<td align="left">未设置 (null)</td>
</tr>
<tr>
<td align="left">defaultResultSetType</td>
<td align="left">指定语句默认的滚动策略。（新增于 3.5.2）</td>
<td align="left">FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT（等同于未设置）</td>
<td align="left">未设置 (null)</td>
</tr>
<tr>
<td align="left">safeRowBoundsEnabled</td>
<td align="left">是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。</td>
<td align="left">true | false</td>
<td align="left">False</td>
</tr>
<tr>
<td align="left">safeResultHandlerEnabled</td>
<td align="left">是否允许在嵌套语句中使用结果处理器（ResultHandler）。如果允许使用则设置为 false。</td>
<td align="left">true | false</td>
<td align="left">True</td>
</tr>
<tr>
<td align="left">mapUnderscoreToCamelCase</td>
<td align="left">是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</td>
<td align="left">true | false</td>
<td align="left">False</td>
</tr>
<tr>
<td align="left">localCacheScope</td>
<td align="left">MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。</td>
<td align="left">SESSION | STATEMENT</td>
<td align="left">SESSION</td>
</tr>
<tr>
<td align="left">jdbcTypeForNull</td>
<td align="left">当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。 某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。</td>
<td align="left">JdbcType 常量，常用值：NULL、VARCHAR 或 OTHER。</td>
<td align="left">OTHER</td>
</tr>
<tr>
<td align="left">lazyLoadTriggerMethods</td>
<td align="left">指定对象的哪些方法触发一次延迟加载。</td>
<td align="left">用逗号分隔的方法列表。</td>
<td align="left">equals,clone,hashCode,toString</td>
</tr>
<tr>
<td align="left">defaultScriptingLanguage</td>
<td align="left">指定动态 SQL 生成使用的默认脚本语言。</td>
<td align="left">一个类型别名或全限定类名。</td>
<td align="left">org.apache.ibatis.scripting.xmltags.XMLLanguageDriver</td>
</tr>
<tr>
<td align="left">defaultEnumTypeHandler</td>
<td align="left">指定 Enum 使用的默认 <code>TypeHandler</code> 。（新增于 3.4.5）</td>
<td align="left">一个类型别名或全限定类名。</td>
<td align="left">org.apache.ibatis.type.EnumTypeHandler</td>
</tr>
<tr>
<td align="left">callSettersOnNulls</td>
<td align="left">指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。</td>
<td align="left">true | false</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">returnInstanceForEmptyRow</td>
<td align="left">当返回行的所有列都是空时，MyBatis默认返回 <code>null</code>。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2）</td>
<td align="left">true | false</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">logPrefix</td>
<td align="left">指定 MyBatis 增加到日志名称的前缀。</td>
<td align="left">任何字符串</td>
<td align="left">未设置</td>
</tr>
<tr>
<td align="left">logImpl</td>
<td align="left">指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td>
<td align="left">SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</td>
<td align="left">未设置</td>
</tr>
<tr>
<td align="left">proxyFactory</td>
<td align="left">指定 Mybatis 创建可延迟加载对象所用到的代理工具。</td>
<td align="left">CGLIB | JAVASSIST</td>
<td align="left">JAVASSIST （MyBatis 3.3 以上）</td>
</tr>
<tr>
<td align="left">vfsImpl</td>
<td align="left">指定 VFS 的实现</td>
<td align="left">自定义 VFS 的实现的类全限定名，以逗号分隔。</td>
<td align="left">未设置</td>
</tr>
<tr>
<td align="left">useActualParamName</td>
<td align="left">允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 <code>-parameters</code> 选项。（新增于 3.4.1）</td>
<td align="left">true | false</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">configurationFactory</td>
<td align="left">指定一个提供 <code>Configuration</code> 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为<code>static Configuration getConfiguration()</code> 的方法。（新增于 3.2.3）</td>
<td align="left">一个类型别名或完全限定类名。</td>
<td align="left">未设置</td>
</tr>
<tr>
<td align="left">shrinkWhitespacesInSql</td>
<td align="left">Removes extra whitespace characters from the SQL. Note that this also affects literal strings in SQL. (Since 3.5.5)</td>
<td align="left">true | false</td>
<td align="left">false</td>
</tr>
</tbody></table>
<p>一个配置完整的 settings 元素的示例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"multipleResultSetsEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useColumnLabel"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useGeneratedKeys"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingBehavior"</span> <span class="attr">value</span>=<span class="string">"PARTIAL"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingUnknownColumnBehavior"</span> <span class="attr">value</span>=<span class="string">"WARNING"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultExecutorType"</span> <span class="attr">value</span>=<span class="string">"SIMPLE"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultStatementTimeout"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultFetchSize"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"safeRowBoundsEnabled"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"jdbcTypeForNull"</span> <span class="attr">value</span>=<span class="string">"OTHER"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadTriggerMethods"</span> <span class="attr">value</span>=<span class="string">"equals,clone,hashCode,toString"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h1><p>既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 </p>
<p>方式一:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/lxb/dao/UserMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方式二:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.lxb.dao.UserMapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还可以通过包名实现, 但是方式二和包名实现时必须注意两点:</p>
<ul>
<li>接口名和xml文件必须同名</li>
<li>接口和xml文件必须在同一个包下</li>
</ul>
<h1 id="声明周期和作用域"><a href="#声明周期和作用域" class="headerlink" title="声明周期和作用域"></a>声明周期和作用域</h1><p>理解我们之前讨论过的不同作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的并发问题.</p>
<p><strong>SqlSessionFactoryBuilder:</strong></p>
<ul>
<li>一旦创建了 SqlSessionFactory , 就不再需要它了</li>
<li>局部变量</li>
</ul>
<p><strong>SqlSessionFactory:</strong></p>
<ul>
<li>说白了就是类比为数据库连接池</li>
<li>一旦创建就一直存在, 没有任何理由丢其它或者重新创建另外一个实例</li>
<li>因此它的作用域是应用作用域</li>
<li>有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</li>
</ul>
<p><strong>SqlSession:</strong></p>
<ul>
<li><p>可以理解为连接到连接池的一个请求</p>
</li>
<li><p>SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 </p>
</li>
<li><p>用完之后要关闭</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200720140926.png" alt=""></p>
<p>这之中每一个Mapper, 都代表一个具体的业务</p>
</li>
</ul>
<h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="typeHandlers-类型处理器"><a href="#typeHandlers-类型处理器" class="headerlink" title="typeHandlers 类型处理器"></a>typeHandlers 类型处理器</h2><h2 id="objectFactory-对象工厂"><a href="#objectFactory-对象工厂" class="headerlink" title="objectFactory 对象工厂"></a>objectFactory 对象工厂</h2><h2 id="plugins插件"><a href="#plugins插件" class="headerlink" title="plugins插件"></a>plugins插件</h2>]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis简介与环境搭建</title>
    <url>/2020/07/13/Mybatis%E7%AE%80%E4%BB%8B%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200718110513.png" alt=""></p>
<ul>
<li>MyBatis是一款优秀的持久层框架</li>
<li>它支持定制化SQL, 存储过程以及高级映射</li>
<li>MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集</li>
<li>可以使用简答你的XML或注解来配置和映射原生类型, 接口和Java 的POJO为数据库中的记录.</li>
</ul>
<h2 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h2><p>数据持久化, 就是将程序的数据在持久状态和瞬时状态转化的过程</p>
<ul>
<li><p>内存: 断电即失</p>
</li>
<li><p>数据库, IO支持持久化</p>
</li>
<li><p>生活中: 冷藏, 罐头.</p>
</li>
</ul>
<p><strong>为什么需要持久化</strong><br>有一些对象, 不能让它丢失, 内存断电即失, 且太贵</p>
<h2 id="持久层-1"><a href="#持久层-1" class="headerlink" title="持久层"></a>持久层</h2><p>完成持久化工作的代码块</p>
<p>层界限十分明显</p>
<h2 id="MyBatis的必要性"><a href="#MyBatis的必要性" class="headerlink" title="MyBatis的必要性"></a>MyBatis的必要性</h2><ul>
<li>方便</li>
<li>传统JDBC代码太复杂, 简化框架, 自动化</li>
<li>帮助程序员将数据存入到数据库中</li>
<li>不用MyBatis也可以, 更容易上手</li>
<li><strong>使用的人多</strong></li>
</ul>
<h1 id="获取MyBatis"><a href="#获取MyBatis" class="headerlink" title="获取MyBatis"></a>获取MyBatis</h1><ul>
<li><p>Maven 仓库</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Github: <a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases</a></p>
</li>
<li><p>中文文档: <a href="https://mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p>
</li>
</ul>
<h1 id="搭建环境与测试"><a href="#搭建环境与测试" class="headerlink" title="搭建环境与测试"></a>搭建环境与测试</h1><h2 id="创建一个数据库表"><a href="#创建一个数据库表" class="headerlink" title="创建一个数据库表"></a>创建一个数据库表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mybatis`</span>.<span class="string">`user`</span>(  </span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">  <span class="string">`pwd`</span> <span class="built_in">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_general_ci;</span><br></pre></td></tr></table></figure>

<p>插入数据:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`user`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`pwd`</span>) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'刘潇博'</span>, <span class="string">'123456'</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">'John'</span>, <span class="string">'123456'</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">'Jay'</span>, <span class="string">'123456'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><ol>
<li><p>新建一个普通Maven项目</p>
</li>
<li><p>删除src目录</p>
</li>
<li><p>导入Maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--jUnit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><ol>
<li><p>在项目中新建一个普通Maven模块</p>
</li>
<li><p>在IDEA中连接Mysql, 将刚才新建的数据库加进来</p>
</li>
<li><p>编写核心配置文件</p>
<p>在模块自带的资源目录中新建一个XML文件, 名为<code>mybatis-config.xml</code></p>
<p>参考官方文档写入:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写Mybatis工具类</p>
<blockquote>
<p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</p>
<p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p>
</blockquote>
<p>构建SqlSessionFactory实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybtisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用Mybatis第一步, 获取SqlSessionFactory对象</span></span><br><span class="line">            String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个语句是固定要这么写的</p>
</li>
<li><p>获得 SqlSession 的实例。</p>
<p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybtisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用Mybatis第一步, 获取SqlSessionFactory对象</span></span><br><span class="line">            String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><ol>
<li><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", pwd='"</span> + pwd + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DAO接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口实现类由原来的UserDaoImpl.java 转变为一个Mapper 配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.lxb.dao.UserDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--select查询语句--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserList"</span> <span class="attr">resultType</span>=<span class="string">"com.lxb.pojo.User"</span>&gt;</span></span><br><span class="line">        select * from mybatis.user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中:</p>
<p>namespace 对应接口</p>
<p>id 对应方法名</p>
<p>resultType 对应返回结果类型</p>
</li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>junit测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取SqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = MybtisUtils.getSqlSession();</span><br><span class="line">        <span class="comment">// 方式一: getMapper</span></span><br><span class="line">        UserDao userDao = sqlSession.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;User&gt; userList = userDao.getUserList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭SqlSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现了以下常见错误需要注意:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200718160618.png" alt=""></p>
<p>原因是每一个Mapper.xml都需要在Mybatis核心配置文件中注册!</p>
<p>所以核心配置文件修改为:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册!--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/lxb/dao/UserMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果依然有错</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200718161316.png" alt=""></p>
<p>这是因为, 在当前的Maven环境中, target目录并没有生成所需的xml文件, 所需文件在java目录下 </p>
<p>Maven默认情况下, 只会把resource目录下的资源配置文件到处到target目录中, 所以需要在porm.xml中添加一下语句:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/lxb/dao/UserMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>然后这里运行后一直报错, 是与数据库的连接出错, 改了时区, 反复重连都没有解决, 最终把url里的<code>useSSL=true</code>删掉就好了</strong></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200718201651.png" alt=""></p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql5.7安装与配置</title>
    <url>/2020/07/18/Mysql5-7%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h1><p>官网下载64位的包</p>
<ol>
<li><p>解压</p>
</li>
<li><p>把这个包放到自己的电脑环境目录下</p>
</li>
<li><p>配置环境变量</p>
<ul>
<li>把bin目录的地址添加到Path路径里即可</li>
</ul>
</li>
<li><p>新建mysql配置文件<code>my.ini</code></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200718101002.png" alt=""></p>
</li>
<li><p>打开配置文件进行编辑</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">basedir</span>=D:\Mysql\mysql-<span class="number">5.7</span>.<span class="number">31</span>\</span><br><span class="line"><span class="attr">datadir</span>=D:\Mysql\mysql-<span class="number">5.7</span>.<span class="number">31</span>\data\</span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动管理员模式下的CMD，运行所有的命令</p>
<ol>
<li>进入bin目录</li>
<li>输入<code>mysqld -install</code></li>
<li>输入<code>mysqld --initialize-insecure --user=mysql</code>, 然后会发现生成了data目录, 里面有初始文件</li>
</ol>
</li>
<li><p>启动mysql, 修改密码</p>
</li>
<li><p>输入<code>net start mysql</code></p>
</li>
<li><p>通过命令行进入管理界面(必须先启动成功)</p>
<ol>
<li>输入<code>mysql -u root -p</code></li>
<li>修改密码<code>update mysql.user set authentication_string=password(&#39;123456&#39;) where user=&#39;root&#39; and Host=&#39;localhost&#39;;</code></li>
<li>刷新权限 <code>flush privileges;</code></li>
</ol>
</li>
<li><p>把my.ini配置文件中最后一行注释掉</p>
</li>
<li><p>重启mysql</p>
<ol>
<li>输入<code>exit</code> 退出管理</li>
<li>输入<code>net stop mysql</code> 停止服务</li>
<li>输入<code>net start mysql</code> 启动服务</li>
<li>输入<code>mysql -u root -p</code>, 然后输入刚才设置的密码即可进入管理界面</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Queue中方法的辨析</title>
    <url>/2020/07/10/Queue%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%BE%A8%E6%9E%90/</url>
    <content><![CDATA[<p> java Queue中 add/offer，element/peek，remove/poll中的三个方法均为重复的方法，在选择使用时不免有所疑惑，这里简单区别一下：</p>
<h3 id="add-和offer-区别"><a href="#add-和offer-区别" class="headerlink" title="add()和offer()区别:"></a><strong>add()和offer()区别:</strong></h3><p>add()和offer()都是向队列中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。因此就可以在程序中进行有效的判断！</p>
<h3 id="poll-和remove-区别："><a href="#poll-和remove-区别：" class="headerlink" title="poll()和remove()区别："></a><strong>poll()和remove()区别：</strong></h3><p>remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。</p>
<h3 id="element-和-peek-区别："><a href="#element-和-peek-区别：" class="headerlink" title="element() 和 peek() 区别："></a><strong>element() 和 peek() 区别：</strong></h3><p>element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>ServletContext</title>
    <url>/2020/07/17/ServletContext/</url>
    <content><![CDATA[<p>Web容器启动的时候, 它会为每个web程序创建一个ServletContext的对象, 它代表了当前的web应用.</p>
<p>作用为:</p>
<h1 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h1><p>我在这个Servlet中保存的数据, 可以在另一个servlet中拿到, 凌驾于所有servlet之上的</p>
<p>首先在一个Servelt程序中设置servletContext的值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String username = <span class="string">"lxb"</span>;</span><br><span class="line">        context.setAttribute(<span class="string">"username"</span>, username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再编写一个Servlet程序, 将值取出并打印在浏览器中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String username = (String) context.getAttribute(<span class="string">"username"</span>);</span><br><span class="line">        resp.getWriter().println(<span class="string">"名字"</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先执行第一个程序, 将值放入, 然后再执行第二个把值取出. 输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200717092334.png" alt=""></p>
<p>下面来解决乱码问题, 设置一下响应格式就可以了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String username = (String) context.getAttribute(<span class="string">"username"</span>);</span><br><span class="line"></span><br><span class="line">        resp.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        </span><br><span class="line">        resp.getWriter().println(<span class="string">"名字"</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200717092920.png" alt=""></p>
<h1 id="获取初始化参数"><a href="#获取初始化参数" class="headerlink" title="获取初始化参数"></a>获取初始化参数</h1><p>在web.xml中设置一个初始化的参数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:maysql://localhost:3306<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后新建一个servlet程序对参数进行读取即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetParam</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        String url = context.getInitParameter(<span class="string">"url"</span>);</span><br><span class="line">        resp.getWriter().println(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200717094757.png" alt=""></p>
<h1 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h1><p>使用context对象的<code>getRequestDispatcher()</code> 方法即可, 放入目标地址, 并调用<code>forward()</code> 方法, 即可实现转发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispacher</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        context.getRequestDispatcher(<span class="string">"/getparam"</span>).forward(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200717100328.png" alt=""></p>
<p>注意地址栏, 该方法只是调用另一个servlet的页面, 不会跳转到另一个地址</p>
<p>这里要与重定向区分起来, 重定向是直接跳转过去</p>
<h1 id="读取资源文件"><a href="#读取资源文件" class="headerlink" title="读取资源文件"></a>读取资源文件</h1><p>Properties类</p>
<ul>
<li>在java目录下新建properties</li>
<li>在resources目录下新建properties</li>
</ul>
<p>发现: 都被打包到了同一个路径下: classes, 我们俗称这个路径为classpath</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">this</span>.getServletContext().getResourceAsStream(<span class="string">"/WEB-INF/classes/db.properties"</span>);</span><br><span class="line"></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(is);</span><br><span class="line">        String username = properties.getProperty(<span class="string">"username"</span>);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().println(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Javaweb</category>
      </categories>
  </entry>
  <entry>
    <title>Servlet原理</title>
    <url>/2020/07/16/Servlet%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>Servlet是由Web服务器调用, web服务器 (Web容器) 在收到浏览器请求之后:</p>
<ul>
<li><p>若是首次访问Servelt, 会生成<code>.class</code>文件</p>
</li>
<li><p>根据浏览器的请求生成<strong>请求(Request)</strong> 和 <strong>响应(Response)</strong></p>
</li>
<li><p>调用Servlet的<code>service()</code> 方法, 并把请求和响应传递给它</p>
<ul>
<li>我们自己编写实现类, 重写这些方法<ol>
<li>接收并处理请求</li>
<li>给出响应的信息</li>
</ol>
</li>
</ul>
</li>
<li><p>Resquest会从service拿到请求, 并且把请求之后的响应交给Response, 见下图红线流程</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716195002.png" alt=""></p>
</li>
<li><p>最终Web容器得到响应信息, 并回传给浏览器</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Javaweb</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>String,StringBuffer,StringBuilder类汇总</title>
    <url>/2020/07/08/String-StringBuffer-StringBuilder%E7%B1%BB%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>字符串Java中非常重要的部分, 这里包含了大量的处理方法以及性质特点, 这篇文章对常用的String类, StringBuffer类, StringBuilder类相关知识点进行汇总.</p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="两个重要特点"><a href="#两个重要特点" class="headerlink" title="两个重要特点"></a>两个重要特点</h3><h4 id="String-常量池"><a href="#String-常量池" class="headerlink" title="String 常量池"></a>String 常量池</h4><p>常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。Java为了提高性能，静态字符串（字面量/常量/常量连接的结果）在常量池中创建，并尽量使用同一个对象，重用静态字符串。对于重复出现的字符串直接量，JVM会首先在常量池中查找，如果常量池中存在即返回该对象。</p>
<p>例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            String str1 = <span class="string">"Hello"</span>;<span class="comment">//生成了1个对象"Hello"</span></span><br><span class="line">            <span class="comment">//不会创建新的String对象，而是使用常量池中已有的"Hello"，</span></span><br><span class="line">            String str2 = <span class="string">"Hello"</span>;</span><br><span class="line">            System.out.println(str1 == str2); <span class="comment">//true</span></span><br><span class="line">            <span class="comment">//使用new关键字会创建新的String对象，不管常量池里面有没有相同的值</span></span><br><span class="line">            String str3 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);<span class="comment">//生成了2个对象"Hello"和new String("Hello")</span></span><br><span class="line">            System.out.println(str1 == str3); <span class="comment">//false </span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="String-对象不可变"><a href="#String-对象不可变" class="headerlink" title="String 对象不可变"></a>String 对象不可变</h4><p>String是常量，其对象一旦构造就不能再被改变。换句话说，<strong>String对象是不可变的</strong>，每一个看起来会修改String值的方法，实际上都是创造了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"hello"</span>;</span><br><span class="line">        String newS = StringTest02.append(s);</span><br><span class="line">        System.out.println(<span class="string">"String append---&gt;"</span> + s.toString());</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"hello"</span>);</span><br><span class="line">        StringBuilder newSb = StringTest02.append(sb);</span><br><span class="line">        System.out.println(<span class="string">"StringBuilder append---&gt;"</span> +sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">append</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s += <span class="string">"kitty"</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">append</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb.append(<span class="string">"kitty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String append---&gt;hello</span><br><span class="line">StringBuilder append---&gt;hellokitty</span><br></pre></td></tr></table></figure>

<p>由上面的例子可见StringBuilder sb的值被改变了，而String s的值没有变，所以String不可变的安全性就体现出来了</p>
<h3 id="String-类的方法"><a href="#String-类的方法" class="headerlink" title="String 类的方法"></a>String 类的方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p><strong>1、<em>public String()</em></strong><br>无参构造方法，用来创建空字符串的String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String();</span><br></pre></td></tr></table></figure>

<p><strong>2、<em>public String(String value)</em></strong><br>用已知的字符串value创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"qwer"</span>); </span><br><span class="line">String str3 = <span class="keyword">new</span> String(str2);</span><br></pre></td></tr></table></figure>

<p><strong>3、<em>public String(char[] value)</em></strong><br>用字符数组value创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">String str4 = <span class="keyword">new</span> String(value);<span class="comment">//相当于String str4 = new String("abcd");</span></span><br></pre></td></tr></table></figure>

<p><strong>4<em>、public String(char chars[], int startIndex, int numChars)</em></strong><br>用字符数组chars的startIndex开始的numChars个字符创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">String str5 = <span class="keyword">new</span> String(value, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//相当于String str5 = new String("bc");</span></span><br></pre></td></tr></table></figure>

<p><strong>5、<em>public String(byte[] values)</em></strong><br>用比特数组values创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] strb = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>&#125;;</span><br><span class="line">String str6 = <span class="keyword">new</span> String(strb);<span class="comment">//相当于String str6 = new String("ABCD");</span></span><br></pre></td></tr></table></figure>

<p><strong>6、<em>public String(byte[] values,int startIndex, int numChars)</em></strong><br>用字符数组byte的startIndex开始的numChars个字符创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] strb = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>&#125;;</span><br><span class="line">String str6 = <span class="keyword">new</span> String(strb,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//相当于String str6 = new String("A");</span></span><br></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><strong>1、<em>length()</em></strong><br>返回字该字符串的长度</p>
<p><strong>2、<em>charAt(int indext)</em></strong><br>求字符串某一位置的字符，index必须&gt;=0并且&lt;= length()-1</p>
<p><strong>3、截取字符串</strong></p>
<ul>
<li><strong><em>substring(int beginIndex)</em></strong><br>该方法从beginIndex位置起（包含这个位置）到最后截取一个字符串返回。<br><strong><em>[beginIndex,最后]</em></strong></li>
<li><strong><em>substring(int beginIndex，endIndex)</em></strong><br>该方法从beginIndex位置起（包含这个位置）到endIndex - 1截取一个字符串返回。<br><strong><em>[beginIndex,endIndex - 1]</em></strong><br>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"abcdefgkl"</span>);</span><br><span class="line">String str2 = str1.substring(<span class="number">2</span>);<span class="comment">//str2 = "cdefgkl"</span></span><br><span class="line">String str3 = str1.substring(<span class="number">2</span>,<span class="number">5</span>);<span class="comment">//str3 = "cde"</span></span><br></pre></td></tr></table></figure>

<p><strong>4、字符串比较</strong></p>
<ul>
<li><strong><em>public int compareTo(String anotherString)</em></strong><br>该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。其比较规则是：拿出字符串的第一个字符与参数的第一个字符进行比较，如果两者不等，比较结束，返回两者的ascii差。这里有一点需要注意：如果两个字符串的长度不同，并且一个字符串与另一个字符串的前面N个字符相等，那么这个方法返回返回两个字符串长度之差。</li>
<li><strong><em>public int compareToIgnore(String anotherString)</em></strong><br>与compareTo方法相似，但忽略大小写。</li>
<li><strong><em>public boolean equals(Object anotherObject)</em></strong><br>比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。</li>
<li><strong><em>public boolean equalsIgnoreCase(String anotherString)</em></strong><br>与equals方法相似，但忽略大小写。<br>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"abcd"</span>; </span><br><span class="line">String s2 = <span class="string">"abce"</span>; </span><br><span class="line">String s3 = <span class="string">"ABC"</span>; </span><br><span class="line">String s4 = <span class="string">"abcdefg"</span>; </span><br><span class="line">String s5 = <span class="string">"abc"</span>; </span><br><span class="line">System.out.println(s1.compareTo(s2)); </span><br><span class="line">System.out.println(s1.compareTo(s3)); </span><br><span class="line">System.out.println(s4.compareTo(s1)); </span><br><span class="line">System.out.println(s4.compareTo(s2)); </span><br><span class="line">System.out.println(s3.compareToIgnoreCase(s5));</span><br><span class="line">System.out.println(s3.equals(s5));</span><br><span class="line">System.out.println(s3.equalsIgnoreCase(s5));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>5、字符串连接</strong></p>
<ul>
<li><strong><em>public String concat(String str)</em></strong><br>将参数中的字符串str连接到当前字符串的后面，效果等价于”+”。</li>
</ul>
<p><strong>6、字符串中单个字符查找</strong></p>
<ul>
<li><strong><em>public int indexOf(int ch/String str)</em></strong><br>用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1。</li>
<li><strong><em>public int indexOf(int ch/String str, int fromIndex)</em></strong><br>改方法与第一种类似，区别在于该方法从fromIndex位置向后查找。</li>
<li><strong><em>public int lastIndexOf(int ch/String str)</em></strong><br>该方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找。</li>
<li><strong><em>public int lastIndexOf(int ch/String str, int fromIndex)</em></strong><br>该方法与第二种方法类似，区别于该方法从fromIndex位置向前查找。<br>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"I am a good student"</span>;</span><br><span class="line">System.out.println(str.indexOf(<span class="string">'a'</span>));</span><br><span class="line">System.out.println(str.indexOf(<span class="string">"good"</span>));</span><br><span class="line">System.out.println(str.indexOf(<span class="string">"w"</span>, <span class="number">2</span>));</span><br><span class="line">System.out.println(str.lastIndexOf(<span class="string">"a"</span>));</span><br><span class="line">System.out.println(str.lastIndexOf(<span class="string">"a"</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">7</span><br><span class="line">-1</span><br><span class="line">5</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>7、字符串中字符的大小写转换</strong></p>
<ul>
<li><strong><em>public String toLowerCase()</em></strong><br>返回将当前字符串中所有字符转换成小写后的新串</li>
<li><strong><em>public String toUpperCase()</em></strong><br>返回将当前字符串中所有字符转换成大写后的新串</li>
</ul>
<p><strong>8、字符串中字符的替换</strong></p>
<ul>
<li><strong><em>public String replace(char oldChar, char newChar)</em></strong><br>用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。</li>
<li><strong><em>public String replaceFirst(String regex, String replacement)</em></strong><br>该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。</li>
<li><strong><em>public String replaceAll(String regex, String replacement)</em></strong><br>该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。<br>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str4 = <span class="string">"asdzxcasd"</span>;</span><br><span class="line">System.out.println(str4.replace(<span class="string">'a'</span>, <span class="string">'g'</span>));</span><br><span class="line">System.out.println(str4.replace(<span class="string">"asd"</span>, <span class="string">"fgh"</span>));</span><br><span class="line">System.out.println(str4.replaceFirst(<span class="string">"asd"</span>, <span class="string">"fgh"</span>));</span><br><span class="line">System.out.println(str4.replaceAll(<span class="string">"asd"</span>, <span class="string">"fgh"</span>));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gsdzxcgsd</span><br><span class="line">fghzxcfgh</span><br><span class="line">fghzxcasd</span><br><span class="line">fghzxcfgh</span><br></pre></td></tr></table></figure>

<p><strong><em>注意：replace和preplaceAll的区别</em></strong></p>
<ol>
<li>replace的参数是char和CharSequence,即可以支持字符的替换,也支持字符串的替换(CharSequence即字符串序列的意思,说白了也就是字符串);</li>
<li>replaceAll的参数是regex,即基于规则表达式的替换,比如,可以通过replaceAll(“\d”, “*”)把一个字符串所有的数字字符都换成星号;</li>
</ol>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p><strong>1、去除首位空格</strong></p>
<ul>
<li><p><strong><em>String trim()</em></strong></p>
<p>截去字符串两端的空格，但对于中间的空格不处理。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">" a sd "</span>;</span><br><span class="line">String str1 = str.trim();</span><br><span class="line"><span class="keyword">int</span> a = str.length();<span class="comment">//a = 6</span></span><br><span class="line"><span class="keyword">int</span> b = str1.length();<span class="comment">//b = 4</span></span><br></pre></td></tr></table></figure>

<p><strong>2、确认开始或结尾字符串</strong></p>
<ul>
<li><strong><em>boolean statWith(String prefix)或boolean endWith(String suffix)</em></strong><br>用来比较当前字符串的起始字符或子字符串prefix和终止字符或子字符串suffix是否和当前字符串相同，重载方法中同时还可以指定比较的开始位置offset。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"asdfgh"</span>;</span><br><span class="line"><span class="keyword">boolean</span> a = str.statWith(<span class="string">"as"</span>);<span class="comment">//a = true</span></span><br><span class="line"><span class="keyword">boolean</span> b = str.endWith(<span class="string">"gh"</span>);<span class="comment">//b = true</span></span><br></pre></td></tr></table></figure>

<p><strong>3、包含字符串</strong></p>
<ul>
<li><strong><em>contains(String str)</em></strong><br>判断参数s是否被包含在字符串中，并返回一个布尔类型的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; &quot;student&quot;;</span><br><span class="line">str.contains(&quot;stu&quot;);&#x2F;&#x2F;true</span><br><span class="line">str.contains(&quot;ok&quot;);&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p><strong>4、分隔字符串</strong></p>
<ul>
<li><strong><em>String[] split(String str)</em></strong><br>将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"asd!qwe!zxc"</span>;</span><br><span class="line">String[] str1 = str.split(<span class="string">"!"</span>);<span class="comment">//str1[0] = "asd";str1[1] = "qwe";str1[2] = "zxc";</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串与基本类型的转换"><a href="#字符串与基本类型的转换" class="headerlink" title="字符串与基本类型的转换"></a>字符串与基本类型的转换</h4><p><strong>1、字符串转换为基本类型</strong></p>
<p>java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：</p>
<ul>
<li><p><strong><em>public static byte parseByte(String s)</em></strong></p>
</li>
<li><p><strong><em>public static short parseShort(String s)</em></strong></p>
</li>
<li><p><strong><em>public static short parseInt(String s)</em></strong></p>
</li>
<li><p><strong><em>public static long parseLong(String s)</em></strong></p>
</li>
<li><p><strong><em>public static float parseFloat(String s)</em></strong></p>
</li>
<li><p><strong><em>public static double parseDouble(String s)</em></strong></p>
<p>例如：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = Integer.parseInt(<span class="string">"12"</span>);</span><br><span class="line"><span class="keyword">float</span> f = Float.parseFloat(<span class="string">"12.34"</span>);</span><br><span class="line"><span class="keyword">double</span> d = Double.parseDouble(<span class="string">"1.124"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>2、基本类型转换为字符串类型</strong></p>
<p>String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。</p>
<ul>
<li><strong><em>static String valueOf(char data[])</em></strong></li>
<li><strong><em>static String valueOf(char data[], int offset, int count)</em></strong></li>
<li><strong><em>static String valueOf(boolean b)</em></strong></li>
<li><strong><em>static String valueOf(char c)</em></strong></li>
<li><strong><em>static String valueOf(int i)</em></strong></li>
<li><strong><em>static String valueOf(long l)</em></strong></li>
<li><strong><em>static String valueOf(float f)</em></strong></li>
<li><strong><em>static String valueOf(double d)</em></strong><br>例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = String.valueOf(<span class="number">12</span>);</span><br><span class="line">String s1 = String.valueOf(<span class="number">12.34</span>);</span><br></pre></td></tr></table></figure>

<h2 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer, StringBuilder"></a>StringBuffer, StringBuilder</h2><h3 id="共同支持的方法"><a href="#共同支持的方法" class="headerlink" title="共同支持的方法"></a>共同支持的方法</h3><ul>
<li><strong><em>public StringBuffer append(String s)</em></strong><br>将指定的字符串追加到此字符序列。</li>
<li><strong><em>public StringBuffer reverse()</em></strong><br>将此字符序列用其反转形式取代。</li>
<li><strong><em>public delete(int start, int end)</em></strong><br>移除此序列的子字符串中的字符。</li>
<li><strong><em>public insert(int offset, int i)</em></strong><br>将 int 参数的字符串表示形式插入此序列中。</li>
<li><strong><em>replace(int start, int end, String str)</em></strong><br>使用给定 String 中的字符替换此序列的子字符串中的字符。</li>
<li><strong><em>int capacity()</em></strong><br>返回当前容量</li>
<li><strong><em>void setCharAt(int index, char ch)</em></strong><br>将给定索引处的字符设置为 ch。</li>
<li><strong><em>void setLength(int newLength)</em></strong><br>设置字符序列的长度</li>
</ul>
<p><strong>在大部分情况下 StringBuilder &gt; StringBuffer</strong></p>
<p>java.lang.StringBuildejava.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>
<h3 id="三者的区别"><a href="#三者的区别" class="headerlink" title="三者的区别"></a>三者的区别</h3><p><strong>1、对象的可变与不可变</strong><br>String对象不可变，StringBuffer和StringBuilder对象可变。</p>
<p><strong>2、 线程是否安全</strong></p>
<ul>
<li>String中的对象是不可变的，也就可以理解为常量，所以线程安全。</li>
<li>StringBuffer中的方法大都采用了synchronized关键字修饰，所以是线程安全的。</li>
<li>StringBuilder没有对方法进行加同步锁，所以是非线程安全的。</li>
</ul>
<p><strong>3、 字符串追加速度比较</strong><br>StringBuilder &gt; StringBuffer &gt; String</p>
<p><strong>4、 StringBuffer和StringBuilder的共同点</strong></p>
<ul>
<li>StringBuffer和StringBuilder有公共的抽象父类AbstractStringBuilder</li>
<li>抽象类与一个接口的区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。</li>
<li>StringBuilder和StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(…)。只是StringBuffer会在方法上加上synchronized关键字，进行同步。<br>如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><em>String</em></strong>：适用于少量的字符串操作的情况<br><strong><em>StringBuilder</em></strong>：适用于单线程下在字符缓冲区进行大量操作的情况<br><strong><em>StringBuffer</em></strong>：适用于多线程下在字符缓冲区进行大量操作的情况</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title>jd0402.最小高度树</title>
    <url>/2020/07/12/jd0402-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<p>*<em>示例: *</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">          0 </span><br><span class="line">         &#x2F; \ </span><br><span class="line">       -3   9 </span><br><span class="line">       &#x2F;   &#x2F; </span><br><span class="line">     -10  5</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS-二分查找"><a href="#DFS-二分查找" class="headerlink" title="DFS + 二分查找"></a>DFS + 二分查找</h2><p>这道题给的是有序数组, 根据三个深度优先遍历的性质可知, 这是中序遍历的结果, 不过做这道题时用不到这个性质.</p>
<p>要根据有序数组创建二叉搜索树, 那么就尽量把中间的元素作为根节点, 然后把左边数组中的中间元素作为左节点, 右边数组的中间元素作为右节点, 以此往下推, 获得递归算法流程为:</p>
<ol>
<li>*<em>终止条件: *</em> 数组的长度为0, 无法创建出节点, 返回<code>null</code></li>
<li>*<em>递归过程: *</em> <ol>
<li>根据已知数组将最中间的元素作为根节点</li>
<li>把前半段的数组递归返回值作为左子节点</li>
<li>把后半段的数组递归返回值作为右子节点</li>
</ol>
</li>
<li>*<em>返回值: *</em> 根据当前数组创建的根节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode temp = <span class="keyword">new</span> TreeNode(nums[nums.length / <span class="number">2</span>]);</span><br><span class="line">    temp.left = sortedArrayToBST(Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length / <span class="number">2</span>));</span><br><span class="line">    temp.right = sortedArrayToBST(Arrays.copyOfRange(nums, nums.length / <span class="number">2</span> + <span class="number">1</span>, nums.length));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>java中带参数的try(){}语法含义</title>
    <url>/2020/07/18/java%E4%B8%AD%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84try-%E8%AF%AD%E6%B3%95%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<p>在学习Mybatis框架时, 官方文档里出现了如下的参考代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查阅资料知道, 这是JDK7的新特性, 是针对于继承了Closeable类的服务推出的</p>
<p>其最简形式 为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(Resource res = xxx)<span class="comment">//可指定多个资源</span></span><br><span class="line">&#123;</span><br><span class="line">     work with res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try块退出时，会自动调用res.close()方法，关闭资源。</p>
<p>不用写一大堆finally来关闭资源,所有实现Closeable的类声明都可以写在里面,最常见于流操作,socket操作,新版的httpclient也可以;<br>需要注意的是,try()的括号中可以写多行声明,每个声明的变量类型都必须是Closeable的子类,用分号隔开.</p>
<p>在没有这个语法之前,流操作一般是这样写的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream is = <span class="keyword">null</span>;</span><br><span class="line">OutputStream os = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(os!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			os.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(is!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			is.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而现在你可以这样写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line">	InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"..."</span>);</span><br><span class="line">	OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"..."</span>);</span><br><span class="line">)&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生活一下子就美好了!!</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>jd0403.特定深度节点链表</title>
    <url>/2020/07/12/jd0403-%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 <code>D</code>，则会创建出 <code>D</code> 个链表）。返回一个包含所有深度的链表的数组。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5,null,7,8]</span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">       &#x2F;  \ </span><br><span class="line">      2    3</span><br><span class="line">     &#x2F; \    \ </span><br><span class="line">    4   5    7</span><br><span class="line">   &#x2F;</span><br><span class="line">  8</span><br><span class="line"></span><br><span class="line">输出：[[1],[2,3],[4,5,7],[8]]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="BFS-队列"><a href="#BFS-队列" class="headerlink" title="BFS + 队列"></a>BFS + 队列</h2><p>这道题就是层序遍历, 然后将每一层的节点各自存储起来. 之前做过类似的题目, 不过这道题的不同点在于每层的节点数值用链表存储, 但是不影响层序遍历的思路.</p>
<p>做层序遍历的题目时我们会用到队列, 先进先出的特点能够正确地模拟出BFS的顺序.</p>
<p>*<em>算法流程: *</em></p>
<ol>
<li><p>*<em>初始化: *</em> 首先创建一个队列, 将根节点入队; 创建一个列表用于存放每一层的链表, 因为不知道一共有多少层, 所以最后再创建题目要求的数组.</p>
</li>
<li><p><strong>循环过程:</strong> 当队列为空时跳出循环</p>
<ol>
<li><p>每次循环时, 队列中有多少个节点, 那么就说明这一层有多少个节点, <code>int levelLength = queue.size()</code></p>
</li>
<li><p>为该层创建一个链表</p>
<ul>
<li>循环遍历该层所有节点, 将每个节点的左右子节点入队, 并存储在链表中</li>
</ul>
</li>
<li><p>将该层的链表存入列表中</p>
</li>
</ol>
</li>
<li><p>*<em>返回值: *</em> 根据列表大小创建链表数组, 将列表的元素迁移进去</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode[] listOfDepth(TreeNode tree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ListNode[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        List&lt;ListNode&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(tree);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> levelLength = queue.size();</span><br><span class="line">            ListNode listNode = <span class="keyword">new</span> ListNode(queue.peek().val);</span><br><span class="line">            ListNode cur = listNode;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelLength; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (i!=<span class="number">0</span>)&#123;</span><br><span class="line">                    cur.next = <span class="keyword">new</span> ListNode(node.val);</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(listNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> ListNode[ans.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>队列</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>jd0412.求和路径</title>
    <url>/2020/07/15/jd0412-%E6%B1%82%E5%92%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>
<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>

<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS + 递归"></a>DFS + 递归</h2><p>又是一道路径求和的问题, 与剑指OFFER-34题不同的是, 本题需要返回的是满足条件的路径数量而不是具体的路径, 这是降低了难度的, 也就不需要利用回溯法计算了, 不必考虑每次递归后再回退一步.</p>
<p>直观上更偏向于采用先序遍历的方法自顶向下寻找路径. 本题有一个难点在于没有规定必须是从根节点到叶子节点才算是合法路径, 从任意节点开始到任意节点结束只要路径和等于目标值就可以. 所以每往路径里添加一个元素, 就从新添加的地方往前递加, 一旦满足条件就把结果加一.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jd0412</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dep = depth(root);</span><br><span class="line">        <span class="keyword">int</span>[] paths = <span class="keyword">new</span> <span class="keyword">int</span>[dep];</span><br><span class="line">        pathSum(root, sum, <span class="number">0</span>, paths);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> level, <span class="keyword">int</span>[] paths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        paths[level] = root.val;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            temp += paths[i];</span><br><span class="line">            <span class="keyword">if</span> (temp == sum)</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pathSum(root.left, sum, level + <span class="number">1</span>, paths);</span><br><span class="line">        pathSum(root.right, sum, level + <span class="number">1</span>, paths);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>jd0406.后继者</title>
    <url>/2020/07/15/jd0406-%E5%90%8E%E7%BB%A7%E8%80%85/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p>
<p>如果指定节点没有对应的“下一个”节点，则返回<code>null</code>。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [2,1,3], p &#x3D; 1</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br><span class="line"></span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], p &#x3D; 6</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   4</span><br><span class="line"> &#x2F;   </span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">输出: null</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS-迭代"><a href="#DFS-迭代" class="headerlink" title="DFS + 迭代"></a>DFS + 迭代</h2><p>题目中已经说明了是中序遍历的后继者, 所以在中序遍历的基础上进行操作</p>
<p>这里用迭代的方法完成.</p>
<p>根据二叉树的中序遍历的迭代过程可知, 每遍历完一个节点, 下面遍历到的元素一定是栈中下一个将要弹出的节点. 所以思路就是遍历的过程中如果遇到了目标节点, 就把下一个将要出栈的节点弹出即可.</p>
<p>具体的做法就是在中序遍历过程的基础上添加一个布尔变量, 初始值为<code>false</code>, 每次出栈时都检查一下是否是<code>true</code>, 若为<code>true</code>就把弹出的节点返回. 如果在遍历过程中遇到了目标节点, 就把该布尔变量变为<code>true</code>, 那么下一个节点就会返回.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == p.val) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jd0405.合法二叉搜索树</title>
    <url>/2020/07/12/jd0405-%E5%90%88%E6%B3%95%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现一个函数，检查一棵二叉树是否为二叉搜索树。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>验证是否是二叉搜索树, 我们可以根据中序遍历结果是升序数组, 所以思路就是中序遍历这棵树, 一旦发现当前节点的数值小于等于前一个数, 那么就证明不是二叉搜索树.</p>
<p>简单来说, 就是在中序遍历的基础上创建一个变量记录着前一个数值, 多一个比较的步骤. </p>
<h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS 递归"></a>DFS 递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isValidBST(root.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= pre) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root.val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="DFS-迭代"><a href="#DFS-迭代" class="headerlink" title="DFS 迭代"></a>DFS 迭代</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (cur.val&lt;=pre)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        pre = cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz06.从尾到头打印链表</title>
    <url>/2020/07/22/jz06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>利用栈先入后出的性质, 按顺序将每个节点入栈, 然后向数组中弹出, 生成的数组就是完成逆序的链表.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = stack.size();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        res[i] = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>先递归到链表的末尾, 然后将节点加入, 类似树的后序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint2(ListNode head) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    recur(head, list);</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        res[i] = list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode head, ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    recur(head.next, list);</span><br><span class="line">    list.add(head.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>jz18.删除链表的节点</title>
    <url>/2020/07/22/jz18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p><strong>注意：</strong>此题对比原题有改动</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>遍历整个链表, 如果下一个节点的值等于目标值,那么跳过下个节点, 令<code>cur.next = cur.next.next</code>. 因为要考虑头结点, 所以创建一个哨兵节点, 从这个哨兵节点开始遍历 .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    pre.next = head;</span><br><span class="line">    ListNode cur = pre;</span><br><span class="line">    <span class="keyword">while</span> (cur.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.next.val == val)&#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>jz24.反转链表</title>
    <url>/2020/07/22/jz24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>使用双指针的方法, 过程见图:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    <span class="keyword">while</span> (pre!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp = pre.next;</span><br><span class="line">        pre.next = cur;</span><br><span class="line">        cur = pre;</span><br><span class="line">        pre = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码要点在于, 每遍历到一个节点, 一定要记录下<code>pre</code> 的下一个节点, 因为一旦反转之后, 就无法直接通过<code>.next</code>继续遍历</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><img src="http://qcxz71s06.bkt.clouddn.com/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的cur就是最后一个节点</span></span><br><span class="line">    ListNode cur = reverseList(head.next);</span><br><span class="line">    <span class="comment">//这里请配合动画演示理解</span></span><br><span class="line">    <span class="comment">//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class="line">    <span class="comment">//而head是4，head的下一个是5，下下一个是空</span></span><br><span class="line">    <span class="comment">//所以head.next.next 就是5-&gt;4</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    <span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>jd1712.BiNode</title>
    <url>/2020/07/15/jd1712-BiNode/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>
<p>返回转换后的单向链表的头节点。</p>
<p>注意：本题相对原题稍作改动</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [4,2,5,1,3,null,6,0]</span><br><span class="line">输出： [0,null,1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="中序遍历迭代"><a href="#中序遍历迭代" class="headerlink" title="中序遍历迭代"></a>中序遍历迭代</h2><p>因为要符合二叉搜索树的性质, 所以要保持顺序, 因此采用中序遍历的方法.</p>
<p>每遍历到一个节点, 需要将当前的左节点置空, 然后接在上一个节点上, 作为上一个节点的右节点. 因为要时刻记录上一个节点的情况, 所以提前初始化一个哨兵节点, 随着遍历的进行, 这个哨兵节点也不断移动.</p>
<p>所以算法大致流程为, 在中序遍历的基础上:</p>
<ol>
<li>将当前从栈中弹出的节点左子节点置空</li>
<li>将当前从栈中弹出的节点接在上一个节点的右边</li>
<li>将上一个节点移动到当前节点处</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBiNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        TreeNode prev = head;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                cur.left = <span class="keyword">null</span>;</span><br><span class="line">                prev.right = cur;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="中序遍历递归"><a href="#中序遍历递归" class="headerlink" title="中序遍历递归"></a>中序遍历递归</h2><p>思路跟迭代法一样, 都是在遍历到当前节点时进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBiNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode head = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    inorder(root, head);</span><br><span class="line">    <span class="keyword">return</span> head.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">inorder</span><span class="params">(TreeNode root, TreeNode prev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root!= <span class="keyword">null</span>)&#123;</span><br><span class="line">        prev = inorder(root.left, prev);</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        prev.right = root;</span><br><span class="line">        prev = root;</span><br><span class="line">        prev = inorder(root.right, prev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz26.树的子结构</title>
    <url>/2020/07/09/jz26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><hr>
<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>看到这道题时经过分析可知需要两个递归过程:</p>
<p>过程一是<code>判断当前节点为根节点的树与树B是否相同</code> || <code>当前节点的左子树与树B是否相同</code> || <code>当前节点的右子树与树B是否相同</code>,   写成<code>isSubStructure(A, B)</code> 方法:</p>
<ol>
<li><p><strong>特例:</strong><br>当 树<code>A</code> 为空 <strong>或</strong> 树 <code>B</code> 为空 时，直接返回 <code>false</code> </p>
</li>
<li><p><strong>返回值</strong>: 若树<code>B</code>是树 <code>A</code>的子结构，则必满足以下三种情况之一，因此用或 <code>||</code> 连接</p>
<ol>
<li>以 节点 <code>A</code>为根节点的子树 包含树 <code>B</code> ，对应 recur(A, B)；</li>
<li>树 <code>B</code> 是 树 <code>A</code>左子树 的子结构，对应 isSubStructure(A.left, B)；</li>
<li>树 <code>B</code>是 树 <code>A</code>右子树 的子结构，对应 isSubStructure(A.right, B)；</li>
</ol>
</li>
</ol>
<p>过程二是判断两个树是否相同, 要求是两节点的值相同, 左右子树也相同, 写成<code>recur()</code> 方法:</p>
<ol>
<li><p><strong>终止条件:</strong></p>
<ol>
<li>当节点<code>B</code> 为空：说明树 <code>B</code> 已匹配完成（越过叶子节点），因此返回<code>true</code> ；</li>
<li>当节点<code>A</code>为空：说明已经越过树 <code>A</code>叶子节点，即匹配失败，返回<code>false</code> ；</li>
<li>当节点<code>A</code> 和 <code>B</code>的值不同：说明匹配失败，返回 <code>false</code> ；</li>
</ol>
</li>
<li><p><strong>返回值:</strong></p>
<ol>
<li>判断 <code>A</code> 和 <code>B</code> 的左子节点是否相等，即 recur(A.left, B.left) ；</li>
<li>判断 <code>A</code> 和 <code>B</code> 的右子节点是否相等，即 recur(A.right, B.right) ；</li>
</ol>
</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/0e15908809807327aa87c748c4cf1d850eeb63cc13df94c87439cbaffb535005-Picture2.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/5d9592ec644c6fc765d6e223d4beb3a74ecf46a32b703d9d02cdbeb9f88e9523-Picture3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/76016cb01f7c051318761388eeadd774b334c6da3c5722754452fc82da87c04b-Picture4.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/efe061c2ae8ae6c75b4f36bfd766d60471b4bc985cb330cdae5805043b19f440-Picture5.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/987e1803a3600ef2b8e18320589e058e189888fb4d88389527f33499340f149a-Picture6.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3850986482cd6344935ac823e8b396b52f02ae196b573cea1e7ebecb97eb063c-Picture7.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/cb14268630fd9efa872f077ee625f8066cd7c818f11df9fc9436fa371994de8a-Picture8.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/24d94f730e0a7fc091ab321349c4524dd51828db1fa6a9c1b6455561fa27708e-Picture9.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz28.对称的二叉树</title>
    <url>/2020/07/09/jz28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>首先要清楚对称二叉树的定义: 对于树中任意两个对称节点<code>L</code> 和 <code>R</code>, 一定有:</p>
<ul>
<li><code>L.val=R.val</code> ：即此两对称节点值相等。</li>
<li><code>L.left.val = R.right.valL.left.val=R.right.val</code> ：即 <code>L</code> 的 左子节点 和 <code>R</code>的 右子节点 对称；</li>
<li><code>L.right.val = R.left.valL.right.val=R.left.val</code> ：即 <code>L</code> 的 右子节点 和 <code>R</code> 的 左子节点 对称。</li>
</ul>
<p>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树.</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/ebf894b723530a89cc9a1fe099f36c57c584d4987b080f625b33e228c0a02bec-Picture1.png" alt=""></p>
<p>递归思路:</p>
<ol>
<li><strong>终止条件:</strong> <ul>
<li>若两个节点都为<code>null</code>, 说明之前的的节点都符合对称条件, 返回<code>true</code></li>
<li>若只有一个节点为<code>null</code>, 说明只有一个节点越过叶子节点, 不对称, 返回<code>false</code></li>
<li>若两个节点的值不相等, 返回<code>false</code>, 没什么好说的</li>
</ul>
</li>
<li>*<em>递归过程: *</em><ul>
<li>判断<code>L.left</code> 和 <code>R.right</code> 是否对称</li>
<li>判断<code>L.right</code>和<code>R.left</code>是否对称</li>
</ul>
</li>
<li>*<em>返回值: *</em> 返回值为布尔值, 将两个对称条件用<code>&amp;&amp;</code> 连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz28</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> || recur(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span> || left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(left.left, right.right) &amp;&amp; recur(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz07.重建二叉树</title>
    <url>/2020/07/09/jz07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   3</span><br><span class="line"> &#x2F;  \</span><br><span class="line">9   20</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    15   7</span><br></pre></td></tr></table></figure>

<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>这道题要充分用到二叉树前序遍历与中序遍历的数量关系.</p>
<p>示例中两个数组的关系进行分析可知:</p>
<blockquote>
<p><strong>前序遍历特点：</strong> 节点按照 <code>[ 根节点 | 左子树 | 右子树 ]</code> 排序，以题目示例为例：<code>[ 3 | 9 | 20 15 7 ]</code></p>
<p><strong>中序遍历特点：</strong> 节点按照 <code>[ 左子树 | 根节点 | 右子树 ]</code> 排序，以题目示例为例：<code>[ 9 | 3 | 15 20 7 ]</code></p>
</blockquote>
<p>对于根节点<code>3</code> 来说, 它排在前序遍历数组的最前面, 在中序遍历数组中找到<code>3</code> 的位置, 可以发现在它之前的元素全部属于左子树, 在它之后的元素全部属于右子树.</p>
<p>这个这个规律可以套用到所有子树中, 比如<code>20</code> 是右子树的根节点, 它在前序遍历数组中位于该子树范围中的第一位(<code>[20, 15, 7]</code>是右子树), 在中序遍历中找到<code>20</code> 的位置, 在其范围内(<code>[15, 20, 7]</code>) 左边的元素都属于新的左子树, 右边的元素都属于新的右子树. 这样就构成了递归关系.</p>
<p>所以我们的递归思路是:</p>
<ul>
<li><p><strong>递归参数:</strong> 前序遍历中根节点的索引<code>pre_root</code>、中序遍历左边界<code>in_left</code>、中序遍历右边界<code>in_right</code></p>
</li>
<li><p><strong>终止条件：</strong> 当 <code>in_left &gt; in_right</code> ，子树中序遍历为空，说明已经越过叶子节点，此时返回 <code>null</code></p>
</li>
<li><p><strong>递推工作：</strong></p>
<ol>
<li><strong>建立根节点<code>root</code></strong>： 值为前序遍历中索引为pre_root的节点值。</li>
<li><strong>搜索根节点<code>root</code>在中序遍历的索引<code>i</code>：</strong> 为了提升搜索效率，本题解使用哈希表 <code>dic</code> 预存储中序遍历的值与索引的映射关系，每次搜索的时间复杂度为 O(1)</li>
<li><strong>构建根节点<code>root</code>的左子树和右子树：</strong> 通过调用<code>recur()</code> 方法开启下一层递归。<ul>
<li>左子树： 根节点索引为<code>pre_root + 1</code> ，中序遍历的左右边界分别为 <code>in_left</code> 和<code>i - 1</code>。</li>
<li>右子树： 根节点索引为<code>i - in_left + pre_root + 1</code>（即：根节点索引 + 左子树长度 + 1），中序遍历的左右边界分别为<code>i + 1</code>和<code>in_right</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p> 判断下一次递归时子树的左右边界比较容易, 就是当前<code>i</code> 值加一或减一即可, 判断左右子树的根节点时, 左子树根节点很容易, 当前节点在前序遍历数组中的后一个元素就是左子树的根节点. 下面来分析右子树根节点如何表示:</p>
<p>我们已经知道当前树的根节点在前序遍历数组中的索引<code>pre_root</code> , 它后面紧跟着的是左子树, 所以得出左子树节点的数量就可以得到右子树根节点的索引了.我们还知道当前树根节点在中序遍历数组中的索引<code>i</code>, 以及左子树的边界<code>in_left</code> ,那么<code>i - in_left</code> 就是左子树的节点数量.  <strong>所以右子树的根节点索引为<code>i- in_left + pre_root + 1.</code></strong></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/asdf1.png" alt="">)<img src="http://qcxz71s06.bkt.clouddn.com/asgfrg2.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/ergfb3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/hq4aebdgsf4.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/qyjhg5.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/2tyesujrd6.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/2ewagrhetjy7.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/gd8.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/wertyu9.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz07</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] pre;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        pre = preorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            dic.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> pre_root, <span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in_left &gt; in_right)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = dic.get(pre[pre_root]);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[pre_root]);</span><br><span class="line"></span><br><span class="line">        root.left = recur(pre_root + <span class="number">1</span>, in_left, i - <span class="number">1</span>);</span><br><span class="line">        root.right = recur(i - in_left + pre_root + <span class="number">1</span>, i + <span class="number">1</span>, in_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz32-Ⅰ.从上到下打印二叉树</title>
    <url>/2020/07/09/jz32-%E2%85%A0-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。</p>
<p>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/f824fdd8052ae4ee657365c98633480caf03c60e42e4661797618e318baf8664-Picture0.png" alt=""></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li><p><strong>特例处理：</strong> 当树的根节点为空，则直接返回空列表 [] ；</p>
</li>
<li><p><strong>初始化：</strong> 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root]</code> ；</p>
</li>
<li><p><strong>BFS 循环：</strong> 当队列 <code>queue</code> 为空时跳出；</p>
<ol>
<li><strong>出队：</strong> 队首元素出队，记为 <code>node</code>；</li>
<li><strong>打印：</strong> 将 <code>node.val</code>添加至列表 <code>tmp</code>尾部；</li>
<li><strong>添加子节点：</strong> 若 <code>node</code>的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code>；</li>
</ol>
</li>
<li><p><strong>返回值：</strong> 返回打印结果列表<code>res</code>即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz32</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            ans.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz27.二叉树的镜像</title>
    <url>/2020/07/09/jz27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>镜像输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>在解题之前要先了解 <strong>二叉树的镜像</strong> 是什么:</p>
<blockquote>
<p>二叉树镜像定义： 对于二叉树中任意节点<code>root</code> ，设其左 / 右子节点分别为 <code>left</code>, <code>right</code> ；则在二叉树的镜像中的对应<code>root</code>节点，其左 / 右子节点分别为 <code>right</code>, <code>left</code>。</p>
</blockquote>
<p><img src="http://qcxz71s06.bkt.clouddn.com/9ac3c2730ab2afea15e720e6e6d7ce66aa2cb8659665085e775f8fff2c5b4285-Picture1.png" alt=""></p>
<p>递归的思路很简单, 就是遍历每个节点, 交换其左右子树即可</p>
<ol>
<li><strong>终止条件:</strong> 当节点<code>root</code> 为空时, 返回<code>null</code></li>
<li><strong>递归过程:</strong><ol>
<li>初始化一个临时节点<code>temp</code> 暂存 左儿子</li>
<li>令左儿子等于右儿子</li>
<li>令右儿子等于临时节点</li>
</ol>
</li>
<li>*<em>返回值: *</em>当前的节点<code>root</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz27</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">recur</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        recur(root.left);</span><br><span class="line">        recur(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="栈遍历方法"><a href="#栈遍历方法" class="headerlink" title="栈遍历方法"></a>栈遍历方法</h2><p>利用栈或队列遍历树的所有节点, 交换每个节点的左右儿子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node.left!= <span class="keyword">null</span>)</span><br><span class="line">                stack.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>)</span><br><span class="line">                stack.add(node.right);</span><br><span class="line">            TreeNode temp = node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>jz32-Ⅲ.从上到下打印二叉树Ⅲ</title>
    <url>/2020/07/10/jz32-%E2%85%A2-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>经过前两道题的分析, 我们已经可以操控每一层的节点了, 这道题延伸出来的是层数的奇偶问题, 如果奇数层正序摆放, 偶数层逆序摆放. </p>
<p>既然经过上一道题每一层的层数我们已经记录下来了, 那就只剩摆放的问题了.</p>
<p>将每一层打印的数用双端队列存储, 那么每遍历到一层时只需要判断该层的奇偶性然后采用头部添加还是尾部添加就好了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> level_length = queue.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level_length; i++) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>) temp.addLast(node.val);</span><br><span class="line">            <span class="keyword">else</span> temp.addFirst(node.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(temp);</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz32-Ⅱ.从上到下打印二叉树Ⅱ</title>
    <url>/2020/07/10/jz32-%E2%85%A1-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="层序遍历-BFS"><a href="#层序遍历-BFS" class="headerlink" title="层序遍历 BFS"></a>层序遍历 BFS</h2><p>这道题与同题号的第一道题都是从上到下打印每一层的节点数值, 但是这道题需要将每一层的数值单独放在一个列表里, 这就需要记录下遍历到了第几层以及每一层有多少个节点.</p>
<p>经过上一道题的遍历过程我们发现, 每次到了新的一层, 队列中存储的节点数量就是该层将要遍历的数量, 将该层的所有节点都遍历完成后就会进入下一层, 我们抓住这个性质执行以下的代码流程:</p>
<ol>
<li><p><strong>初始化:</strong></p>
<ul>
<li>创建一个队列<code>queue</code> 用来进队和出队操作, 先将<code>root</code> 根节点入队</li>
<li>初始化一个列表<code>res</code> 用来记录每一层的数值, 它就是最后要返回的列表</li>
<li>初始化一个变量<code>level = 0</code> , 用来表示当前的层数, 对应的是<code>res</code> 列表索引, 所以从0开始</li>
</ul>
</li>
<li><p><strong>循环过程:</strong> 当队列为空时跳出循环操作</p>
<ol>
<li>往<code>res</code> 中新增一个空列表用于存放本层的数值</li>
<li>创建一个变量记录本层有多少个节点, <code>int level_length = queue.size()</code></li>
<li>进入新的循环将队列中的节点全部抛出, 数值添加到列表中, 并将左右子节点入队</li>
</ol>
</li>
<li><p><strong>返回值:</strong> 返回<code>res</code> 即可</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz32_2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">            <span class="keyword">int</span> level_length = queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level_length; i++) &#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                res.get(level).add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz34.二叉树中和为某一值的路径</title>
    <url>/2020/07/10/jz34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>

<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>这道题明显可以通过回溯算法进行遍历求解, 就是<code>先序遍历+路径记录</code></p>
<p>首先考虑递归的终止条件, 需要注意的是题目中描述只有到达叶子节点才算一条完整的路径, 所以不必考虑路径中途停止的情况, 直接将终止条件设置成<code>root == null</code>即可, 表示已经遍历穿了.</p>
<ol>
<li><strong>终止条件:</strong> <code>root== null</code>, 直接返回</li>
<li>*<em>递归过程: *</em> <ol>
<li>路径更新: 将当前的节点值加入路径中</li>
<li>目标更新: 将当前的目标值减去当前的节点值</li>
<li>判断路径是否满足条件: 若当前节点为叶子节点并且目标值为0, 则将当前路径加入到<code>res</code> 列表中.</li>
<li>遍历左右子节点</li>
<li>路径恢复</li>
</ol>
</li>
</ol>
<blockquote>
<p>值得注意的是，记录路径时若直接执行 res.append(path) ，则是将 path 对象加入了 res ；后续 path 改变时， res 中的 path 对象也会随之改变。</p>
<p>正确做法：res.append(list(path)) ，相当于复制了一个 path 并加入到 res 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz34</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        recur(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        path.addLast(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        recur(root.left, target);</span><br><span class="line">        recur(root.right, target);</span><br><span class="line">        path.removeLast();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BST</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>jz54.二叉搜索树的第K大节点</title>
    <url>/2020/07/11/jz54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="BFS-排序"><a href="#BFS-排序" class="headerlink" title="BFS + 排序"></a>BFS + 排序</h2><p>直观印象就是先将二叉树的节点遍历出来, 然后经过排序得出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res.get(res.size() - k);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是这样做的时间复杂度很差.</p>
<hr>
<h2 id="中序遍历-重要"><a href="#中序遍历-重要" class="headerlink" title="中序遍历(重要)"></a>中序遍历(重要)</h2><blockquote>
<p>二叉搜索数的中序遍历为<strong>递增序列</strong></p>
</blockquote>
<p>只要得到二叉搜索树的中序遍历数组, 就直接免去了排序的过程, 大大加快程序执行速度.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest2</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    recur(res, root);</span><br><span class="line">    <span class="keyword">return</span> res.get(res.size() - k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(List&lt;Integer&gt; res, TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>)</span><br><span class="line">            recur(res, root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>)</span><br><span class="line">            recur(res, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz55-Ⅰ.二叉树的深度</title>
    <url>/2020/07/11/jz55-%E2%85%A0-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>之前做层序遍历的相关题目时有记录过当前遍历所在层数, 那么直接把这个值拿来用就是最大的深度了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> levelNums = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNums; i++) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p><strong>关键点: ** 树的深度和其左右子树的深度之间有着重要关系. 显然, **此树的深度</strong> 等于 <strong>左子树深度</strong> 与 <strong>右子树深度</strong> 中的 <strong>最大值 +1</strong></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/9b063f1f2b7ba125b97a2a11c5f774c0f8ff4df594696993a8eb8282750dae0d-Picture1.png" alt=""></p>
<ol>
<li><strong>终止条件：</strong> 当 <code>root</code> 为空，说明已越过叶节点，因此返回 深度 0 。</li>
<li>*<em>递归过程： *</em> 本质上是对树做后序遍历<ol>
<li>计算节点 <code>root</code> 的 <strong>左子树的深度</strong> ，即调用 <code>maxDepth(root.left)</code></li>
<li>计算节点 <code>root</code> 的 <strong>右子树的深度</strong> ，即调用 <code>maxDepth(root.right)</code></li>
</ol>
</li>
<li><strong>返回值：</strong> 返回 <strong>此树的深度</strong> ，即 <code>max(maxDepth(root.left), maxDepth(root.right)) + 1</code>。</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/ca69f6f15b15999009e903a7c1284effc33ec2317f213ce9170a5d638e1d8b0c-Picture2.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/8026850d70bbeb67a495d9d59eba48cdb43662208e27b430f866436db6fa6673-Picture3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/41c5379ebad1af9e846bbd5f3885968b5186f414e145b6468350ce2c70063f9c-Picture4.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/15270a1bf3ce624fc2928a9bd76810221987abb940ff4c06d7c283be5e25c348-Picture5.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/a27fbe2c4f711cfc1d3c0b7166ad370a1b0c1d7241eeec27d0581abf9722011d-Picture6.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/acb83071a507b8c5b33a31cf0bf2469127df59dcf853c0f75cc299b26042f632-Picture7.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/a10e134e2d20b51b7c444f3102464148c7758851452cf7cff2ef3df5666afbaf-Picture8.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/65f9e2a001a58e4fba481a428a7f07011b6e9fead22909c0acb14fa6d88fc28c-Picture9.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/770a9ba56e74def0292539aa6814785a81cbc2e4e6ef559427d23a91703d096e-Picture10.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/7ecf07e4017438980ea0fe8145e71f33b41f6799c2b567ab0c16cfd25d037f02-Picture11.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz37.序列换二叉树</title>
    <url>/2020/07/11/jz37-%E5%BA%8F%E5%88%97%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p><strong>示例:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>这道题要求实现两个方法, 一个是层序遍历将一个二叉树序列化, 还要根据已知的序列化字符串还原出原二叉树. </p>
<p>首先先来解决序列化问题:</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>这个序列化问题与之前的各种BFS问题一样, 无非就是需要把<code>null</code> 也打印出来, 并且最终结果生成字符串的形式. 字符串形式好说, 直接利用列表的<code>toString()</code> 方法即可. 下面主要来讨论如何把<code>null</code> 打印出来.</p>
<p>之前的BFS过程中, 都有这么一个步骤:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)</span><br><span class="line">    queue.add(temp.left);</span><br><span class="line"><span class="keyword">if</span> (temp.right != <span class="keyword">null</span>)</span><br><span class="line">    queue.add(temp.right);</span><br></pre></td></tr></table></figure>

<p>这么写是为了不让<code>null</code> 入队, 而这道题我们需要将<code>null</code> 入队, 所以两个判断句省去.</p>
<p>另外, 判断一下如果当前出队的节点为<code>null</code>, 则向列表中加入<code>null</code> , 不再考虑<code>null</code> 的左右子节点.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(temp.val);</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>给定一个包含<code>null</code> 的字符串, 将它还原成一个完整二叉树. 这就要分析层序遍历中各节点元素的顺序关系了</p>
<p>直接看图解:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/a372d9c99fecd301e82a34fbe417264c4c09629df2a75c9fea564653f2aa4d6c-Picture15.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/279936eb04ae459c9bc8e87e6dc967b21dca2603648b161a52a93510a3916c1a-Picture16.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/0d118b74490c624afbb18fbf82cd4fc844bce7aea4246efe6c599df9d1e005ca-Picture17.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/6762b541459782314176442011b699913085b7d34ab2598d6044374fe8ee9c6d-Picture18.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/ce3d8c2f587f6f384784b9915f301115ece35dcc8f18aa9c4120e40972e43594-Picture19.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/cb179bc30eab589fc4ce90f7ebdf4269a330e87e1bb5498f241c4634b00c0dc1-Picture20.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/00b3903a3e296ffdd91da6fce33ac9b81ee6d43a5171589cb43d15ba64d61dd8-Picture21.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/8180b8a750c32af66868f7550547effed37d77602c1d4347674bef4803270b82-Picture22.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/455c33478d9236a851313e402f1ef7453686001263ca1002c146923c9d0a1033-Picture23.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/8d207a75cf994e0762b2a420c593553355f1e31ab0b08eaa6245bb5b6a6697b4-Picture24.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/76fe0ddf83303622aa4d954fec53f663c9a5bad3187afbe9c586ec127fd0e8f0-Picture25.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3180c5691fe13aa9d94f352fef42a1e14f931e9327f6041dadb8da3e450b6de1-Picture26.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/dc493c0a7f30e042ee563e13a16bc4c60964d7f4c9d6e52f14625b9b14672f67-Picture27.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/0351597bfa8ec0fa9e715d2182d5166498df3de35b53668fc121115e2478ffc8-Picture28.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/4abbdbb9ee212f3e89515c8909265df08b641dc389a076064ef71bfe8d9b53bd-Picture29.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/f3a8767a785cf7d384e0be4e607593f800fc8822cdfae0ce54290748a82f511b-Picture30.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/2dde0419c3d7a134e6fb8fcc38c85a5180df04b197f8b6cd37137d38da33e8f5-Picture31.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.equals(<span class="string">"[]"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String[] strings = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>).split(<span class="string">", "</span>);</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(strings[<span class="number">0</span>]));</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!strings[i].equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">            temp.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(strings[i]));</span><br><span class="line">            queue.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!strings[i].equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">            temp.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(strings[i]));</span><br><span class="line">            queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















































]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz68--Ⅰ.二叉搜索树的最近公共祖先</title>
    <url>/2020/07/12/jz68-%E2%85%A0-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/binarysearchtree_improved.png" alt=""></p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>祖先的定义：</strong> 若节点 p 在节点 root的左（右）子树中，或 p = root，则称 root是 p的祖先。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/28242ac7394dfa60a3598a4cf145af9b8311d8f325838e5875d65f6d4ed692fa-Picture1.png" alt=""></p>
<p><strong>最近公共祖先的定义：</strong> 设节点 root为节点 p,q的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。</p>
<p>根据以上定义，若 root 是 p,q的 最近公共祖先 ，则只可能为以下情况之一：</p>
<ol>
<li>p 和 q 在 root 的子树中，且分列 root的 异侧（即分别在左、右子树中）；</li>
<li>p = root，且 q 在 root 的左或右子树中；</li>
<li>q = root，且 pp 在 root 的左或右子树中；</li>
</ol>
<p><strong>本题给定了两个重要条件：</strong>① 树为 二叉搜索树 ，② 树的所有节点的值都是 唯一 的。根据以上条件，可方便地判断 p,q 与 root 的子树关系，即：</p>
<p>若<code>root.val &lt; p.val</code>，则 p 在 root 右子树 中；<br>若 <code>root.val &gt; p.val</code>，则 p 在 root 左子树 中；<br>若 <code>root.val = p.val</code>，则 p 和 root 指向 同一节点 。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>这道题一定要用到二分搜索树的性质, 即左子树的元素肯定都比当前节点小, 右子树的元素都比当前节点大. </p>
<p>如果两个目标节点都比当前节点大, 那么满足条件的节点一定都都在右子树中, 反之一定在左子树中, 如果左右子树一边一个 或者说当前节点就等于一个目标值, 那么当前节点就是最近的公共祖先.</p>
<p>以这个思路去编写代码很容易:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">            root = root.right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">            root = root.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor2</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz55-Ⅱ.平衡二叉树</title>
    <url>/2020/07/12/jz55-%E2%85%A1-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p><strong>示例一</strong>：给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回 <code>true</code> 。</p>
<p><strong>示例二</strong>：给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>

<p>返回 <code>false</code> 。</p>
<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="先序遍历-判断深度-自顶向下"><a href="#先序遍历-判断深度-自顶向下" class="headerlink" title="先序遍历 + 判断深度(自顶向下)"></a>先序遍历 + 判断深度(自顶向下)</h2><p>根据上道题(jz55-Ⅰ)算出的树的深度进行拓展, 我们通过递归的方法已经算出了每个子树的深度, 假设用<code>depth(root)</code> 表示, 那么再嵌套一个递归:</p>
<p><code>isBalance(root):</code></p>
<ol>
<li><p>*<em>特例处理: *</em> 如果<code>root == null</code> , 直接返回<code>true</code> ;</p>
</li>
<li><p>*<em>递归过程: *</em> 判断三个内容:</p>
<ol>
<li>当前左右子树的差值是否小于等于1: <code>Math.abs(depth(root.left) - depth(root.right)) &lt;= 1</code></li>
<li>左子树是否为平衡树:  <code>isBalance(root.left)</code></li>
<li>右子树是否为平衡树: <code>isBalance(root.right)</code></li>
</ol>
</li>
<li><p>*<em>返回值: *</em> 将递归过程求出的三个内容用 <code>&amp;&amp;</code> 连接起来, 返回值类型为 <code>boolean</code></p>
</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/8464f2bae6181353f9960c9ada3f060672a7b309dd313155526efba0d3a8b38d-Picture12.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/997c6c77469be3c3cfada7d89a45cf56634742ee86140a7f0c970d8cd335cafe-Picture13.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/23fc976dcc45a11c7c2398da3d5c4bc49768f0fb6a8eacb14837f1e48bb16897-Picture14.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/36272beee5f24ed421e0267f39408c7304862e73a5e40737090226da24e93300-Picture15.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/f7b74ef888f602cd1215e8ebb04a3638e8a9566ce9b76a945e3f45e2f101a367-Picture16.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/06490aa3308753df2554cf86efccf70345394200fe98c2cf01b2451faee18d4b-Picture17.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="后序遍历-剪枝-从底至顶"><a href="#后序遍历-剪枝-从底至顶" class="headerlink" title="后序遍历 + 剪枝(从底至顶)"></a>后序遍历 + 剪枝(从底至顶)</h2><p>思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</p>
<p><strong>算法流程：</strong></p>
<p><strong><code>recur(root)</code> 函数：</strong></p>
<ul>
<li><p><strong>返回值：</strong></p>
<ol>
<li>当节点root 左 / 右子树的深度差 ≤1 ：则返回当前子树的深度，即节点 root 的左 / 右子树的深度最大值 +1 （ max(left, right) + 1 ）；</li>
<li>当节点root 左 / 右子树的深度差 &gt; 2：则返回 -1, 代表 <strong>此子树不是平衡树</strong> </li>
</ol>
</li>
<li><p><strong>终止条件：</strong></p>
<ol>
<li>当 <code>root</code> 为空：说明越过叶节点，因此返回高度 0；</li>
<li>当左（右）子树深度为 -1：代表此树的 <strong>左（右）子树</strong> 不是平衡树，因此剪枝，直接返回 -1 ；</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">recur</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = recur(root.left);</span><br><span class="line">    <span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = recur(root.right);</span><br><span class="line">    <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left, right) : -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz68-Ⅱ.二叉树的最近公共祖先</title>
    <url>/2020/07/12/jz68-%E2%85%A1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/binarytree.png" alt=""></p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="后序遍历DFS"><a href="#后序遍历DFS" class="headerlink" title="后序遍历DFS"></a>后序遍历DFS</h2><p><strong>祖先的定义：</strong> 若节点 p 在节点 root的左（右）子树中，或 p = root，则称 root是 p的祖先。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/83402bb4c1bba2746effc5607d9654aeb9c3496b4a846d41ce61adb5af02c0f5-Picture1.png" alt=""></p>
<p><strong>最近公共祖先的定义：</strong> 设节点 root为节点 p,q的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。</p>
<p>根据以上定义，若 root 是 p,q的 最近公共祖先 ，则只可能为以下情况之一：</p>
<ol>
<li>p 和 q 在 root 的子树中，且分列 root的 异侧（即分别在左、右子树中）；</li>
<li>p = root，且 q 在 root 的左或右子树中；</li>
<li>q = root，且 pp 在 root 的左或右子树中；</li>
</ol>
<hr>
<p>这道题与上道题的区别或者说拓展点在于, 上道题是二叉搜索树, 可以根据值的大小进行判断在左子树还是右子树中, 但是二叉树没有大小的要求, 所以只能遍历到具体的节点, 然后根据位置判断在哪个子树中.</p>
<p>我们采用后序遍历的方法, 一旦遍历到目标节点, 就层层向上返回.</p>
<ul>
<li>若左子树递归返回一个节点, 右子树返回一个节点, 说明左右子树中各发现了一个目标节点, 那么当前节点就是最近的公共祖先节点</li>
<li>若左子树递归返回了一个节点, 右子树返回<code>null</code>, 那就继续上交左子树返回的节点, 左子树返回的这个节点有两种可能:<ul>
<li>可能是两个目标节都在左子树中找到了, 这个节点就是他们的公共祖先节点</li>
<li>可能是只找到了一个目标节点, 那么这个节点就是目标节点, 需要在上传的某一层中与另外的一个目标节点汇合</li>
</ul>
</li>
<li>若右子树递归返回了一个节点, 左子树返回<code>null</code>, 情况类比左子树的情况即可, 完全对称</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>||root.val==p.val||root.val == q.val)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="keyword">null</span> )</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>lombok使用</title>
    <url>/2020/07/22/lombok%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol>
<li><p>在IDEA的插件中搜索并安装Lombok插件</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200722142336.png" alt=""></p>
</li>
<li><p>导入同名的jar包</p>
</li>
<li><p>提供的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span> and <span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@FieldNameConstants</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span>, <span class="meta">@RequiredArgsConstructor</span> and <span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Log</span>, <span class="meta">@Log</span>4j, <span class="meta">@Log</span>4j2, <span class="meta">@Slf</span>4j, <span class="meta">@XSlf</span>4j, <span class="meta">@CommonsLog</span>, <span class="meta">@JBossLog</span>, <span class="meta">@Flogger</span>, <span class="meta">@CustomLog</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@Singular</span></span><br><span class="line"><span class="meta">@Delegate</span></span><br><span class="line"><span class="meta">@Value</span></span><br><span class="line"><span class="meta">@Accessors</span></span><br><span class="line"><span class="meta">@Wither</span></span><br><span class="line"><span class="meta">@With</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@val</span></span><br><span class="line"><span class="meta">@var</span></span><br><span class="line">experimental <span class="meta">@var</span></span><br><span class="line"><span class="meta">@UtilityClass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在User类中, 把之前写的各种方法都删去,然后写上@Data注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后查看该类的结构, 发现自动生成了很多方法:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200722143804.png" alt=""></p>
<p>但注意这里之后无参构造器, 如果需要有参构造器, 用@AllArgsConstructor注解, 但是无参构造又没了, 所以这三个注解一起使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br></pre></td></tr></table></figure>

<p>如果嫌多, 就用单个的注释写在相应的位置即可</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的前中后序遍历</title>
    <url>/2020/07/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>汇总二叉树的前, 中, 后序遍历.每种遍历都有经典的递归和迭代方法.</p>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left, res);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p><img src="http://qcxz71s06.bkt.clouddn.com/f1c189e18ab21142095be343b507a206_3.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    TreeNode curNode = root;</span><br><span class="line">    stack.push(curNode);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        curNode = stack.pop();</span><br><span class="line">        res.add(curNode.val);</span><br><span class="line">        <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(curNode.right);</span><br><span class="line">        <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(curNode.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归方法-1"><a href="#递归方法-1" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.left, res);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.right, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代方法-1"><a href="#迭代方法-1" class="headerlink" title="迭代方法"></a>迭代方法</h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="http://qcxz71s06.bkt.clouddn.com/f6e4510b7c3446075698d9fd10595f2d.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/55fc6e5a3a213807d281b9ed360e89f0.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/f9d089302bcccba69e83adf17ce98382.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/350a01b043f194dc409076b65bbbbb61.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/c1f7b568c46ace2815d7653b1a47e092.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3fb26798163cecf6ed46ae823256809e.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/b564b85e0e54727ab791d94f63834209.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/9b3541ab2cefb2a16efe0929a2f173c3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/6995c79bfc19b0fc7bdb6af3a2ede56d.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/27ae5a883182fbf7ed00897de3348f64.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/88de3e29515e65b31b1f6c776587163a.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/636fb34cd17e20b998b4e78c95a32066.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/14056baa203348c036a36cb2eddd217c.png" alt=""></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归方法-2"><a href="#递归方法-2" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left, res);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代方法-2"><a href="#迭代方法-2" class="headerlink" title="迭代方法"></a>迭代方法</h3><ol>
<li>前序遍历的过程是<code>中左右</code>。 <ul>
<li>将其转化成<code>中右左</code>。也就是压栈的过程中优先压入左子树，再压入右子树。</li>
</ul>
</li>
<li>然后将这个结果反过来，用<code>addFirst()</code>方法将元素输出到数组即可完成逆序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    stack.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode curNode = stack.pop();</span><br><span class="line">        res.addFirst(curNode.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(curNode.left);</span><br><span class="line">        <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(curNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>解决IDEA中languageLevel和javac版本重置问题</title>
    <url>/2020/07/22/%E8%A7%A3%E5%86%B3IDEA%E4%B8%ADlanguageLevel%E5%92%8Cjavac%E7%89%88%E6%9C%AC%E9%87%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用Maven的时候, 每次新建一个项目, 或者刷新一下porm.xml文件, 就会使得每个项目的Language Level和解释器版本重置回1.5. 每次都要设置回来, 很烦</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200722154210.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200722154223.png" alt=""></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>在porm.xml文件中添加以下代码:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">source</span>&gt;</span>13<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span>&gt;</span>13<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后就没有重置问题了</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>团灭四道搜索旋转排序数组题</title>
    <url>/2020/07/07/%E5%9B%A2%E7%81%AD%E5%9B%9B%E9%81%93%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在刷关于二分查找的算法题目时, 有一块内容是绕不过去的, 那就是旋转排序数组的题目. </p>
<p>我们知道, 在查找排序数组时往往采用二分查找的方法, 但是旋转排序数组只保留了区域性的排序, 这就让人比较头疼.通常的二分查找题目有两类, 一类是目标值查找, 即从数组中查找目标值, 返回其下标; 另一类考察的是边界, 这类题目更加灵活, 可能会考察第K大的数, 第一个重复出现的数等等.</p>
<p>结合了旋转数组之后, 就有了四道非常典型的题目, 他们是:</p>
<ul>
<li>LeetCode 33: <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></li>
<li>LeetCode 81: <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">搜索旋转排序数组 Ⅱ</a></li>
<li>LeetCode 153: <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></li>
<li>LeetCode 154: <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值 Ⅱ</a></li>
</ul>
<p>总体而言分别考察了目标值和最小值, 只是按是否存在重复的数又各拓展出一道题. 下面分别来解决.</p>
<hr>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>首先，<code>mid</code>将数组分成前后两段：</p>
<p>如果<code>nums[start]&lt;=nums[mid]</code>，则说明前半段是<strong>递增</strong>的</p>
<ul>
<li><p>如果<code>nums*[*start*]* &lt;= target &amp;&amp; target &lt; nums*[*mid*]</code>,目标值在前半段，使<code>end=mid-1</code>*</p>
</li>
<li><p>否则，目标值在后半段，使<code>start=mid+1</code>*</p>
</li>
</ul>
<p>否则，说明后半段是<strong>递增</strong>的</p>
<ul>
<li><p>如果<code>nums[mid] &lt; target &amp;&amp; target &lt;= nums[end]</code>,目标值在后半段，使<code>start=mid+1</code></p>
</li>
<li><p>否则，目标值在前半段，使<code>end=mid-1</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) &#123;</span><br><span class="line">                <span class="comment">// 说明数组在[0, mid]区间上是递增的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    <span class="comment">// 说明target在[left, mid-1]区间内</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 说明target在[mid+1, right]区间内</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明数组在[mid, right]区间上是递增的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                    <span class="comment">// 说明target在区间[mid+1, right]内</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 说明target在区间[left, mid-1]内</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="81-搜索旋转排序数组-Ⅱ"><a href="#81-搜索旋转排序数组-Ⅱ" class="headerlink" title="81: 搜索旋转排序数组 Ⅱ"></a>81: 搜索旋转排序数组 Ⅱ</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h4><p>因为存在重复的元素, 因此在33题中判断前后段升降时遇到了特殊情况. 在33题中是通过<code>nums[mid] &gt;= nums[left]</code> 来判断前半段是否为增, 若存在重复元素, 则无法通过该方法判断例如 <code>10111</code> 的数组. 有两种判断方法:</p>
<ol>
<li>出现这种情况时<code>nums[left]</code> 和<code>nums[right]</code> 一定是相等的.<code>left++</code> 即可</li>
<li>将原来的判断条件分开来处理, 当<code>nums[mid] &gt; nums[left]</code>时, 还按33题的方法去做, 添加一个<code>nums[mid] = nums[left]</code>的处理方法: 也是<code>left++</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] == nums[mid]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="153-搜索旋转排序数组中的最小值"><a href="#153-搜索旋转排序数组中的最小值" class="headerlink" title="153.搜索旋转排序数组中的最小值"></a>153.搜索旋转排序数组中的最小值</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找-2"><a href="#二分查找-2" class="headerlink" title="二分查找"></a>二分查找</h4><p>因为不存在重复的数字, 所以只需要考虑大于和等于的情况, 比较对象为<code>nums[right]</code></p>
<ol>
<li><p>循环二分： 设置 <code>i</code>,<code>j</code> 指针分别指向<code>numbers</code> 数组左右两端，<code>m = (i + j) / 2</code> 为每次二分的中点（ “/“ 代表向下取整除法），可分为以下三种情况：</p>
<ol>
<li><p>当<code>numbers[m] &gt; numbers[j]</code>时： <code>m</code> 一定在 左排序数组 中，即旋转点 <code>x</code>一定在<code>[m + 1, j]</code>闭区间内，因此执行<code>i = m + 1</code>；</p>
</li>
<li><p>当 <code>numbers[m] &lt; numbers[j]</code>时： <code>m</code> 一定在 右排序数组 中，即旋转点 <code>x</code> 一定在<code>[i, m]</code> 闭区间内，因此执行<code>j = m</code>；</p>
</li>
</ol>
</li>
<li><p>返回值： 当<code>i = j</code>时跳出二分循环，并返回 <code>numbers[i]</code>即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="154-搜索旋转排序数组中的最小值-Ⅱ"><a href="#154-搜索旋转排序数组中的最小值-Ⅱ" class="headerlink" title="154.搜索旋转排序数组中的最小值 Ⅱ"></a>154.搜索旋转排序数组中的最小值 Ⅱ</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>注意数组中可能存在重复的元素。</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找-3"><a href="#二分查找-3" class="headerlink" title="二分查找"></a>二分查找</h4><p>这道题与153题有着高度的相似,  依然是将<code>nums[mid]</code>与<code>nums[right]</code>相比较, 不过是多考虑一个等于的情况, 采取的措施是<code>right--</code>. </p>
<p>如下图所示，寻找旋转数组的最小元素即为寻找 右排序数组 的首个元素 <code>numbers[x]</code> ，称 <code>x</code> 为 旋转点</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/e4c293fbc50538a0af581f455a2d8ce4_2.png" alt=""></p>
<ol>
<li><p>循环二分： 设置 <code>i</code>,<code>j</code> 指针分别指向<code>numbers</code> 数组左右两端，<code>m = (i + j) / 2</code> 为每次二分的中点（ “/“ 代表向下取整除法），可分为以下三种情况：</p>
<ol>
<li><p>当<code>numbers[m] &gt; numbers[j]</code>时： <code>m</code> 一定在 左排序数组 中，即旋转点 <code>x</code>一定在<code>[m + 1, j]</code>闭区间内，因此执行<code>i = m + 1</code>；</p>
</li>
<li><p>当 <code>numbers[m] &lt; numbers[j]</code>时： <code>m</code> 一定在 右排序数组 中，即旋转点 <code>x</code> 一定在<code>[i, m]</code> 闭区间内，因此执行<code>j = m</code>；</p>
</li>
<li><p>当 <code>numbers[m] == numbers[j]</code>时： 无法判断 <code>m</code> 在哪个排序数组中，即无法判断旋转点<code>x</code> 在 <code>[i, m]</code> 还是 <code>[m + 1, j]</code> 区间中。解决方案： 执行<code>j = j - 1</code> 缩小判断范围.</p>
</li>
</ol>
</li>
<li><p>返回值： 当<code>i = j</code>时跳出二分循环，并返回 <code>numbers[i]</code>即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) j = m;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较来看<strong>153题</strong>的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>旋转排序数组</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2020/07/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 多线程的内容很重要, 第一遍没学好, 重新梳理总结一下. 把基础内容总结好之后, 会学习JUC并发编程的相关知识, 会一直总结学习下去. 这块内容我还是想深入学习的, 不只是记一些概念性的知识.</p>
<hr>
<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h3><p>多线程简化理解为, 一条路上交通很拥挤, 通过开辟多个车道分流, 解决拥堵问题.</p>
<p>单线程调用方法和多线程的区别:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708130847.png" alt=""></p>
<p>很明显左边的效率低, 右边开辟新线程, 各走各的, 效率高.</p>
<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>在操作系统中运行的程序就是进程, 比如QQ, 播放器, 游戏等</p>
<p>一个进程可以有多个线程, 如视频中同时听到声音, 看到图像, 看弹幕等等</p>
<p>需要注意的是, <strong>程序</strong>是指令和数据的有序集合, 是一个静态的概念, 执行程序的一次执行过程叫做<strong>进程</strong>, 这才是动态的概念</p>
<p>通常在一个进程中可以包含若干个线程, 线程是CPU调度和执行的单位</p>
<p><strong>核心概念:</strong></p>
<ul>
<li>在程序执行时, 即使没有创建线程, 后台也会有多个线程, 如主线程, gc线程;</li>
<li>main()称之为主线程, 为系统的入口, 用于执行整个程序</li>
<li>对同一份资源操作时, 会存在资源抢夺的问题, 需要加入并发控制</li>
<li>线程会带来额外的开销, 如CPU调度时间, 并发控制开销</li>
</ul>
<hr>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><h3 id="三种创建方式"><a href="#三种创建方式" class="headerlink" title="三种创建方式"></a>三种创建方式</h3><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708232259.png" alt=""></p>
<h4 id="Thread方式"><a href="#Thread方式" class="headerlink" title="Thread方式"></a>Thread方式</h4><p><code>Thread</code>类实现了<code>Runnable</code>接口</p>
<ol>
<li>自定义线程类继承<code>Thread</code> 类</li>
<li>重写<code>run()</code> 方法, 编写线程执行体</li>
<li>创建线程对象, 调用<code>start()</code> 方法启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run 方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在看代码----"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main线程, 主线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程对象</span></span><br><span class="line">        TestThread testThread1 = <span class="keyword">new</span> TestThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start()方法开启线程</span></span><br><span class="line">        testThread1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在学习多线程-----"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708233832.png"  />

<p>可以看到自定义线程和主线程的输出结果交错显示.</p>
<p>线程不一定立即执行, 由CPU安排调度. 这里如果把<code>start()</code> 方法替换成<code>run()</code> 的话, 就按顺序执行了.</p>
<p>下面写一个从网络同时下载三张图片, 再熟悉一下多线程的使用, 这里因为要处理IO流, 所以导入了<code>commons-io</code> 包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">// 网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread2</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebDownLoader webDownLoader = <span class="keyword">new</span> WebDownLoader();</span><br><span class="line">        webDownLoader.downloader(url, name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件名为: "</span>+ name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread2 t1 = <span class="keyword">new</span> TestThread2(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708232259.png"</span>, <span class="string">"1.png"</span></span><br><span class="line">                );</span><br><span class="line">        TestThread2 t2 = <span class="keyword">new</span> TestThread2(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708130847.png"</span>, <span class="string">"2.png"</span></span><br><span class="line">                );</span><br><span class="line">        TestThread2 t3 = <span class="keyword">new</span> TestThread2(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/46a8eb9c7e647c684c0b92d098727b9b.png"</span>, <span class="string">"3.png"</span></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url), <span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"IO异常, downloader方法出现问题"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来分析一下这段代码, 将下载和存储的功能单独做成一个下载器的类, 这个是主要功能代码, 我们根据创建线程的流程可以知道待会要在重写的<code>run()</code> 方法中调用.</p>
<p>然后来按照流程创建自定义线程类, 要点是继承<code>Thread</code> 类, 重写<code>run()</code> 方法, 然后将功能代码写进<code>run()</code> 方法中. </p>
<p>在主线程中创建三个自定义线程对象, 他们各自负责下载一张图片, 然后使用<code>start()</code> 方法, 输出的结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载了文件名为: 2.png</span><br><span class="line">下载了文件名为: 3.png</span><br><span class="line">下载了文件名为: 1.png</span><br></pre></td></tr></table></figure>

<p>可以看出多线程的效果.</p>
<h4 id="Runnable方法"><a href="#Runnable方法" class="headerlink" title="Runnable方法"></a>Runnable方法</h4><ol>
<li>实现MyRunnable类实现Runnable接口</li>
<li>实现<code>run()</code> 方法, 编写线程执行体</li>
<li>创建线程对象, 调用<code>start()</code> 方法启动线程</li>
</ol>
<blockquote>
<p><strong>避免单继承局限性, 灵活方便, 方便同一个对象被多个线程使用</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run 方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在看代码----"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main线程, 主线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程对象</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 创建线程对象, 通过线程对象来开启我们的线程, 这是个代理</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(testThread3);</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 简写方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testThread3).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在学习多线程-----"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果与<code>Thread方法</code> 类似, 不再贴出, 需要注意的是, 在使用<code>start()</code> 方法开启新的线程时通过一个<code>Thread</code> 类的对象调用, 它被称为自定义线程的<strong>静态代理</strong>.</p>
<p>用实现<code>Runnable</code>接口的方法改写下载网络图片的示例, 只需要改动自定义线程类的名称以及调用方法即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(t1).start();</span><br><span class="line"><span class="keyword">new</span> Thread(t2).start();</span><br><span class="line"><span class="keyword">new</span> Thread(t3).start();</span><br></pre></td></tr></table></figure>

<h5 id="龟兔赛跑小例子"><a href="#龟兔赛跑小例子" class="headerlink" title="龟兔赛跑小例子"></a>龟兔赛跑小例子</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟龟兔赛跑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lxb0124</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-09 13:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Race</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 胜利者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String winner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟兔子休息</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"兔子"</span>) &amp;&amp; i % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断比赛是否结束</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = gameOver(i);</span><br><span class="line">            <span class="comment">// 如果比赛结束, 停止程序</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" ---&gt; 跑了 "</span> + i + <span class="string">" 步"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否完成比赛</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">gameOver</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否有胜利者</span></span><br><span class="line">        <span class="keyword">if</span> (winner != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (steps &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                winner = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(<span class="string">"winner is "</span> + winner + <span class="string">" !"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Race race = <span class="keyword">new</span> Race();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(race, <span class="string">"兔子"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(race, <span class="string">"乌龟"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Callable方法-了解即可"><a href="#Callable方法-了解即可" class="headerlink" title="Callable方法(了解即可)"></a>Callable方法(了解即可)</h4><ol>
<li><p>实现<code>Callable</code> 接口, 需要返回值类型</p>
</li>
<li><p>重写<code>call</code> 方法, 需要抛出异常</p>
</li>
<li><p>创建目标对象</p>
</li>
<li><p>创建执行服务:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService ser = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交执行:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Boolean&gt; result1 = ser.submit(t1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> r1 = result.get();</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭服务:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ser.shutdownNow;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>改写下载网络图片案例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">// 网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebDownLoader webDownLoader = <span class="keyword">new</span> WebDownLoader();</span><br><span class="line">        webDownLoader.downloader(url, name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件名为: "</span>+ name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable t1 = <span class="keyword">new</span> TestCallable(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708232259.png"</span>, <span class="string">"1.png"</span></span><br><span class="line">        );</span><br><span class="line">        TestCallable t2 = <span class="keyword">new</span> TestCallable(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708130847.png"</span>, <span class="string">"2.png"</span></span><br><span class="line">        );</span><br><span class="line">        TestCallable t3 = <span class="keyword">new</span> TestCallable(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/46a8eb9c7e647c684c0b92d098727b9b.png"</span>, <span class="string">"3.png"</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行服务:</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; r1 = ser.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; r2 = ser.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; r3 = ser.submit(t3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        Boolean rs1 = r1.get();</span><br><span class="line">        Boolean rs2 = r2.get();</span><br><span class="line">        Boolean rs3 = r3.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        ser.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>callable的好处</strong></p>
<ol>
<li>可以定义返回值</li>
<li>可以抛出异常</li>
</ol>
<h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p>多个线程同时操作同一个对象</p>
<p>以买火车票为例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNums&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟延时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 拿到了第"</span> + ticketNums-- + <span class="string">" 票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread4 ticket = <span class="keyword">new</span> TestThread4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(ticket, <span class="string">"小明"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket, <span class="string">"老师"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket, <span class="string">"黄牛"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析这段代码的功能, 首先是在自定义线程里设置了共享的资源, 然后开启三个线程对这个资源进行操作. 这里可能会有疑问: 为什么三个线程会对同一个资源进行操作呢? 这要注意我们只创建了一个自定义线程的对象<code>ticket</code> , 然后开启了三次也就是申请了三个代理, 所以只有一个共享资源. </p>
<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200709130233.png" alt=""></p>
<p>我们发现了问题: 拿第10张票来说, 三个线程都对其进行了操作, 这就出现了并发的问题.多个线程操作同一个资源的情况下, 线程不安全, 数据紊乱.</p>
<p>为什么龟兔赛跑的例子中没有出现并发问题呢? 这是因为龟兔赛跑中创建的<code>race</code> 对象模拟的是一个赛道, 在整个循环的框架中让线程进来, 所以不会存在冲突的问题.</p>
<hr>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ol>
<li><p>真实对象和代理对象都要实现同一个接口</p>
</li>
<li><p>代理对象要代理真实角色</p>
</li>
</ol>
<p>这样做的好处是:</p>
<ol>
<li>代理对象可以做很多真实对象做不了的事情</li>
<li>真实对象专注做自己的事情</li>
</ol>
<p>下面通过代码深刻了解这一过程:</p>
<p>我们模拟婚庆公司代理举行婚礼的过程</p>
<p>首先创建一个<code>Marry</code>接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个真实对象的类<code>You</code>, 这个是真正要结婚的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真实角色, 你去结婚</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xxx要结婚了, 超开心"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义婚庆公司的类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理角色, 帮助你去结婚</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Marry target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="keyword">this</span>.target.HappyMarry();</span><br><span class="line">        afer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"结婚之前布置现场"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"结婚之后收尾款"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这两段代码的对比可以看到, 它们都重写的<code>HappyMarry()</code> 方法, 如果不用婚庆公司的话, 只能实现结婚这一个动作, 使用了代理之后, 不仅原来的功能可以实现(因为传入了<code>You</code>对象), 还可以添加额外的功能.</p>
<p>如果没有用到代理的话, 我们是这样调用的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        You you = <span class="keyword">new</span> You();</span><br><span class="line">        you.HappyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxx要结婚了, 超开心</span><br></pre></td></tr></table></figure>

<p>使用代理之后的话:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeddingCompany weddingCompany = <span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You());</span><br><span class="line">        weddingCompany.HappyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结婚之前布置现场</span><br><span class="line">xxx要结婚了, 超开心</span><br><span class="line">结婚之后收尾款</span><br></pre></td></tr></table></figure>

<p>由婚庆公司的例子可以类比到线程的创建过程, 我们发现线程的创建过程也用到了静态代理的思想</p>
<p>我们将上面创建婚庆公司的对象代码简化一下, 并和线程创建代码写在一起对比:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You()).HappyMarry();</span><br><span class="line">   <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">"我爱多线程!"</span>)).start();</span><br></pre></td></tr></table></figure>

<p>这里<code>WeddingCompany</code> 和<code>Thread</code> 都是静态代理, 需要传入真实对象, 婚庆公司和<code>You</code> 都实现了<code>Marry</code> 接口; <code>Thread</code> 和 自定义线程类都实现了<code>Runnable</code> 接口.</p>
<p>然后最后调用的方法都是代理类中定义的方法.</p>
<hr>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>*<em>定义: *</em> 任何接口, 如果只包含唯一一个抽象方法, 那么它就是函数式接口. 例如现在经常接触的<code>Runnable</code> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于函数式接口, 我们可以通过 Lambda 表达式来创建该接口的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ILike like = <span class="keyword">new</span> Like();</span><br><span class="line">        like.lambda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Like</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"i like lambda."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个函数式接口的例子, 先用常规方法调用<code>lambda()</code> 函数</p>
<p>利用<strong>静态内部类</strong>的方式进行代码优化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"i like lambda2."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Like2 like = <span class="keyword">new</span> Like2();</span><br><span class="line">        like.lambda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<strong>局部内部类</strong>的方式进行代码优化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"i like lambda2."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Like3 like3 = <span class="keyword">new</span> Like3();</span><br><span class="line">    like3.lambda();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<strong>匿名内部类</strong>进行简化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名内部类, 没有类的名称, 必须借助接口或父类</span></span><br><span class="line">    ILike like4 = <span class="keyword">new</span> ILike() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"i like lambda4."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    like4.lambda();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终, 利用<strong>Lambda表达式</strong>再进行简化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda表达式</span></span><br><span class="line">    ILike like5 = ()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">"i like lambda5."</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    like5.lambda();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要使用<code>Lambda</code> 表达式:</p>
<ul>
<li>避免匿名内部类定义过多</li>
<li>简化代码</li>
<li>去掉了一堆没有意义的代码, 只留下核心的逻辑</li>
</ul>
<h3 id="带参数的Lambda表达式"><a href="#带参数的Lambda表达式" class="headerlink" title="带参数的Lambda表达式"></a>带参数的Lambda表达式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Ilove ilove = (<span class="keyword">int</span> a)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">"i love you ---&gt;"</span> + a);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ilove.love(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Ilove</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">love</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步简化, 将参数类型和括号都简化掉:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Ilove ilove = a -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"i love you ---&gt;"</span> + a);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ilove.love(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将花括号都给去掉:</p>
<p>去掉花括号的原因是重写的方法里只有一行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Ilove ilove = a -&gt; System.out.println(<span class="string">"i love you ---&gt;"</span> + a);</span><br><span class="line"></span><br><span class="line">    ilove.love(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>lambda表达式只能有一行代码的情况下才能简化成一行, 如果有多行, 那么就用代码块包裹</li>
<li>能写成lambda表达式的前提是为函数式接口</li>
<li>多个参数也可以去掉参数类型, 要去掉就全都去掉, 但是必须加括号</li>
</ul>
<hr>
<h2 id="线程的五大状态"><a href="#线程的五大状态" class="headerlink" title="线程的五大状态"></a>线程的五大状态</h2><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200710122350.png" alt=""></p>
<p>一些常见的线程方法:</p>
<ul>
<li><strong><em>setPriority(int newPriority):</em></strong> 更改线程的优先级</li>
<li><strong><em>static void sleep(long millis):</em></strong> 在指定的毫秒数内让当前正在执行的线程休眠</li>
<li><strong><em>void join():</em></strong> 等待该线程终止</li>
<li><strong><em>static void yield():</em></strong> 暂停当前正在执行的线程对象, 并执行其他线程</li>
<li><strong><em>void interrupt():</em></strong> 中断线程, 别用这种方式</li>
<li><strong><em>boolean isAlive():</em></strong> 测试线程是否处于活动状态</li>
</ul>
<h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><p>不推荐使用JDK提供的<code>stop()</code>, <code>destroy()</code> 方法. 推荐线程自己停止下来, 可以使用一个标志位进行终止变量当 flag = false, 则终止线程运行.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试stop</span></span><br><span class="line"><span class="comment"> * 1. 建议线程正常停止, 利用次数, 不建议死循环</span></span><br><span class="line"><span class="comment"> * 2. 建议使用标志位</span></span><br><span class="line"><span class="comment"> * 3. 不要使用stop 或者destroyed方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lxb0124</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-10 12:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置一个标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">"run ... Thread "</span> + i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一个公开的方法停止线程, 转换标志位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TestStop testStop = <span class="keyword">new</span> TestStop();</span><br><span class="line">        <span class="keyword">new</span> Thread(testStop).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">900</span>)&#123;</span><br><span class="line">                <span class="comment">// 调用stop方法, 让线程停止</span></span><br><span class="line">                testStop.stop();</span><br><span class="line">                System.out.println(<span class="string">"该线程停止了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析这段代码, 在主线程中开启了自定义线程, 两个线程同时运行, 各自计数, 当主线程记到900时, 将自定义的线程停掉, 结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200710125803.png" alt=""></p>
<h3 id="线程休眠-sleep"><a href="#线程休眠-sleep" class="headerlink" title="线程休眠: sleep"></a>线程休眠: sleep</h3><ul>
<li>sleep(时间) 指定当前线程阻塞的毫秒数</li>
<li>sleep存在异常InterruptedException;</li>
<li>sleep时间达到后线程进入就绪状态</li>
<li>sleep看可以模拟网络延时, 倒计时等</li>
<li><strong>每个对象都有一个锁, sleep不会释放锁</strong></li>
</ul>
<p>之前写的三个人抢火车票的代码就应用了网络延时, 可以放大问题的发生性. 下面写一个倒计时的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印当前系统时间</span></span><br><span class="line">    Date startTime = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(startTime));</span><br><span class="line">            startTime = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程礼让-yield"><a href="#线程礼让-yield" class="headerlink" title="线程礼让: yield"></a>线程礼让: yield</h3><ul>
<li>礼让线程, 让当前正在执行的线程暂停, 但不阻塞</li>
<li>将线程从运行状态转为就绪状态</li>
<li><strong>让CPU重新调度, 礼让不一定成功, 看CPU心情!!</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyYield myYield = <span class="keyword">new</span> MyYield();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield, <span class="string">"a"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield, <span class="string">"b"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 线程开始执行"</span>);</span><br><span class="line">        Thread.yield();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 线程停止执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程强制执行-join"><a href="#线程强制执行-join" class="headerlink" title="线程强制执行: join"></a>线程强制执行: join</h3><ul>
<li>Join合并线程, 待此线程执行完成后, 再执行其他线程, 其他线程阻塞</li>
<li>可以想象成插队</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程vip来了 "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestJoin testJoin = <span class="keyword">new</span> TestJoin();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(testJoin);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">50</span>)&#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"main "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚开始自定义线程和主线程同时执行, 当主线程计数到50时, 自定义线程强行执行, 直到该线程执行结束主线程再继续执行. 输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200710134632.png" alt=""></p>
<h3 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h3><p>通过<code>Thread.State</code> 可以查看线程的状态:</p>
<ul>
<li>NEW: 尚未启动的线程处于此状态</li>
<li>RUNNABLE: 在Java虚拟机中执行的线程处于此状态</li>
<li>BLOCKED: 被阻塞等待监视器锁定的线程处于此状态</li>
<li>WAITING: 正在等待另一个线程执行特定动作的线程处于此状态</li>
<li>TERMINATED: 已退出的线程处于此状态</li>
</ul>
<p>一个线程可以在给定时间点处于一个状态, 这些状态是不反映任何操作系统线程状态的虚拟机状态.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"////////"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 观测状态</span></span><br><span class="line">        Thread.State state = thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 观察启动后</span></span><br><span class="line">        thread.start();</span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (state != Thread.State.TERMINATED) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                state = thread.getState();</span><br><span class="line">                System.out.println(state);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析这段代码, 自定义线程的<code>run()</code> 编写了一个5秒的倒计时, 然后观测这个线程整个过程中的状态. 首先是启动前应该是<code>NEW</code>, 启动了瞬间应该为<code>RUNNABLE</code>, 进入倒计时后应该为<code>TIMED_WAITING</code>, <code>run()</code> 方法跑完之后应该为<code>TERMINATED</code>.</p>
<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NEW</span><br><span class="line">RUNNABLE</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">TERMINATED</span><br></pre></td></tr></table></figure>

<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程, 线程调度器按照优先级决定应该调度哪个线程来执行.</p>
<p>线程的优先级用数字表示, 范围从1-10:</p>
<ul>
<li>Thread.MIN_PRIORITY = 1;</li>
<li>Thread.MAX_PRIORITY = 10;</li>
<li>Thread.NORM_PRIORITY = 5;</li>
</ul>
<p>使用以下方式改变或获取优先级:</p>
<ul>
<li>getPriority</li>
<li>setPriority(int xxx)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPriority</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程默认优先级</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" --&gt; "</span> + Thread.currentThread().getPriority());</span><br><span class="line"></span><br><span class="line">        MyPriority myPriority = <span class="keyword">new</span> MyPriority();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        t2.setPriority(<span class="number">1</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t3.setPriority(<span class="number">4</span>);</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        t4.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">        t5.setPriority(<span class="number">8</span>);</span><br><span class="line">        t5.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPriority</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" --&gt; "</span> +Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main --&gt; 5</span><br><span class="line">Thread-3 --&gt; 10</span><br><span class="line">Thread-4 --&gt; 8</span><br><span class="line">Thread-2 --&gt; 4</span><br><span class="line">Thread-0 --&gt; 5</span><br><span class="line">Thread-1 --&gt; 1</span><br></pre></td></tr></table></figure>

<p>需要注意的是, 优先级低只是意味着获得调度的概率低, 并不是优先级低就不会被调用了, 都是看CPU的调度.</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>线程分为用户线程和守护线程, 虚拟机必须确保用户线程执行完毕, 而不用等待守护线程执行完毕, 如后台记录操作日志, 监控内存, 垃圾回收等待…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaemon</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        Youa youa =  <span class="keyword">new</span> Youa();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);     <span class="comment">// 默认是false表示用户线程, 正常的线程都是用户线程</span></span><br><span class="line"></span><br><span class="line">        thread.start(); <span class="comment">// 上帝守护线程启动</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(youa).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上帝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"上帝永远保佑着你"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Youa</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">36500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"你一生都开心的活着"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"======goodbye!world!======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200710175623.png" alt=""></p>
<hr>
<h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><p>线程同步问题发生在多个线程操作同一个资源时.</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>同一个对象被多个线程同时操作. 处理多线程问题时, 多个线程访问同一个对象, 并且某些线程还想修改这个对象, 这时候我们就需要线程同步. 线程同步其实就是一种等待机制, 多个需要同时访问此对象的线程进入这个对象的等待池形成队列, 等待前面线程使用完毕, 下一个线程再使用.</p>
<h3 id="队列-和-锁"><a href="#队列-和-锁" class="headerlink" title="队列 和 锁"></a>队列 和 锁</h3><p>队列是对线程而言, 是一种排队的机制, 但是只有队列也不行, 还需要资源对象保证安全, 这就是锁 .  队列 + 锁才能保证线程的安全性.</p>
<p>由于同一进程的多个线程共享同一块存储空间, 在带来方便的同时, 也带来了访问冲突问题, 为了保证数据在方法中被访问时的正确性, 在访问时加入<strong>锁机制 synchronized</strong>, 当一个线程获得对象的排他锁, 独占资源, 其他线程必须等待, 使用后释放锁即可, 存在以下问题:</p>
<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起.</li>
<li>在多线程竞争下, 加锁, 释放锁会导致比较多的上下文切换和调度延时, 引起性能问题</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁, 会导致优先级倒置, 引起性能问题.</li>
</ul>
<h3 id="三大不安全案例"><a href="#三大不安全案例" class="headerlink" title="三大不安全案例"></a>三大不安全案例</h3><p>先来分析抢票的过程:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBuyTicket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyTicket station = <span class="keyword">new</span> BuyTicket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(station, <span class="string">"我"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(station, <span class="string">"你"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(station, <span class="string">"黄牛"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            buy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 拿到了 "</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我 拿到了 10</span><br><span class="line">你 拿到了 8</span><br><span class="line">黄牛 拿到了 9</span><br><span class="line">我 拿到了 7</span><br><span class="line">你 拿到了 6</span><br><span class="line">黄牛 拿到了 5</span><br><span class="line">我 拿到了 4</span><br><span class="line">你 拿到了 3</span><br><span class="line">黄牛 拿到了 2</span><br><span class="line">我 拿到了 1</span><br><span class="line">你 拿到了 0</span><br><span class="line">黄牛 拿到了 -1</span><br></pre></td></tr></table></figure>

<p>为什么会出现-1呢? 当票还剩一张时, 每个人看到的都是1, 对它进行了重复操作, 所以变成了-1. 这显然说明线程是不安全的.</p>
<p>再来看一个取钱的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBank</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="number">100</span>, <span class="string">"基金"</span>);</span><br><span class="line"></span><br><span class="line">        Drawing you = <span class="keyword">new</span> Drawing(account, <span class="number">50</span>, <span class="string">"你"</span>, <span class="number">50</span>);</span><br><span class="line">        Drawing wife = <span class="keyword">new</span> Drawing(account, <span class="number">100</span>, <span class="string">"girlfriend"</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        you.start();</span><br><span class="line">        wife.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个银行账户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟取款</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Account account;</span><br><span class="line">    <span class="comment">// 取了多少钱</span></span><br><span class="line">    <span class="keyword">int</span> drawingMoney;</span><br><span class="line">    <span class="comment">// 现在手里有多少钱</span></span><br><span class="line">    <span class="keyword">int</span> nowMoney;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Drawing</span><span class="params">(Account account, <span class="keyword">int</span> drawingMoney, String name, <span class="keyword">int</span> nowMoney)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawingMoney = drawingMoney;</span><br><span class="line">        <span class="keyword">this</span>.nowMoney = nowMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取钱</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (account.money - drawingMoney &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"钱不够, 取不了"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 卡内余额</span></span><br><span class="line">        account.money = account.money - drawingMoney;</span><br><span class="line">        nowMoney = nowMoney + drawingMoney;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"余额为: "</span> + account.money);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 手里的钱 "</span> + nowMoney);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">余额为: -50</span><br><span class="line">余额为: 0</span><br><span class="line">你 手里的钱 100</span><br><span class="line">girlfriend 手里的钱 150</span><br></pre></td></tr></table></figure>

<p>集合中有不少都是线程不安全的, 比如<code>List</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(Thread.currentThread().getName());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按常理来讲, 列表中应该添加了1000个元素, 但是实际的输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401</span><br></pre></td></tr></table></figure>

<p>可能是因为主线程中的打印操作执行得过早, 还没等线程全部加进去, 那我们添加一个延时, 给足添加的时间:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(Thread.currentThread().getName());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里给了五秒钟, 足够将所有线程添加到列表中了, 输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">992</span><br></pre></td></tr></table></figure>

<p>分析原因是某一时间两个元素添加到了列表的同一位置, 然后覆盖掉了一个.</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>解决上述的不安全案例, 所用的方法就是同步</p>
<p>由于我们可以通过private关键字来保证数据对象只能被方法访问, 所以我们只需要针对方法提出一套机制, 这套机制就是 <strong>synchronized</strong> 关键字, 它包括两种方法: </p>
<p>synchronized 方法 和 synchronized 块.</p>
<blockquote>
<p>同步方法: <strong>public synchronized void method(int args){}</strong></p>
</blockquote>
<p>synchronized 方法控制对”对象”的访问, 每个对象对应一把锁, 每个 synchronized 方法都必须获得调用该方法的对象的锁才能执行, 否则线程会阻塞, 方法一旦执行, 就独占该锁, 直到该方法返回才会释放锁, 后面被阻塞的线程才能获得这个锁, 继续执行.</p>
<blockquote>
<p>缺陷: <strong>若将一个大的方法申明为synchronized将会影响效率</strong></p>
</blockquote>
<p><strong>在使用synchronize修饰方法时要注意以下几点:</strong></p>
<ol>
<li><p>synchronized关键字不能继承.</p>
<p>虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下：</p>
<ul>
<li>在子类方法中加上synchronized关键字:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在子类方法中调用父类的同步方法:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; <span class="keyword">super</span>.method();   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在定义接口方法时不能使用synchronized关键字。</p>
</li>
<li><p>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</p>
</li>
</ol>
<h4 id="修饰一个静态方法"><a href="#修饰一个静态方法" class="headerlink" title="修饰一个静态方法"></a>修饰一个静态方法</h4><p>Synchronized也可修饰一个静态方法，用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      method();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SyncThread syncThread1 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">SyncThread syncThread2 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(syncThread1, <span class="string">"SyncThread1"</span>);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(syncThread2, <span class="string">"SyncThread2"</span>);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SyncThread1:0</span><br><span class="line">SyncThread1:1</span><br><span class="line">SyncThread1:2</span><br><span class="line">SyncThread1:3</span><br><span class="line">SyncThread1:4</span><br><span class="line">SyncThread2:5</span><br><span class="line">SyncThread2:6</span><br><span class="line">SyncThread2:7</span><br><span class="line">SyncThread2:8</span><br><span class="line">SyncThread2:9</span><br></pre></td></tr></table></figure>

<p>syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。这与Demo1是不同的。</p>
<h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><p>同步块: <strong>synchronized(Obj) {}</strong></p>
<p><code>Obj</code> 称之为 <strong>同步监视器</strong></p>
<ul>
<li>Obj 可以是任何对象, 但是推荐使用共享资源作为同步监视器</li>
<li>同步方法中无需指定同步监视器, 因为同步方法的同步监视器就是this, 就是这个对象本身, 或者是 class</li>
</ul>
<p>同步监视器的执行过程:</p>
<ol>
<li>第一个线程访问, 锁定同步监视器, 执行其中代码</li>
<li>第二个线程访问, 发现同步监视器被锁定, 无法访问</li>
<li>第一个线程访问完毕, 解锁同步监视器</li>
<li>第二个线程访问, 发现同步监视器没有锁, 然后锁定并访问</li>
</ol>
<p>对于三个不安全的案例进行修改, 抢票的案例中, 把买票的方法加上关键词 synchronized 即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步方法, 锁的是this</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 拿到了 "</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你 拿到了 10</span><br><span class="line">我 拿到了 9</span><br><span class="line">黄牛 拿到了 8</span><br><span class="line">我 拿到了 7</span><br><span class="line">你 拿到了 6</span><br><span class="line">你 拿到了 5</span><br><span class="line">我 拿到了 4</span><br><span class="line">我 拿到了 3</span><br><span class="line">黄牛 拿到了 2</span><br><span class="line">我 拿到了 1</span><br></pre></td></tr></table></figure>

<p>对于银行取钱的案例进行修改, 使用同步块, 将共用的账户资源作为同步监视器, 然后将取钱的过程放在代码块中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取钱</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (account)&#123;</span><br><span class="line">        <span class="keyword">if</span> (account.money - drawingMoney &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"钱不够, 取不了"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 卡内余额</span></span><br><span class="line">        account.money = account.money - drawingMoney;</span><br><span class="line">        nowMoney = nowMoney + drawingMoney;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"余额为: "</span> + account.money);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 手里的钱 "</span> + nowMoney);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">余额为: 50</span><br><span class="line">你 手里的钱 100</span><br><span class="line">钱不够, 取不了</span><br></pre></td></tr></table></figure>

<p>对不安全的集合案例进行修改, 把list作为同步监视器即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                    list.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出也正常了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure>

<p>以下两个写法是等价的:</p>
<p>写法一:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法二:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>多个线程各自占有一些共享资源, 并且互相等待其他线程占有的资源才能运行, 而导致两个或者多个线程都在等待对方释放资源, 都停止执行的情形. 某一个同步块同时拥有 <strong>两个以上对象的锁</strong> 时, 就可能会发生死锁的问题.</p>
<p>下面写一个互相抱着对方的锁的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Makeup g1 = <span class="keyword">new</span> Makeup(<span class="number">0</span>, <span class="string">"灰姑娘"</span>);</span><br><span class="line">        Makeup g2 = <span class="keyword">new</span> Makeup(<span class="number">1</span>, <span class="string">"白雪公主"</span>);</span><br><span class="line"></span><br><span class="line">        g1.start();</span><br><span class="line">        g2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lipstick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mirror</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Makeup</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要的资源只有一份, 用static来保证</span></span><br><span class="line">    <span class="keyword">static</span> Lipstick lipstick = <span class="keyword">new</span> Lipstick();</span><br><span class="line">    <span class="keyword">static</span> Mirror mirror = <span class="keyword">new</span> Mirror();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> choice;</span><br><span class="line">    String girlName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Makeup</span><span class="params">(<span class="keyword">int</span> choice, String girlName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.choice = choice;</span><br><span class="line">        <span class="keyword">this</span>.girlName = girlName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeup();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeup</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lipstick) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.girlName + <span class="string">" 获得口红的锁 "</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (mirror) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.girlName + <span class="string">" 获得镜子的锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mirror) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.girlName + <span class="string">" 获得镜子的锁"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (lipstick) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.girlName + <span class="string">" 获得口红的锁 "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿g1来说, 因为她抱着口红的锁, 想要镜子的锁, 但是镜子的锁拿不到, 所以同步块一直执行不完, g2也是这样, 相互僵持着, 发生死锁.</p>
<h3 id="死锁的避免方法"><a href="#死锁的避免方法" class="headerlink" title="死锁的避免方法"></a>死锁的避免方法</h3><p>产生死锁的四个必要条件:</p>
<ol>
<li><strong>互斥条件:</strong> 一个资源每次只能被一个进程使用</li>
<li>*<em>请求与保持条件: *</em> 一个进程因请求资源而阻塞时, 对已获得的资源保持不放</li>
<li>*<em>不剥夺条件: *</em> 进程已获得的资源, 在未使用完之前, 不能强行剥夺</li>
<li>*<em>循环等待条件: *</em> 若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<p>上面的四个必要条件中, 我们只要想办法破其中任意一个或多个条件就可以避免死锁的发生</p>
<hr>
<h2 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock(锁)"></a>Lock(锁)</h2><p>从JDK 5.0 开始, Java 提供了更强大的线程同步机制—-通过显示定义同步锁对象来实现同步, 同步锁使用Lock对象充当.</p>
<ul>
<li>java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具. 锁提供了对共享资源的独占访问, 每次只能有一个线程对Lock 对象加锁, 线程开始访问共享资源之前应先获得Lock 对象</li>
<li>ReentrantLock 类实现了 Lock, 他拥有与 synchronized 相同的并发性和内存语义, 在实现线程安全的控制中, 比较常用的是ReentrantLock, 可以显式加锁, 释放锁.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestLock2 testLock2 = <span class="keyword">new</span> TestLock2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2, <span class="string">"aaa"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2, <span class="string">"bbb"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2, <span class="string">"ccc"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock锁</span></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (ticketNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">" 抢到了 "</span> + ticketNums--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaa 抢到了 10</span><br><span class="line">ccc 抢到了 9</span><br><span class="line">bbb 抢到了 8</span><br><span class="line">bbb 抢到了 7</span><br><span class="line">aaa 抢到了 6</span><br><span class="line">ccc 抢到了 5</span><br><span class="line">bbb 抢到了 4</span><br><span class="line">aaa 抢到了 3</span><br><span class="line">ccc 抢到了 2</span><br><span class="line">ccc 抢到了 1</span><br></pre></td></tr></table></figure>

<p>利用重入锁进行编码的流程为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function">pubilc <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//保证线程安全的代码</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="comment">// 如果同步代码有异常, 要将unlock()写入finally块中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h3><ul>
<li><p>Lock 是显式锁(手动开启和关闭锁, 别忘记关闭), synchronized 是隐式锁, 出了作用域自动释放</p>
</li>
<li><p>Lock 只有代码块锁, synchronize有代码块锁和方法锁</p>
</li>
<li><p>使用Lock锁, JVM将花费较少时间来调度线程, 性能更好. 并且具有更好的扩展性(提供更多的子类)</p>
</li>
<li><p>优先使用顺序:</p>
<p><strong>Lock &gt; 同步代码块(已经进入了方法体, 分配了相应资源) &gt; 同步方法(在方法体之外)</strong></p>
</li>
</ul>
<hr>
<h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p>应用场景: 生产者和消费者问题</p>
<ul>
<li>假设仓库中只能存放一件产品, 生产者将生产出来的产品放入仓库, 消费者将仓库中产品取走消费</li>
<li>如果仓库中没有产品, 则生产者将产品放入仓库, 否则停止生产并等待, 直到仓库中的产品被消费者取走为止</li>
<li>如果仓库中放有产品, 则消费者可以将产品取走消费, 否则停止消费并等待, 直到仓库中再次放入产品为止</li>
</ul>
<p>这是一个线程同步问题, 生产者和消费者共享同一个资源, 并且生产者和消费者之间相互依赖, 互为条件:</p>
<ul>
<li>对于生产者, 没有生产产品之前, 要通知消费者等待, 而生产了产品之后, 又需要通知消费者消费</li>
<li>对于消费者, 在消费之后, 要通知生产者已经结束消费, 需要生产新的产品以供消费</li>
<li>在生产者消费者问题中, 仅有 synchronized是不够的<ul>
<li>synchronized可阻止并发更新同一个共享资源, 实现了同步</li>
<li>synchronized不能用来实现不同线程之间的信息传递(通信)</li>
</ul>
</li>
</ul>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><p>Java提供了几个方法解决线程之间的通信问题</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>wait()</td>
<td>表示线程一直等待, 直到其他线程通知, 与sleep不同, 会释放锁</td>
</tr>
<tr>
<td>wait(long timeout)</td>
<td>指定等待的毫秒数</td>
</tr>
<tr>
<td>notify()</td>
<td>唤醒一个处于等待状态的线程</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>唤醒同一个对象上所有调用wait()方法的线程, 优先级高的线程优先调度</td>
</tr>
</tbody></table>
<p><strong>注意: 均是Object类的方法, 都只能在同步方法或者同步代码块中使用, 否则会抛出异常IllegalMonitorStateException</strong></p>
<h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><p>并发协作模型”生产者/ 消费者模式” –&gt; 管程法</p>
<ul>
<li>生产者: 负责生产数据的模块(可能是方法, 对象, 线程, 进程);</li>
<li>消费者: 负责处理数据的模块(可能是方法, 对象, 线程, 进程);</li>
<li>缓冲区: 消费者不能直接使用生产者的数据, 他们之间有个缓冲区</li>
</ul>
<p><strong>生产者将生产好的数据放入缓冲区, 消费者从缓冲区拿出数据</strong></p>
<p>写一个例子来理解管程法的过程. 这是一个炸鸡店的例子. 假设库存最大能保留十只鸡, 多于十只则生产者不生产, 生产者线程<code>wait()</code>, 少于零只则消费者不消费,消费者线程<code>wait()</code>. 当消费者成功消费一个炸鸡, 就<code>notifyAll()</code> 一下, 当生产者成功生产一个炸鸡, 就<code>notifyAll()</code> 一下.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者, 消费者, 产品, 缓冲区</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynContainer container = <span class="keyword">new</span> SynContainer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Productor(container).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(container).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            container.push(<span class="keyword">new</span> Chicken(i));</span><br><span class="line">            System.out.println(<span class="string">"生产--&gt; "</span> + i + <span class="string">" 只鸡"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消费了--&gt; "</span> + container.pop().id + <span class="string">" 只鸡"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chicken</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器计数器</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要一个容器大小</span></span><br><span class="line">    Chicken[] chickens = <span class="keyword">new</span> Chicken[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者放入产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Chicken chicken)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果容器满了, 就要等待消费者消费</span></span><br><span class="line">        <span class="keyword">if</span> (count == chickens.length) &#123;</span><br><span class="line">            <span class="comment">// 通知消费者消费, 生产者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有满, 我们就需要丢入产品</span></span><br><span class="line">        chickens[count] = chicken;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以通知消费者消费了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者消费产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Chicken <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断能否消费</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待生产者生产, 消费者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果可以消费</span></span><br><span class="line">        Chicken chicken = chickens[count - <span class="number">1</span>];</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 吃完了, 通知生产者生产</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> chicken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h3><p>并发协作模型”生产者/ 消费者模式” –&gt; 信号灯法</p>
<p>通过标志位解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Player(tv).start();</span><br><span class="line">        <span class="keyword">new</span> Watcher(tv).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者-- 演员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">"快乐大本营"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">"新闻联播"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者-- 观众</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Watcher</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            tv.watch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品-- 节目</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 演员表演, 观众等待 T</span></span><br><span class="line">    <span class="comment">// 观众观看, 演员等待 F</span></span><br><span class="line">    String voice;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表演</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String voice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"演员表演了 "</span> + voice);</span><br><span class="line">        <span class="comment">// 通知观众观看</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">this</span>.voice = voice;</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"观看了 "</span> + voice);</span><br><span class="line">        <span class="comment">// 通知演员表演</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">演员表演了 快乐大本营</span><br><span class="line">观看了 快乐大本营</span><br><span class="line">演员表演了 新闻联播</span><br><span class="line">观看了 新闻联播</span><br><span class="line">演员表演了 快乐大本营</span><br><span class="line">观看了 快乐大本营</span><br><span class="line">演员表演了 新闻联播</span><br><span class="line">观看了 新闻联播</span><br><span class="line">演员表演了 快乐大本营</span><br><span class="line">观看了 快乐大本营</span><br><span class="line">演员表演了 新闻联播</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li><strong>背景</strong>: 经常创建和销毁, 使用量特别大的资源, 比如并发情况下的线程, 对性能影响很大</li>
<li>*<em>思路: *</em> 提前创建好多个线程, 放入线程池中, 使用时直接获取, 使用完放回池中. 可以避免频繁创建销毁, 实现重复利用. 类似生活中的公共交通工具</li>
<li><strong>好处:</strong><ul>
<li>提高响应速度(减少了创建新线程的时间)</li>
<li>降低资源消耗(重复利用线程池中线程, 不需要每次都创建)</li>
<li>便于线程管理<ul>
<li>corePoolSize: 核心池的大小</li>
<li>maximumPoolSize: 最大线程数</li>
<li>keepAliveTime: 线程没有任务时最多保持多长时间会终止</li>
</ul>
</li>
</ul>
</li>
<li>JDK 5.0 起提供了线程池相关API: <strong>ExecutorService</strong> 和 <strong>Executors</strong></li>
<li>ExecutorServive: 真正的线程池接口. 常见子类ThreadPoolExecutor<ul>
<li>void execute(Runnable command): 执行任务/命令, 没有返回值, 一般用来执行Runnable</li>
<li><T> Future<T> submit(Callable<T> task): 执行任务, 有返回值, 一般又来执行Callable</li>
<li>void shutdown() : 关闭连接池</li>
</ul>
</li>
<li>Executors: 工具类, 线程池的工厂类, 用于创建并返回不同类型的线程池 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建服务, 创建线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 关闭连接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
