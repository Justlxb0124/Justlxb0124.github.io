<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>153.寻找旋转排序数组中的最小值</title>
    <url>/2020/07/04/153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>因为不存在重复的数字, 所以只需要考虑大于和等于的情况, 比较对象为<code>nums[right]</code></p>
<ol>
<li><p>循环二分： 设置 <code>i</code>,<code>j</code> 指针分别指向<code>numbers</code> 数组左右两端，<code>m = (i + j) / 2</code> 为每次二分的中点（ “/“ 代表向下取整除法），可分为以下三种情况：</p>
<ol>
<li><p>当<code>numbers[m] &gt; numbers[j]</code>时： <code>m</code> 一定在 左排序数组 中，即旋转点 <code>x</code>一定在<code>[m + 1, j]</code>闭区间内，因此执行<code>i = m + 1</code>；</p>
</li>
<li><p>当 <code>numbers[m] &lt; numbers[j]</code>时： <code>m</code> 一定在 右排序数组 中，即旋转点 <code>x</code> 一定在<code>[i, m]</code> 闭区间内，因此执行<code>j = m</code>；</p>
</li>
</ol>
</li>
<li><p>返回值： 当<code>i = j</code>时跳出二分循环，并返回 <code>numbers[i]</code>即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>32.最长有效括号</title>
    <url>/2020/07/04/32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>刚做这道题时忽略了题目中<strong>子串</strong>的要求, 直接求了共有多少有效括号, 提交后才发现.</p>
<p>首先想到的还是用栈来解决有效括号的问题, 这道题麻烦在必须是子串才可以, 字符前后需要建立联系.</p>
<p>具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：</p>
<ul>
<li>对于遇到的每个<code>(</code> ，我们将它的下标放入栈中</li>
<li>对于遇到的每个<code>)</code>，我们先弹出栈顶元素表示匹配了当前右括号：<ul>
<li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</li>
<li>如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」</li>
</ul>
</li>
</ul>
<p>需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1−1 的元素。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/1.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/2.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/4.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/5.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/6.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/7.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/8.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/9.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/10.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/11.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>)</span><br><span class="line">                stack.push(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = Math.max(max, i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>240.搜索二维矩阵Ⅱ</title>
    <url>/2020/07/08/240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E2%85%A1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。<br>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p>
<p><strong>示例一</strong>：</p>
<p>给定 target = 5，返回 true。</p>
<p><strong>示例二</strong>：</p>
<p>给定 target = 20，返回 false。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="左下角出发遍历法"><a href="#左下角出发遍历法" class="headerlink" title="左下角出发遍历法"></a>左下角出发遍历法</h2><p>根据本文所描述的特征, 每一行从左到右递增, 每一列从上到下递增, 所以可以根据贪婪思想决定每一步怎么走, 即:</p>
<ul>
<li>当<code>matrix[i][j]&gt;target</code>, 则直接删除改行数组, <code>i--</code>, 因为只能往上走才能找到更小的数</li>
<li>当<code>matrix[i][j]&lt;target</code>, 则直接删除该列数组, <code>j++</code>, 因为只能往右走才能找到更大的数</li>
<li>若相等, 直接返回<code>true</code></li>
</ul>
<p>越界说明没找到, 返回<code>false</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt;= matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二分查找-较慢"><a href="#二分查找-较慢" class="headerlink" title="二分查找(较慢)"></a>二分查找(较慢)</h2><p>因为矩阵已经排过序, 所以可采用二分查找的方法.</p>
<p>思路是遍历每一行的数组进行查找, 每当遍历到新的一行, 如果该行第一个元素都比目标值大, 那么直接返回<code>false</code>, 因为这已经是目前还没有遍历的数中最小的了.</p>
<p>如果该行数组最右的元素都比目标值小, 则直接开始遍历下一行, 因为这已经是这一行最大的数了, 没有查找的必要.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix2</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>]&gt;target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][matrix[<span class="number">0</span>].length-<span class="number">1</span>]&lt;target)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> col = binarySearch1(matrix[i], target);</span><br><span class="line">            <span class="keyword">if</span> (col!=-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span>[] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid]&lt;target) i = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid]&gt;target) j = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>173.二叉搜索树迭代器</title>
    <url>/2020/07/16/173-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p>
<p>调用 <code>next()</code> 将返回二叉搜索树中的下一个最小的数。</p>
<p><strong>示例：</strong></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/bst-tree.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BSTIterator iterator &#x3D; new BSTIterator(root);</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 3</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 7</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 9</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 15</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 true</span><br><span class="line">iterator.next();    &#x2F;&#x2F; 返回 20</span><br><span class="line">iterator.hasNext(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS-列表"><a href="#DFS-列表" class="headerlink" title="DFS + 列表"></a>DFS + 列表</h2><p>需要写一个构造器, 然后实现两个方法. 因为要输出的是下一个最小的节点, 所以很容易想到中序遍历, 然后一个一个输出.</p>
<p><strong>大致思路为:</strong></p>
<ol>
<li>写构造器, 当传入一个二叉搜索树时, 直接将其中序遍历, 并将结果用列表存放</li>
<li>初始化一个变量, 时刻记录当前输出到哪里, 即再次调用<code>next()</code> 和<code>hasNext()</code> 时要查看的位置</li>
<li>当调用<code>next()</code> , 指针移动一位, 当调用<code>hasNext()</code>, 指针不动</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">                inOrder(root.left);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">                inOrder(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the next smallest number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(++index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> whether we have a next smallest number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index != list.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>315.计算右侧小于当前元素的个数</title>
    <url>/2020/07/08/315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [5,2,6,1]</span><br><span class="line">输出: [2,1,1,0] </span><br><span class="line">解释:</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1).</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1).</span><br><span class="line">6 的右侧有 1 个更小的元素 (1).</span><br><span class="line">1 的右侧有 0 个更小的元素.</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>这道题目要想到二分查找的一个性质: 在一个排序数组中, 可以通过二分查找目标值的左边界来表示数组中有多少个元素小于目标值</p>
<p>比如一个数组为:<code>[1, 2, 2, 4, 5, 6]</code>, 查找数字<code>4</code>的返回值是<code>3</code>, 结果不言而喻.</p>
<p>那么我们需要想办法创造出排序数组的条件.</p>
<p>首先初始化一个空的列表用于存放遍历后的元素, 因为这道题目是考察右侧有多少个更小的元素, 所以要从右往左遍历, 这能保证每遍历到一个元素, 列表中的元素都位于它的右边, 只需要在它们之间查找即可.</p>
<p>二分查找的结果即为元素右边有多少更小的值, 并将其插入到合适的位置使列表仍然是有序的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res.addFirst(binarySearch(list, nums[i]));</span><br><span class="line">            list.add(binarySearch(list, nums[i]), nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (list.get(mid) &gt;= target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (list.get(mid) &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在做这道题时因为要用到向列表中某个位置插入元素, 找响应的<code>insert()</code> 方法, 怎么也找不到, 原来直接用<code>add()</code> 方法就好了, 如果只填一个元素, 默认为列表尾部添加元素, 如果在前面写上索引, 即为在指定位置插入元素, 剩余元素后移.</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>29.两数相除</title>
    <url>/2020/07/04/29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line">解释: 10&#x2F;3 &#x3D; truncate(3.33333..) &#x3D; truncate(3) &#x3D; 3</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">输出: -2</span><br><span class="line">解释: 7&#x2F;-3 &#x3D; truncate(-2.33333..) &#x3D; -2</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>首先想到的是对被除数循环递减, 记录能减多少次就好了, 但是明显效率太低.</p>
<p>那么这个循环递减的过程就可以使用移位运算优化一下.<strong>计算机在做移位时效率很高, 向左移1位相当于乘以2, 向右移1位相当于除以2</strong></p>
<p>设循环初始值为<code>i = 31</code>, 每次循环都比较<code>dividend&gt;&gt;i</code> 和 <code>devisor</code>的大小, 起初结果肯定是小于关系. 一旦变成了等于或大于关系, 则说明商至少是<code>2^i</code></p>
<p>以100除以3为例说明:</p>
<p><code>i</code>从31, 30, …,开始循环, 当<code>i=5</code>时, 有<code>(100&gt;&gt;5)&gt;=3</code>, 即<code>100/32&gt;=3</code>, 说明100中至少有32个3, 然后让余数4继续完成遍历.</p>
<p>这样的方法最多只只需要遍历31个数字即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> negative = (dividend ^ divisor) &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> t = Math.abs((<span class="keyword">long</span>) dividend);</span><br><span class="line">        <span class="keyword">long</span> d = Math.abs((<span class="keyword">long</span>) divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((t &gt;&gt; i) &gt;= d) &#123;</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                t -= d &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? -res : res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>96.不同的二叉搜索树</title>
    <url>/2020/07/16/96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>这道题需要动手推导, 根据下图的关系:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/5e13a34a242ad4a1a509b1c54fc17d2e4c81add7d8c5104f96b5f91293af8031-frame_00007.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/96bb714d079c7aef72465216b1f205cbf78865f6bcc3cf69691f7d46096196e0-frame_00010.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/69509ce7a83c6c57bc6fb611db21ef1a83c552cc4237e75fb338162c8e128c12-frame_00016.png" alt=""></p>
<p>可以总结出思路, 对于<code>n</code> 个节点来说, 每个节点都可以作为根节点, 每个节点作为根节点的所有情况加起来就是<code>n</code> 个节点的总数量. 比如图中的 n=3 的情况, 就是<strong>节点1作为根节点的情况 + 节点2作为根节点的情况 + 节点3作为根节点的情况</strong>. 而每个节点作为根节点时的可能性数量又等于左右子树的情况相乘. 这就是一个动态规划的问题, 因为每个状态都与前几个状态有关.</p>
<p><strong><em>G</em>(<em>n</em>)=<em>f</em>(1)+<em>f</em>(2)+<em>f</em>(3)+<em>f</em>(4)+…+<em>f</em>(<em>n</em>)</strong></p>
<p>其中</p>
<p><strong><em>f</em>(<em>i</em>)=<em>G</em>(<em>i</em>−1)∗<em>G</em>(<em>n</em>−<em>i</em>)</strong></p>
<p>综合两个公式可以得到 <code>卡特兰数</code>公式</p>
<p><strong><em>G(n) = G(0)G(n-1)+G(1)(n-2)+…+G(n-1)*G(0)G(n)=G(0)∗G(n−1)+G(1)∗(n−2)+…+G(n−1)∗G(0)</em></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc96</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>287.寻找重复数</title>
    <url>/2020/07/03/287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>之所以不使用暴力遍历查找和哈希表记录, 是因为时间复杂度或者空间复杂度超出要求.</p>
<p>使用<code>cnt[i]</code>表示<code>nums[]</code>数组中小于等于<code>i</code> 的数有多少个, 假设我们重复的数是<code>target</code>, 那么<code>[1, target-1]</code>里的所有数满足<code>cnt[i]&lt;=i</code>, <code>[target, n]</code>里的所有数满足<code>cnt[i]&gt;i</code>, 具有单调性.</p>
<p>以示例1为例, 列出每个数字的<code>cnt</code>值:</p>
<table>
<thead>
<tr>
<th align="center">nums</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cnt</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>示例中重复的整数是2, 我们可以看到[1, 1]中的数满足<code>cnt[i]&lt;=i</code>, [2, 4]中的数满足<code>cnt[i]&gt;i</code></p>
<p>一旦知道了<code>cnt[i]</code>数组的单调性和以上的大小关系, 就可以使用二分查找来找到重复的数. 对于所有测试用例, 考虑一下两种情况:</p>
<ul>
<li>如果测试用例的数组中 <code>target</code> 出现了两次，其余的数各出现了一次，这个时候肯定满足上文提及的性质，因为小于<code>target</code> 的数 <code>i</code>满足<code>cnt[i]=i</code>，大于等于<code>target</code> 的数 <code>j</code>满足 <code>cnt[j]=j+1</code></li>
<li>如果测试用例的数组中<code>target</code>出现了三次及以上，那么必然有一些数不在 <code>nums[]</code>数组中了，这个时候相当于我们用 <code>target</code> 去替换了这些数，我们考虑替换的时候对 <code>cnt[]</code>数组的影响。如果替换的数<code>i</code>小于 <code>target</code>，那么 <code>[i,target-1]</code> 的 <code>cnt</code> 值均减一，其他不变，满足条件。如果替换的数 <code>j</code>大于等于 <code>target</code>，那么<code>[target, j-1]</code>的 <code>cnt</code> 值均加一，其他不变，亦满足条件。</li>
</ul>
<p><strong>总结来说就是, 对于每个区间[left, right], 根据<code>mid</code>计算出<code>cnt</code>的值, 然后比较<code>mid</code>和<code>cnt</code>的大小, 以比较的结果调整左右边界</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= mid) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= mid) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发编程</title>
    <url>/2020/07/11/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="什么是JUC"><a href="#什么是JUC" class="headerlink" title="什么是JUC"></a>什么是JUC</h2><p>所谓JUC并发编程, 就是利用到了JDK中以下的三个关于多线程的包进行开发:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200712203137.png" alt=""></p>
<p>简称为 J U C.</p>
<p>一些业务无法通过普通的线程代码完成, 比如基础阶段的 <code>Thread</code></p>
<p><strong>Runnable</strong> : 没有返回值, 效率相较于Callable 相对较低</p>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><p>在操作系统中运行的程序就是进程, 比如QQ, 播放器, 游戏等</p>
<p>一个进程可以有多个线程, 如视频中同时听到声音, 看到图像, 看弹幕等等</p>
<p>需要注意的是, <strong>程序</strong>是指令和数据的有序集合, 是一个静态的概念, 执行程序的一次执行过程叫做<strong>进程</strong>, 这才是动态的概念</p>
<p>通常在一个进程中可以包含若干个线程, 线程是CPU调度和执行的单位</p>
<p><strong>核心概念:</strong></p>
<ul>
<li>在程序执行时, 即使没有创建线程, 后台也会有多个线程, 如主线程, gc线程;</li>
<li>main()称之为主线程, 为系统的入口, 用于执行整个程序</li>
<li>对同一份资源操作时, 会存在资源抢夺的问题, 需要加入并发控制</li>
<li>线程会带来额外的开销, 如CPU调度时间, 并发控制开销</li>
</ul>
<p><strong>java默认有几个线程?</strong></p>
<p>两个: main, GC</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM原理</title>
    <url>/2020/07/12/JVM%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="JVM探究"><a href="#JVM探究" class="headerlink" title="JVM探究"></a>JVM探究</h1><ul>
<li>请你谈谈对JVM的理解? Java8虚拟机和之前的变化更新?</li>
<li>什么是OOM, 什么是栈溢出?怎么分析?</li>
<li>JVM的常用调优参数有哪些?</li>
<li>内存快照如何抓取, 怎么分析Dump文件?</li>
<li>谈谈JVM中, 类加载器的认识?</li>
</ul>
<h1 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h1><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200712210530.png" alt=""></p>
<h1 id="JVM的体系结构"><a href="#JVM的体系结构" class="headerlink" title="JVM的体系结构"></a>JVM的体系结构</h1><p><img src="http://qcxz71s06.bkt.clouddn.com/jvm.png" alt=""></p>
<p>所谓的JVM调优, 99%的情况下都是在<strong>方法区</strong>和<strong>堆</strong>中调的. 这之中绝大部分都是在调堆.</p>
<p>运行时数据区中的 <strong>栈, 本地方法栈, 程序计数器</strong>这三个部分不可能有垃圾</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>加载Class文件: new Student();</p>
<p>引用是在栈里, 具体的实例放在堆中</p>
<p>实例化一个Car类的过程：</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200712215554.png" alt=""></p>
<p>生成的实例对象包括各种属性放在堆中, 名字也就是地址放在栈中. 引用时根据栈中的地址去堆中引用</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200712214851.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car1 = <span class="keyword">new</span> Car();</span><br><span class="line">        Car car2 = <span class="keyword">new</span> Car();</span><br><span class="line">        Car car3 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends Car&gt; aClass1 = car1.getClass();</span><br><span class="line">        Class&lt;? extends Car&gt; aClass2 = car2.getClass();</span><br><span class="line">        Class&lt;? extends Car&gt; aClass3 = car3.getClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(aClass1);</span><br><span class="line">        System.out.println(aClass2);</span><br><span class="line">        System.out.println(aClass3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Car</span><br><span class="line">class Car</span><br><span class="line">class Car</span><br></pre></td></tr></table></figure>

<p><strong>类加载器的分类:</strong></p>
<ol>
<li>虚拟机自带的加载器</li>
<li>启动类(根)加载器: 负责加载%JAVA_HOME%\bin目录下的所有jar包，或者是-Xbootclasspath参数指定的路径；</li>
<li>扩展类加载器: 负责加载%JAVA_HOME%\bin\ext目录下的所有jar包，或者是java.ext.dirs参数指定的路径；</li>
<li>应用程序加载器: 负责加载用户类路径上所指定的类库，如果应用程序中没有自定义加载器，那么次加载器就为默认加载器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car1 = <span class="keyword">new</span> Car();</span><br><span class="line">        Car car2 = <span class="keyword">new</span> Car();</span><br><span class="line">        Car car3 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">        Class&lt;? extends Car&gt; aClass1 = car1.getClass();</span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = aClass1.getClassLoader();</span><br><span class="line">        ClassLoader parent = classLoader.getParent();</span><br><span class="line">        ClassLoader parent1 = parent.getParent();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        System.out.println(parent);</span><br><span class="line">        System.out.println(parent1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdk.internal.loader.ClassLoaders$AppClassLoader@3fee733d</span><br><span class="line">jdk.internal.loader.ClassLoaders$PlatformClassLoader@723279cf</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><ol>
<li>类加载器收到类加载的请求</li>
<li>将这个请求向上委托给父类加载器去完成, 一直向上委托, 直到启动类加载器</li>
<li>启动类加载器检查是否能够加载当前这个类, 能加载就结束, 使用当前加载器, 否则, 抛出异常, 通知子加载器进行加载</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/1502173-20181029183937235-1542648599.png" alt=""></p>
<p>接下来举个例子：</p>
<p>大家所熟知的Object类，直接告诉大家，Object默认情况下是启动类加载器进行加载的。假设我也自定义一个Object，并且制定加载器为自定义加载器。现在你会发现自定义的Object可以正常编译，但是永远无法被加载运行。</p>
<p>这是因为申请自定义Object加载时，总是启动类加载器，而不是自定义加载器，也不会是其他的加载器。</p>
<h1 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h1><p>Java安全模型的核心就是Java沙箱, 沙箱是一个限制程序运行的环境. 沙箱机制就是将Java代码限定在虚拟机特定的运行范围中, 并且严格限制代码对本地系统资源访问, 通过这样的措施来保证对代码的有效隔离, 防止对本地系统造成破坏. 沙箱主要 <strong>限制系统的资源访问</strong> , CPU, 内存, 文件系统, 网络. 不同级别的沙箱对这些资源访问的限制也可以不一样</p>
<h1 id="Native"><a href="#Native" class="headerlink" title="Native"></a>Native</h1><p>在Java 的<code>Thread</code> 类中, 有这样的方法:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200713105125.png" alt=""></p>
<p>凡是带了<code>native</code> 关键字的, 说明java的作用范围达不到了, 会去调用底层c语言的库</p>
<p>会进入本地方法栈, 然后它会调用JNI(本地方法接口), 继而调用本地方法库</p>
<p>JNI的作用: 扩展Java的使用, 融合不同的编程语言为Java所用</p>
<h1 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h1><p>程序计数器: Program Counter Register</p>
<p>每个线程都有一个程序计数器, 是线程私有的, 就是一个指针, 指向方法区中的方法字节码(用来存储指向一条指令的地址, 也即将要执行的指令代码), 在执行引擎读取下一条指令, 是一个非常小的内存空间, 几乎可以忽略不计.</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区是被所有线程共享, 所有字段和方法字节码, 以及一些特殊方法, 如构造函数, 接口代码也在此定义, 简单说, 所有定义的方法的信息都保存在该区域, <strong>该区域属于共享区间</strong>;</p>
<p><strong>静态变量, 常量, 类信息(构造方法, 接口定义), 运行时的常量池存在方法区中, 但是实例变量存在堆内存中, 和方法区无关.</strong></p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈内存, 主管程序的运行, 生命周期和线程同步</p>
<p>线程结束, 栈内存也就释放, 对于栈来说, 不存在垃圾回收问题</p>
<p>一旦线程结束, 栈就Over</p>
<p>存放: 8大基本类型 + 对象引用 + 实例的方法</p>
<p>对象的实例化过程视频解析:</p>
<p><a href="https://www.bilibili.com/video/BV1HE411E7kY?from=search&amp;seid=7388971973574996958" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1HE411E7kY?from=search&amp;seid=7388971973574996958</a></p>
<h1 id="三种JVM"><a href="#三种JVM" class="headerlink" title="三种JVM"></a>三种JVM</h1><ul>
<li>Sun公司: HotSpot</li>
<li>BEA:  JRockit</li>
<li>IBM: J9VM</li>
</ul>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>Heap, 一个JVM只有一个堆内存, 堆内存的大小是可以调节的.</p>
<p>类加载器读取了类文件后, 一般会把什么东西放到堆中? 类, 方法, 常量, 变量</p>
<p>堆内存中还要细分为三个区域:</p>
<ul>
<li>新生区(伊甸园区)</li>
<li>养老区</li>
<li>永久区</li>
</ul>
<h2 id="新生区"><a href="#新生区" class="headerlink" title="新生区"></a>新生区</h2><p>类诞生, 成长的地方, 甚至死亡</p>
<p>伊甸园区, 所有的对象都是在 伊甸园 区</p>
<h2 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h2><p>这个区域常驻内存的, 用来存放JDK自身携带的Class对象, Interface元数据, 存储的是Java运行时的一些环境或类信息</p>
<ul>
<li>1.6之前 : 永久代, 常量池实在方法区</li>
<li>1.7: 永久代, 但是慢慢退化了, “去永久代”, 常量池在堆中</li>
<li>1.8之后 : 无永久代, 常量池在元空间</li>
</ul>
<p>默认情况下, JVM分配的总内存是电脑内存的1/4, 而初始化的内存为: 1/64</p>
<ol>
<li>JVM的体系结构</li>
<li>类加载器</li>
<li>双亲委派机制</li>
<li>沙箱安全机制</li>
<li>Native</li>
<li>PC寄存器</li>
<li>方法区</li>
<li>栈</li>
<li>三种JVM</li>
<li>堆</li>
<li>新生区</li>
<li>老年区</li>
<li>永久区</li>
<li>堆内存调优</li>
<li>GC<ol>
<li>常用算法</li>
</ol>
</li>
<li>JMM</li>
<li>总结</li>
</ol>
<ol>
<li>百度</li>
<li>思维导图</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/2020/07/13/Mybatis/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven环境搭建</title>
    <url>/2020/07/15/Maven%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>为什么要学习这个技术</strong></p>
<ol>
<li><p>在Javaweb开发中, 需要使用大量的jar包, 我们手动去导入</p>
</li>
<li><p>如何能够让一个东西自动帮我们导入和配置这个jar包</p>
<p>由此, Maven诞生了</p>
</li>
</ol>
<p><strong>Maven项目架构管理工具</strong></p>
<p>我们目前用来就是导入jar包的</p>
<p><strong>核心思想:</strong><br>约定大于配置!</p>
<ul>
<li>有约束, 不要去违反</li>
<li>Maven会规定好该如何去编写我们的Java代码</li>
</ul>
<h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>进入官网</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716093403.png" alt=""></p>
<ol start="2">
<li>选择下载</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200715215433.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200715215558.png" alt=""></p>
<p>下载完成后解压即可.</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ol>
<li>配置系统环境变量</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716093827.png" alt=""></p>
<ol start="2">
<li>编辑path变量</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716093838.png" alt=""></p>
<ol start="3">
<li>配置好以后测试是否完成</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200715221700.png" alt=""></p>
<h2 id="阿里云镜像"><a href="#阿里云镜像" class="headerlink" title="阿里云镜像"></a>阿里云镜像</h2><ul>
<li>加速我们的下载</li>
<li>国内建议使用阿里云镜像</li>
</ul>
<p>打开conf目录下的settings.xml文件, 修改如下:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716095513.png" alt=""></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*,!jeecg,!jeecg-snapshots<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><p>在本地建立一个仓库</p>
<ol>
<li>在目录下新建文件夹作为本地仓库</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716094843.png" alt=""></p>
<ol start="2">
<li>在settings.xml文件中进行修改</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716095005.png" alt=""></p>
<h1 id="IDEA里的Maven操作"><a href="#IDEA里的Maven操作" class="headerlink" title="IDEA里的Maven操作"></a>IDEA里的Maven操作</h1><h2 id="创建一个MavenWeb项目"><a href="#创建一个MavenWeb项目" class="headerlink" title="创建一个MavenWeb项目"></a>创建一个MavenWeb项目</h2><ol>
<li>新建Maven项目, 选择一个模板</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716100008.png" alt=""></p>
<ol start="2">
<li>填写项目信息</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716100404.png" alt=""></p>
<p>​        GroupId:  组名</p>
<p>​        ArtifactId: 项目名</p>
<ol start="3">
<li>填写Maven目录信息</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716100914.png" alt=""></p>
<ol start="4">
<li><p>等待项目初始化完毕</p>
</li>
<li><p>观察Maven仓库中多了什么东西</p>
</li>
</ol>
<p><img src="C:%5CUsers%5Clxb%5CDesktop%5CQQ%E6%88%AA%E5%9B%BE20200716104455.png" alt="QQ截图20200716104455"></p>
<h2 id="IDEA中的Maven设置"><a href="#IDEA中的Maven设置" class="headerlink" title="IDEA中的Maven设置"></a>IDEA中的Maven设置</h2><p>IDEA项目创建成功后, 看一眼设置</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716104702.png" alt=""></p>
<p>到这里, Maven在IDEA中的配置就完成了</p>
<h2 id="创建一个普通的Maven项目"><a href="#创建一个普通的Maven项目" class="headerlink" title="创建一个普通的Maven项目"></a>创建一个普通的Maven项目</h2><p>这次不勾选模板</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716105926.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716111928.png" alt=""></p>
<p>一个干净的Maven项目</p>
<h2 id="标记文件夹功能"><a href="#标记文件夹功能" class="headerlink" title="标记文件夹功能"></a>标记文件夹功能</h2><p>Maven项目中每个目录都有各自的作用, 如果单纯新建一个空目录是不能新建Class类文件的, 做法是将新建的目录标记为特定的类型:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716112439.png" alt=""></p>
<h2 id="在IDEA中配置TOMCAT"><a href="#在IDEA中配置TOMCAT" class="headerlink" title="在IDEA中配置TOMCAT"></a>在IDEA中配置TOMCAT</h2><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716135757.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716135843.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716140906.png" alt=""></p>
<p>因为新建的WEB项目中的web.xml文件初试版本号与本地版本号不一致, 所以需要去看一下.</p>
<p>IDEA默认初试为2.3, 打开以下地址:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\tomcat\apache-tomcat-8.0.50\webapps\ROOT\WEB-INF</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment">  contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment">  this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment">  The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment">  (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment">  the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  limitations under the License.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">"3.1"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Welcome to Tomcat<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">     Welcome to Tomcat</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到是3.1的版本, 直接全部复制, 把IDEA中的web.xml文件替换掉.</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716152626.png" alt=""></p>
<p>配置好之后就可以正常启动Tomcat服务器了. 网址中端口号之后的字符就是自定义的项目映射地址</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716140245.png" alt=""></p>
<h2 id="Maven部件"><a href="#Maven部件" class="headerlink" title="Maven部件"></a>Maven部件</h2><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716141521.png" alt=""></p>
<h2 id="porm文件"><a href="#porm文件" class="headerlink" title="porm文件"></a>porm文件</h2><p>porm.xml是Maven的核心配置文件</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716154947.png" alt=""></p>
<p>需要什么包, 直接去Maven仓库里搜索, 然后将依赖语句添加到这里即可</p>
<h1 id="更多Maven讲解"><a href="#更多Maven讲解" class="headerlink" title="更多Maven讲解"></a>更多Maven讲解</h1><ol>
<li>构建一个普通的Maven项目, 删掉里面的<code>src</code>目录, 这个空工程就是Maven主工程, 往里创建<code>Moudel</code>即可. </li>
<li>新建一个servlet子模块, 会有父模块的选项</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716185339.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716185653.png" alt=""></p>
<p>​        可以看到列表中多了一个Maven模块    </p>
<ol start="3">
<li><p>关于Maven父子工程的理解:</p>
<ul>
<li>每创建一个子模块, 都会自带一个porm.xml文件</li>
<li>在父项目的porm.xml文件中会多出</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>servlet01<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在子项目的porm.xml文件中有</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-learning04<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>父项目的jar包子项目可以直接使用</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>javaweb小记</title>
    <url>/2020/07/05/JavaWeb%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h2><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li><p>编写一个类去实现Filter接口</p>
</li>
<li><p>实现过滤方法doFilter()</p>
</li>
<li><p>到web.xml中去配置Filter的拦截路径</p>
</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li><p>构造器方法</p>
</li>
<li><p>init 初始化方法</p>
<p> 第1,2步, 在web工程启动的时候执行(Filter已经创建)</p>
</li>
<li><p>doFilter 过滤方法</p>
<p> 第3步, 每次拦截到请求就会执行</p>
</li>
<li><p>destroy 销毁</p>
<p> 第4步, 停止web工程的时候,就会执行(停止web工程, 也会销毁Filter过滤器)</p>
</li>
</ol>
<h3 id="FilterConfig类"><a href="#FilterConfig类" class="headerlink" title="FilterConfig类"></a>FilterConfig类</h3><p>见名知义, 它是Filter过滤器的配置文件类</p>
<p>Tomcat 每次创建Filter的时候, 也会同时创建一个FilterConfig类, 这里包含了Filter配置文件的配置信息</p>
<p>FilterConfig类的作用是获取Filter过滤器的配置内容:</p>
<ol>
<li>获取Filter的名称 <code>filter-name</code>的内容</li>
</ol>
<pre><code>就是xml文件中`filter-name`的值</code></pre><ol>
<li><p>获取在Filter中配置的<code>init-param</code>初始化参数</p>
<p>  就是xml文件中自定义的’init-param’初始化参数</p>
</li>
<li><p>获取<code>ServletContext</code>对象</p>
<p> 获取ServletContext对象</p>
</li>
</ol>
<h3 id="FilterChain过滤器链"><a href="#FilterChain过滤器链" class="headerlink" title="FilterChain过滤器链"></a>FilterChain过滤器链</h3><p>  Filter:   过滤器</p>
<p>  Chain:   链, 链条</p>
<p>  FilterChain:   就是过滤器链(多个过滤器如何一起工作)</p>
<p>程序执行顺序:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/46a8eb9c7e647c684c0b92d098727b9b.png" alt=""></p>
<h3 id="Filter的拦截路径"><a href="#Filter的拦截路径" class="headerlink" title="Filter的拦截路径"></a>Filter的拦截路径</h3><ol>
<li>精确匹配</li>
</ol>
<pre><code>&lt;url-pattern&gt;/target.jsp&lt;/url-pattern&gt;

以上配置的路径, 表示请求地址必须为: http://ip:port/工程路径/target.jsp</code></pre><ol start="2">
<li><p>目录匹配</p>
<p> <url-pattern>/admin/*</url-pattern></p>
<p> 以上配置的路径, 表示请求地址必须为: <a href="http://ip:port/工程路径/admin/">http://ip:port/工程路径/admin/</a>*</p>
</li>
<li><p>后缀名匹配</p>
<p> <url-pattern>*.html</url-pattern></p>
<p> 以上配置的路径, 表示请求地址必须以 .html结尾才会拦截到</p>
</li>
</ol>
<p>Filter过滤器只关心请求的地址是否匹配,不关心请求的资源是否存在</p>
<h2 id="ThreadLocal-的使用"><a href="#ThreadLocal-的使用" class="headerlink" title="ThreadLocal 的使用"></a>ThreadLocal 的使用</h2><p>  ThreaLocal 的作用,它可以解决多线程的数据安全问题</p>
<p>  ThreaLocal 它可以给当前线程关联一个数据(可以是普通变量,可以是对象,也可以是数组,集合)</p>
<h3 id="ThreadLocal-的特点"><a href="#ThreadLocal-的特点" class="headerlink" title="ThreadLocal 的特点"></a>ThreadLocal 的特点</h3><ol>
<li><p>ThreadLocal 可以为当前线程关联一个数据. (它可以像Map一样存取数据, Key为当前线程)</p>
</li>
<li><p>每一个ThreadLocal对象, 只能为当前线程关联一个数据, 如果要为当前线程关联多个数据, 就需要使用多ThreadLocal对象实例</p>
</li>
<li><p>每个ThreadLocal对象实例定义的时候, 一般都是static 类型</p>
</li>
<li><p>ThreadLocal中保存的数据, 在线程销毁后.  会由JVM虚拟机自动释放.</p>
</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/0eaee7d2aeea706e84a7691e49a43806.png" alt=""></p>
<p>*<em>使用Filter过滤器统一给所有的 Service 方法都加上try-catch *</em></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3e75caf50d4eb4d75addbe3f17244f61.png" alt=""></p>
<p><strong>将所有异常都统一交给Tomcat，让Tomcat展示友好的错误信息页面</strong></p>
<p>在web.xml中我们可以通过错误页面配置来进行管理。</p>
<error-page>

</error-page>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是一种轻量级的数据交换格式。易于人阅读和编写，同时也易于机器解析和生成。JSON采用完全独立于语言的文本格式，而且很多语言都提供了对JSON的支持。</p>
<p>JSON是一种轻量级的数据交换格式, 轻量级指的是跟xml做比较.</p>
<p>数据交换指的是客户端和服务器之间业务数据的传递格式.</p>
<h3 id="JSON的定义"><a href="#JSON的定义" class="headerlink" title="JSON的定义"></a>JSON的定义</h3><p>JSON是由键值对组成, 并且由大括号包围, 每个键用引号引起来, 键和值之间使用冒号进行分隔, 多组键值对之间使用逗号进行分隔.</p>
<h3 id="JSON的访问"><a href="#JSON的访问" class="headerlink" title="JSON的访问"></a>JSON的访问</h3><p>json本身是一个对象, json中的key我们可以理解为是对象中的一个属性, json中的key 访问就跟访问对象的属性一样: json对象.key</p>
<h3 id="JSON-在-JAVA-中的应用"><a href="#JSON-在-JAVA-中的应用" class="headerlink" title="JSON 在 JAVA 中的应用"></a>JSON 在 JAVA 中的应用</h3><h4 id="javabean-和-json-的互转"><a href="#javabean-和-json-的互转" class="headerlink" title="javabean 和 json 的互转"></a>javabean 和 json 的互转</h4><ol>
<li><p>自定义一个<code>Javabean</code>, 创建一个示例对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"aaa!"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>Gson</code>对象, 并使用<code>toJson</code>方法将<code>person</code>对象转换成<code>json</code>对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">String personJsonString = gson.toJson(person);</span><br><span class="line">System.out.println(personJsonString);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704165732.png" alt=""></p>
</li>
<li><p>同样可以将字符串转换回<code>Person</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fromJson把json字符串转换回Java对象</span></span><br><span class="line"><span class="comment">// 第一个参数是json字符串</span></span><br><span class="line"><span class="comment">// 第二个参数是转换回去的Java对象</span></span><br><span class="line">Person person1 = gson.fromJson(personJsonString, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(person1);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
</li>
</ol>
<p>   <img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704165738.png" alt=""></p>
<p>   可以看出格式是使用了<code>Person</code>类的<code>toString</code>格式, 说明已经转回.</p>
<h4 id="List-和-json-的互传"><a href="#List-和-json-的互传" class="headerlink" title="List 和 json 的互传"></a>List 和 json 的互传</h4><ol>
<li><p>还是使用<code>Person</code>类,  定义多个示例对象放入<code>List</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"cx"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>Gson</code>对象, 依然使用<code>toJson</code>的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">String personListJsonString = gson.toJson(personList);</span><br><span class="line">System.out.println(personListJsonString);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704165836.png" alt=""></p>
</li>
<li><p>转回<code>Person</code>列表时, 还是使用<code>fromJson</code>方法, 但是第二个形参需要注意, <strong>不是</strong><code>personList.getClass()</code>, 那该将什么作为列表的格式呢.</p>
<blockquote>
<p>gson包自带了一个<code>TypeToken</code>类, 使用这个类可以解决困惑</p>
<ol>
<li><p>首先创建一个新的类<code>PersonListType</code>, 然后继承<code>TypeToken</code>类, 注意填入的泛型为需要转回的类型:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704164430.png" alt=""></p>
<p>这个类放在这里就可以了.</p>
</li>
<li><p>我们去看一下<code>TypeTokken</code>的源码, 可以看到一个关键的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法返回的就是我们所需要的格式, 因为是继承了这个类, 直接使用就可以了. 这样就解决了<code>fromJson()</code>方法中第二个形参写什么的问题.</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; list = gson.fromJson(personListJsonString, <span class="keyword">new</span> PersonListType().getType());</span><br><span class="line">        System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704165843.png" alt=""></p>
</li>
</ol>
<h4 id="Map-和-json-的互转"><a href="#Map-和-json-的互转" class="headerlink" title="Map 和 json 的互转"></a>Map 和 json 的互转</h4><ol>
<li><p>创建哈希表, 然后将<code>Person</code>示例对象添加进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Person&gt; personMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">personMap.put(<span class="number">1</span>, <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>));</span><br><span class="line">personMap.put(<span class="number">2</span>, <span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"cx"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>Gson</code>对象, 使用<code>toJson</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">String personMapJsonString = gson.toJson(personMap);</span><br><span class="line">System.out.println(personMapJsonString);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704171016.png" alt=""></p>
<p>这里就要注意与<code>List</code>互换的区别了. <code>List</code>转换成<code>json</code>对象时, 是将多个<code>json</code>对象放到一个列表中, 而<code>Map</code>转过去之后, 变成了嵌套的形式. </p>
</li>
<li><p>转回<code>Map</code>形式, 方法与上面类似, 也是定义一个继承<code>TypeToken</code>的类, 然后将其放入<code>fromJson</code>方法的第二个形参中.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Person&gt; map = gson.fromJson(personMapJsonString, <span class="keyword">new</span> PersonMapType().getType());</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704182530.png" alt=""></p>
</li>
</ol>
<h4 id="使用匿名内部类进行代码优化"><a href="#使用匿名内部类进行代码优化" class="headerlink" title="使用匿名内部类进行代码优化"></a>使用匿名内部类进行代码优化</h4><p>在与<code>List</code>和<code>Map</code>结构进行互换时, 都有专门定义一个类, 但都只是在声明时使用了一次, 所以可以使用匿名内部类来优化代码.以转回<code>Map</code>为例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Person&gt; map = gson.fromJson(personMapJsonString, <span class="keyword">new</span> TypeToken&lt;HashMap&lt;Integer, Person&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<h3 id="JSON-vs-XML"><a href="#JSON-vs-XML" class="headerlink" title="JSON vs XML"></a>JSON vs XML</h3><p>JSON 和 XML 都用于接收 web 服务端的数据, 在写法上有所不同</p>
<p>Json实例:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sites"</span>: [</span><br><span class="line">    &#123; <span class="attr">"name"</span>:<span class="string">"github"</span> , <span class="attr">"url"</span>:<span class="string">"www.github.com"</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">"name"</span>:<span class="string">"google"</span> , <span class="attr">"url"</span>:<span class="string">"www.google.com"</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">"name"</span>:<span class="string">"微博"</span> , <span class="attr">"url"</span>:<span class="string">"www.weibo.com"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML实例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sites</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>github<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.runoob.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>google<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.google.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>微博<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.weibo.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sites</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>两者的相同之处:</p>
<ul>
<li>JSON 和 XML 数据都是 “自我描述” ，都易于理解。</li>
<li>JSON 和 XML 数据都是有层次的结构</li>
<li>JSON 和 XML 数据可以被大多数编程语言使用</li>
</ul>
<p>两者不同之处:</p>
<ul>
<li>JSON 不需要结束标签</li>
<li>JSON 更加简短</li>
<li>JSON 读写速度更快</li>
<li>JSON 可以使用数组</li>
</ul>
<p>最大的不同之处:</p>
<p>XML 需要使用 XML 解析器来解析，JSON 可以使用标准的 JavaScript 函数来解析。</p>
<ul>
<li><p><code>JSON.parse()</code>: 将一个 JSON 字符串转换为 JavaScript 对象。</p>
</li>
<li><p><code>JSON.stringify()</code>: 于将 JavaScript 值转换为 JSON 字符串。</p>
</li>
</ul>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="AJAX定义"><a href="#AJAX定义" class="headerlink" title="AJAX定义"></a>AJAX定义</h3><p>AJAX即”Asynchronous Javascript And XML”(异步 JavaScript和XML), 是指一种创建交互式网页应用的网页开发技术.</p>
<p><strong>AJAX是一种浏览器通过js异步发起请求, 局部更新页面的技术</strong></p>
<p>异步请求能大大提升用户体验, 不同请求各自响应, 不需要排队等候</p>
<p>AJAX请求局部更新, 浏览器地址栏不会发生变化, 局部更新不会舍弃原来页面的内容</p>
<h3 id="原生AJAX实例"><a href="#原生AJAX实例" class="headerlink" title="原生AJAX实例"></a>原生AJAX实例</h3><ol>
<li><p>编写<code>AjaxServlet</code>类, 让它继承<code>BaseServlet</code>类。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705114824.png" alt=""></p>
<p>然后在<code>web.xml</code>文件中修改配置</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705115150.png" alt=""></p>
</li>
<li><p>在<code>ajax.html</code>页面中编写js代码设置<code>ajax</code>请求, 这里要用到<code>.open()</code>方法, 然后用<code>.send()</code>方法来发送请求.注释中写明了具体的步骤.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"cache-control"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Expires"</span> <span class="attr">content</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 在这里使用JavaScript语言发起Ajax请求, 访问服务器AjaxServlet中的javaScriptAjax</span></span></span><br><span class="line"><span class="actionscript">			<span class="function"><span class="keyword">function</span> <span class="title">ajaxRequest</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 				1、我们首先要创建XMLHttpRequest </span></span></span><br><span class="line"><span class="actionscript">				<span class="keyword">var</span> xmlhttprequest = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 				2、调用open方法设置请求参数</span></span></span><br><span class="line"><span class="actionscript">				xmlhttprequest.open(<span class="string">"Get"</span>, <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet?action=javaScriptAjax"</span>, <span class="literal">true</span>)</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 				3、调用send方法发送请求</span></span></span><br><span class="line">				xmlhttprequest.send();</span><br><span class="line"><span class="actionscript"><span class="comment">// 				4、在send方法前绑定onreadystatechange事件，处理请求完成后的操作。</span></span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>	</span><br><span class="line">		<span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"ajaxRequest()"</span>&gt;</span>ajax request<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div01"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>AjaxServlet</code>中编写请求处理方法. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">javaScriptAjax</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ajax请求过来了"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>点击<code>html</code>页面的请求按钮之后, 控制台输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705141743.png" alt=""></p>
<p>说明能够正确接收到网页发送的<code>ajax</code>请求.</p>
</li>
<li><p>向客户端发送信息, 采用<code>json</code>字符串的形式. 如果需要获取来自服务器的相应, 使用<code>XMLHttpRequest</code>对象的<code>responseText</code>或<code>responseXML</code>属性.</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>responseText</td>
<td>获得字符串形式的响应数据</td>
</tr>
<tr>
<td>responseXML</td>
<td>获得XML形式的响应数据</td>
</tr>
</tbody></table>
<p>当请求被发送到服务器时, 需要执行一些基于响应的任务. 每当<code>readyState</code>改变时, 就会触发<code>onreadystatechange</code>事件.</p>
<p><code>readyState</code>属性存有<code>XMLHttpRequest</code>的状态信息</p>
<p>下面是<code>XMLHttpRequest</code>对象的三个重要属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>onreadystatechange</td>
<td>存储函数(或函数名), 每当readyState属性改变时, 就会调用该函数</td>
</tr>
<tr>
<td>readyState</td>
<td>存有XMLHttpRequest的状态.从0到4发生变化</td>
</tr>
<tr>
<td>status</td>
<td>200:”OK”, 404:”未找到页面”</td>
</tr>
</tbody></table>
<p>其中<code>readyState</code>的值表达的含义为:</p>
<ul>
<li>0: 请求未初始化</li>
<li>1: 服务器连接已建立</li>
<li>2: 请求已接收</li>
<li>3: 请求处理中</li>
<li>4: 请求已完成, 且响应已就绪</li>
</ul>
<p>也就是说我们从客户端向服务器发送了请求, 服务器处理完成后发出了响应, 这个过程中都伴随着这三个属性的变化. </p>
<p>对服务器响应所执行的任务我们写在<code>onreadystatechange</code>事件中, 这里理所应当地添加上状态已就绪的条件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttprequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (xmlhttprequest.readyState == <span class="number">4</span> &amp;&amp; xmlhttprequest.status == <span class="number">200</span>) &#123;</span><br><span class="line">                    alert(xmlhttprequest.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是, <code>onreadystatechange</code>事件要在<code>send()</code>方法之前绑定.</p>
<p>这里传给客户端的信息为一个<code>Person</code>实例, 在<code>AjaxServlet</code>程序中编写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">javaScriptAjax</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ajax请求过来了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line">        </span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>页面输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705150355.png" alt=""></p>
<p>把返回的数据显示在页面上:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttprequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (xmlhttprequest.readyState == <span class="number">4</span> &amp;&amp; xmlhttprequest.status == <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="built_in">document</span>.getElementById(<span class="string">"div01"</span>).innerHTML = xmlhttprequest.responseText;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>页面为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705150625.png" alt=""></p>
<p>对返回的<code>json</code>对象进行操作, 提取对象中的值:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttprequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (xmlhttprequest.readyState == <span class="number">4</span> &amp;&amp; xmlhttprequest.status == <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="keyword">let</span> jsonObj = <span class="built_in">JSON</span>.parse(xmlhttprequest.responseText);</span><br><span class="line">                    <span class="built_in">document</span>.getElementById(<span class="string">"div01"</span>).innerHTML = <span class="string">"编号: "</span>+ jsonObj.id + <span class="string">", 姓名: "</span>+ jsonObj.name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>页面为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705151411.png" alt=""></p>
</li>
</ol>
<h3 id="jQuery-中的-AJAX-请求"><a href="#jQuery-中的-AJAX-请求" class="headerlink" title="jQuery 中的 AJAX 请求"></a>jQuery 中的 AJAX 请求</h3><p>一般不会写原生的AJAX请求, 更多的是依托与框架.</p>
<h4 id="ajax-方法"><a href="#ajax-方法" class="headerlink" title="$.ajax 方法"></a><code>$.ajax</code> 方法</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>表示请求的地址</td>
</tr>
<tr>
<td>type</td>
<td>表示请求的类型GET或POST</td>
</tr>
<tr>
<td>data</td>
<td>表示发送给服务器的数据</td>
</tr>
<tr>
<td>success</td>
<td>请求响应, 响应的回调函数</td>
</tr>
<tr>
<td>dataType</td>
<td>响应的数据类型, 常用的类型有: text 表示纯文本, xml 表示xml数据 , json 表示json对象</td>
</tr>
</tbody></table>
<p>在<code>html</code> 页面中添加相应的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax请求</span></span><br><span class="line">            $(<span class="string">"#ajaxBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url: <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet"</span>,</span><br><span class="line">                    data: <span class="string">"action=jQueryAjax"</span>,</span><br><span class="line">                    type: <span class="string">"GET"</span>,</span><br><span class="line">                    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        alert(<span class="string">"服务器返回的数据是: "</span> + data);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    dataType: <span class="string">"text"</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>success</code> 后跟的<code>function</code> 括号中要写入服务器返回的数据. </p>
<p>在<code>AjaxServlet</code> 类中编写请求处理方法, 为了区别于上面的原生<code>AJAX</code>实例, 再写一个<code>jQueryAjax</code> 方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQueryAjax</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQueryAjax == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705160736.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705161352.png" alt=""></p>
<p>依然是对返回的<code>JSON</code> 字符串进行操作, 使它显示得更直观.</p>
<p>在页面中合适的地方添加<code>&lt;div&gt;&lt;/div&gt;</code>块, 然后修改<code>success</code> 属性:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// alert("服务器返回的数据是: " + data);</span></span><br><span class="line">                        <span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">                        $(<span class="string">"msg"</span>).html(<span class="string">"编号: "</span> + jsonObj.id + <span class="string">" , 姓名:"</span> + jsonObj.name);</span><br><span class="line">                    &#125;,</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705162117.png" alt=""></p>
<p><strong>如果<code>dataType</code> 属性填的是<code>json</code>, 会自动转为<code>json</code> 对象, 不需要再手动转换.</strong></p>
<h4 id="get-方法和-post-方法"><a href="#get-方法和-post-方法" class="headerlink" title="$.get 方法和 $.post 方法"></a><code>$.get</code> 方法和 <code>$.post</code> 方法</h4><blockquote>
<p>这两个方法本质就是把上面的方法中的<code>type</code> 属性固定下来</p>
</blockquote>
<p><strong>$.get方法</strong></p>
<p>通过远程 HTTP GET 请求载入信息</p>
<p>这是一个简单的GET请求功能以取代复杂的<code>$.ajax</code>. 请求成功时可调用回调函数. 如果需要在出错时执行函数, 需要使用<code>$.ajax</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>请求的地址</td>
</tr>
<tr>
<td>data</td>
<td>发送的数据</td>
</tr>
<tr>
<td>callback</td>
<td>成功的回调函数</td>
</tr>
<tr>
<td>type</td>
<td>返回的数据类型</td>
</tr>
</tbody></table>
<p>比<code>$.ajax</code> 少了<code>type</code>属性, 因为方式已经确定</p>
<p>在<code>html</code>页面中编写:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax--get请求</span></span><br><span class="line">            $(<span class="string">"#getBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// get请求</span></span><br><span class="line">                $.<span class="keyword">get</span>(</span><br><span class="line">                    "http://localhost:8080/json_ajax_i18n/ajaxServlet",</span><br><span class="line">                    "action=jQueryGet",</span><br><span class="line">                    function (data) &#123;</span><br><span class="line">                        <span class="comment">// alert("服务器返回的数据是: " + data);</span></span><br><span class="line">                        $(<span class="string">"#msg"</span>).html(<span class="string">"get 编号: "</span> + data.id + <span class="string">" , 姓名:"</span> + data.name);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"json"</span></span><br><span class="line">                );</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>在<code>AjaxServlet</code>类中编写<code>get</code> 请求处理方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQueryGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQueryGet == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705165624.png" alt=""></p>
<p><strong>$.post</strong>方法</p>
<p>函数调用的属性与<code>get</code>一模一样, 直接贴出代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax--post请求</span></span><br><span class="line">            $(<span class="string">"#postBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// post请求</span></span><br><span class="line">                $.post(</span><br><span class="line">                    <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet"</span>,</span><br><span class="line">                    <span class="string">"action=jQueryPost"</span>,</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// alert("服务器返回的数据是: " + data);</span></span><br><span class="line">                        $(<span class="string">"#msg"</span>).html(<span class="string">"post 编号: "</span> + data.id + <span class="string">" , 姓名:"</span> + data.name);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"json"</span></span><br><span class="line">                );</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQueryPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQueryPost == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705165818.png" alt=""></p>
<h4 id="getJSON-方法"><a href="#getJSON-方法" class="headerlink" title="$.getJSON 方法"></a><code>$.getJSON</code> 方法</h4><p>通过 GET 请求载入 JSON 数据</p>
<blockquote>
<p>本质上就是<code>$.get</code> 方法中的<code>dataType</code>属性被固定成<code>json</code> </p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>请求的地址</td>
</tr>
<tr>
<td>data</td>
<td>发送的数据</td>
</tr>
<tr>
<td>callback</td>
<td>成功的回调函数</td>
</tr>
</tbody></table>
<p>直接贴代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax--getJson请求</span></span><br><span class="line">            $(<span class="string">"#getJSONBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 调用</span></span><br><span class="line">                $.getJSON(</span><br><span class="line">                    <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet"</span>,</span><br><span class="line">                    <span class="string">"action=jQueryGetJson"</span>,</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// alert("服务器返回的数据是: " + data);</span></span><br><span class="line">                        $(<span class="string">"#msg"</span>).html(<span class="string">"getJson 编号: "</span> + data.id + <span class="string">" , 姓名:"</span> + data.name);</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQueryGetJson</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQueryGetJson == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705211905.png" alt=""></p>
<h4 id="serialize-方法"><a href="#serialize-方法" class="headerlink" title="serialize()方法"></a><code>serialize()</code>方法</h4><p>可以把表单中所有表单项的内容都获取到, 并以 name=value&amp;name=value 的形式进行拼接.</p>
<p>首先创建一个表单:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form01"</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    下拉单选：<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"single"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Single"</span>&gt;</span>Single<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Single2"</span>&gt;</span>Single2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    下拉多选：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"multiple"</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span> <span class="attr">value</span>=<span class="string">"Multiple"</span>&gt;</span>Multiple<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Multiple2"</span>&gt;</span>Multiple2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span> <span class="attr">value</span>=<span class="string">"Multiple3"</span>&gt;</span>Multiple3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    复选：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"check"</span> <span class="attr">value</span>=<span class="string">"check1"</span>/&gt;</span> check1</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"check"</span> <span class="attr">value</span>=<span class="string">"check2"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span> check2<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    单选：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"radio1"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span> radio1</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"radio2"</span>/&gt;</span> radio2<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit"</span>&gt;</span>提交--serialize()<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表单效果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705212249.png" alt=""></p>
<p>之前的做法是将整个表单都提交, 现在只需要提交键值即可.</p>
<p>在按钮的单击事件中添加:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert($(<span class="string">"#form01"</span>).serialize());</span><br></pre></td></tr></table></figure>

<p>然后随便填写表单, 输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705213127.png" alt=""></p>
<p>已经获取参数并拼接好.</p>
<p>修改客户端代码将所有参数都发给服务器:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.getJSON(</span><br><span class="line">                    <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet"</span>,</span><br><span class="line">                    <span class="string">"action=jQuerySerialize&amp;"</span> + $(<span class="string">"#form01"</span>).serialize(),</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        $(<span class="string">"#msg"</span>).html(<span class="string">"jQuerySerialize 编号: "</span> + data.id + <span class="string">" , 姓名:"</span> + data.name);</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br></pre></td></tr></table></figure>

<p>然后在服务器端接收:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQuerySerialize</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQuerySerialize == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"用户名: "</span> + req.getParameter(<span class="string">"username"</span>));</span><br><span class="line">        System.out.println(<span class="string">"密码: "</span> + req.getParameter(<span class="string">"password"</span>));</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>随便填写表单, 输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705214305.png" alt=""></p>
<h2 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h2><p>国际化三要素:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705231026.png" alt=""></p>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
        <tag>Filter</tag>
        <tag>Json</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>Java拾遗</title>
    <url>/2020/07/07/Java%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 语言基础中知识点繁多, 大多数只是在第一次学习时有印象, 但是因为长时间没有运用到会遗忘, 这篇博文就用来记录和总结遇到的生僻的知识点.</p>
<hr>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><code>abstract</code> 修饰符可以用来修饰方法, 也可以用来修饰类, 如果修饰方法, 那么该方法就是抽象方法; 如果修饰类, 那么该类就是抽象类.</p>
<ul>
<li>不能<code>new</code> 抽象类, 只能靠子类去实现它</li>
<li>抽象类中可以写普通方法</li>
<li>抽象方法必须在抽象类中</li>
</ul>
<hr>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>在接口中定义的常量会默认加上修饰符 <code>public static final</code>, 在实现了该接口的类中可以直接拿来用</li>
<li>在接口中定义的方法会默认加上修饰符 <code>pubilc abstract</code> </li>
<li>接口中没有构造方法, 这是不能被实例化的原因</li>
</ul>
<hr>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义以下的类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是外部类的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"这是内部类的方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个类中分别定义了各自的方法. 然后实例化外部类的对象, 对该类进行测试.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br><span class="line">        inner.in();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就要注意 <code>new</code> 内部类对象时写法上的区别了.</p>
<p>可以通过定义内部类的方法来获取外部类的私有属性, 修改外部类如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是外部类的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"这是内部类的方法"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过内部类的对象调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br><span class="line">        inner.in();</span><br><span class="line">        inner.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200707193414.png" alt=""></p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>在定义内部类时添加 <code>statc</code> 关键字即可. </p>
<p>因为创建内部类的方式与调用方法的步骤与成员内部类相同, 所以就不再赘述.</p>
<p>但是需要注意的是, 静态内部类是随外部类加载时创建的, 所以<strong>不能调用成员变量</strong>.</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>在外部类的方法中定义的类叫局部内部类.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"这是内部类的方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200707200724.png" alt=""></p>
<p><strong>Error</strong>:</p>
<p>通常是灾难性的致命的错误, 是程序员无法控制和处理的, 当出现这些异常时, JVM一般会终止线程</p>
<p><strong>Exception</strong>:</p>
<p>通常情况下是可以被程序处理, 并且在程序中应该尽可能的去处理这些异常</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>主动抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Demo01().test(a, b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(); <span class="comment">// 主动抛出异常, 一般在方法中使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>假设方法中处理不了这个异常, 直接在方法上抛出, 使用<code>throws</code> 关键字, 然后调用该方法时用<code>try-catch</code> 捕获处理</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>使用<code>try-catch</code>捕获异常并处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Demo01().test(a, b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"运算失败, 除数为0"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"调用结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> ArithmeticException</span>&#123;</span><br><span class="line">        System.out.println(a/b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运算失败, 除数为0</span><br><span class="line">调用结束</span><br></pre></td></tr></table></figure>

<h3 id="异常处理五个关键字"><a href="#异常处理五个关键字" class="headerlink" title="异常处理五个关键字"></a>异常处理五个关键字</h3><p><strong>try, catch, throw, throws, finally</strong></p>
<p>先看<code>try</code> , <code>catch</code>, <code>finally</code> 关键字的常见用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;   <span class="comment">// try监控区域</span></span><br><span class="line">        System.out.println(a / b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">// catch(想要捕获的异常类型)捕获异常</span></span><br><span class="line">        System.out.println(<span class="string">"程序出现异常, 变量b不能为0"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 处理善后工作</span></span><br><span class="line">        System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序出现异常, 变量b不能为0</span><br><span class="line">finally</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是<code>finally</code>, 不管是否能捕获到异常, 都会执行该代码块, 属于善后工作, 也可以不要</p>
<p>可以写多个<code>catch</code> 进行捕获, 如果要写多个的话,小的异常写上面, 层层递进, 大的写上面就给覆盖掉了</p>
<p><code>thow</code>和<code>throws</code> 的区别在于, 前者为方法中主动抛出异常, 后者是该方法中处理不了让调用该方法的方法通过<code>try-catch</code>处理.</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>创建自定义异常要继承<code>Exception</code> 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递数字 &gt; 10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detail = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toString: 异常的打印信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MyException&#123;"</span> + detail + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用该异常:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可能会存在异常的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"传递的参数为: "</span> + a);</span><br><span class="line">        <span class="keyword">if</span> (a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(a);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传递的参数为: 11</span><br><span class="line">MyException&#123;11&#125;</span><br></pre></td></tr></table></figure>



<p>在这段代码中, 判断<code>a&gt;10</code> 的时候抛出我们所定义的异常, 这里有两种处理方式, 一是在该方法中<code>try-catch</code> 进行异常的处理, 或者在方法层面抛出, 让该方法的调用者去<code>try-catch</code> 去处理. 这里采用的是第二种处理方法.</p>
<p>总之, 只要抛出了异常, 要么就地处理, 要么抛出去谁调用谁处理, 总是要还的.</p>
<p>以下是就地处理的代码和结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可能会存在异常的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"传递的参数为: "</span> + a);</span><br><span class="line">        <span class="keyword">if</span> (a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MyException(a);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传递的参数为: 11</span><br><span class="line">MyException&#123;11&#125;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p><strong>要注意输出的结果是不一样的!!</strong></p>
<hr>
<h2 id="类加载器与构造器的调用顺序"><a href="#类加载器与构造器的调用顺序" class="headerlink" title="类加载器与构造器的调用顺序"></a>类加载器与构造器的调用顺序</h2><p>今天遇到一个考察继承的题目, 牵涉到类加载器和构造器调用顺序的问题, 很有趣.</p>
<p><strong>问</strong>: new一个C02对象, 会输出什么信息?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n1 = getVal01();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"A02的一个静态代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"A02的第一个普通代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n3 = getVal02();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getVal01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal01"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal02"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A02的构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B02</span> <span class="keyword">extends</span> <span class="title">A02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n3 = getVal03();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"B02的一个静态代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n5 = getVal04();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"B02的第一个普通代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getVal03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal03"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal04"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B02的构造器"</span>);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C02</span> <span class="keyword">extends</span> <span class="title">B02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n6 = getVal06();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"C02的一个静态代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"C02的第一个普通代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n8 = getVal08();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getVal06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal06"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal08</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal08"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">C02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"C02的构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        C02 c = <span class="keyword">new</span> C02();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>:</p>
<p>这里有三个类,<code>A02</code>是父类, <code>B02</code>继承<code>A02</code>, <code>C02</code>继承<code>B02</code>. 每个类都有各自的静态代码块和无参构造器. </p>
<p>根据继承的特点可知, 当<code>new</code> 一个<code>C02</code>对象时, 会去调用<code>C02</code>的构造器, <code>C02</code>构造器第一行默认为<code>super()</code> , 即调用父类<code>B02</code>的构造器, 同理调用<code>A02</code> 的构造器, 然后顺序执行类<code>A02</code> 的代码 -&gt; <code>A02</code>构造器内的代码 -&gt; 顺序执行类<code>B02</code> 的代码 -&gt; <code>B02</code>构造器内的代码 -&gt; 顺序执行<code>C02</code> 的代码 -&gt; <code>C02</code> 构造器内的代码.</p>
<p>然而加了类构造器之后该是什么顺序呢?  直接贴结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getVal01</span><br><span class="line">A02的一个静态代码块..</span><br><span class="line">getVal03</span><br><span class="line">B02的一个静态代码块..</span><br><span class="line">getVal06</span><br><span class="line">C02的一个静态代码块..</span><br><span class="line">A02的第一个普通代码块..</span><br><span class="line">getVal02</span><br><span class="line">A02的构造器</span><br><span class="line">getVal04</span><br><span class="line">B02的第一个普通代码块..</span><br><span class="line">B02的构造器</span><br><span class="line">C02的第一个普通代码块..</span><br><span class="line">getVal08</span><br><span class="line">C02的构造器</span><br></pre></td></tr></table></figure>

<p>我们刚才分析的步骤是从第七行开始的, 后面全部严格按照分析的步骤打印信息, 所以可以得出结论: 类加载器工作的时间整体都在构造器之前.</p>
<p>不难看出, 类加载器的调用顺序与构造器是类似的, 也是从子类一路到父类, 然后再到子类. 更加严谨的调用顺序如下所述:</p>
<h3 id="类加载器调用顺序"><a href="#类加载器调用顺序" class="headerlink" title="类加载器调用顺序"></a>类加载器调用顺序</h3><p>JVM会用类加载器加载xxx.C02这个class文件</p>
<p>加载(class){</p>
<p>　　if(class有父类){</p>
<p>　　　　加载(superclass);</p>
<p>　　}</p>
<p>　　1.静态域申明,默认初始化为0,false,null</p>
<p>　　2.按照申明顺序(从上而下书写顺序)执行静态域(赋值)和静态代码块(执行代码块体),</p>
<p>　　　　二者等价,因此不可在静态代码块中<strong>使用</strong>位于代码块之后申明的静态域,但是<strong>可以初始化</strong></p>
<p>　　3.按照申明顺序加载静态方法</p>
<p>}</p>
<h3 id="构造器调用顺序"><a href="#构造器调用顺序" class="headerlink" title="构造器调用顺序"></a>构造器调用顺序</h3><ol>
<li><p>所有实例域初始化为默认值0,false,null</p>
</li>
<li><p>按照申明顺序执行域初始化及块初始化</p>
</li>
<li><p><strong>如果构造器”第一行”调用了其他构造器,则执行</strong></p>
</li>
<li><p>执行构造器体</p>
</li>
</ol>
<h3 id="方法调用顺序"><a href="#方法调用顺序" class="headerlink" title="方法调用顺序"></a>方法调用顺序</h3><ol>
<li><p>编译器查看对象的<strong>申明</strong>类型,找到它所有与方法名相同的方法</p>
</li>
<li><p>根据参数类型,找到相应”最合适”的父类方法可能会出现类型转换(向上转型)</p>
</li>
<li><p>如果是private,static,final,构造器 方法,那么已经确定就是该方法(这四种类型的方法没有多态特征),</p>
</li>
</ol>
<p>　　因为没有多态所以也叫静态绑定</p>
<ol start="4">
<li><p>如果是其他方式,采用动态绑定:JVM去寻找改类的实际类型中对应的最合适方法</p>
</li>
<li><p>执行调用</p>
</li>
</ol>
<p><strong>结合理论表述, 本题的顺序总结来说就是:</strong></p>
<ol>
<li>父类的静态代码块和静态属性(优先级一样，按定义顺序执行)</li>
<li>子类的静态代码块和静态属性(优先级一样，按定义顺序执行)</li>
<li>父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</li>
<li>子类的构造方法</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>接口</tag>
        <tag>内部类</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet原理</title>
    <url>/2020/07/16/Servlet%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>Servlet是由Web服务器调用, web服务器 (Web容器) 在收到浏览器请求之后:</p>
<ul>
<li><p>若是首次访问Servelt, 会生成<code>.class</code>文件</p>
</li>
<li><p>根据浏览器的请求生成<strong>请求(Request)</strong> 和 <strong>响应(Response)</strong></p>
</li>
<li><p>调用Servlet的<code>service()</code> 方法, 并把请求和响应传递给它</p>
<ul>
<li>我们自己编写实现类, 重写这些方法<ol>
<li>接收并处理请求</li>
<li>给出响应的信息</li>
</ol>
</li>
</ul>
</li>
<li><p>Resquest会从service拿到请求, 并且把请求之后的响应交给Response, 见下图红线流程</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200716195002.png" alt=""></p>
</li>
<li><p>最终Web容器得到响应信息, 并回传给浏览器</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Javaweb</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Queue中方法的辨析</title>
    <url>/2020/07/10/Queue%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E8%BE%A8%E6%9E%90/</url>
    <content><![CDATA[<p> java Queue中 add/offer，element/peek，remove/poll中的三个方法均为重复的方法，在选择使用时不免有所疑惑，这里简单区别一下：</p>
<h3 id="add-和offer-区别"><a href="#add-和offer-区别" class="headerlink" title="add()和offer()区别:"></a><strong>add()和offer()区别:</strong></h3><p>add()和offer()都是向队列中添加一个元素。一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。因此就可以在程序中进行有效的判断！</p>
<h3 id="poll-和remove-区别："><a href="#poll-和remove-区别：" class="headerlink" title="poll()和remove()区别："></a><strong>poll()和remove()区别：</strong></h3><p>remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。</p>
<h3 id="element-和-peek-区别："><a href="#element-和-peek-区别：" class="headerlink" title="element() 和 peek() 区别："></a><strong>element() 和 peek() 区别：</strong></h3><p>element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>jd0403.特定深度节点链表</title>
    <url>/2020/07/12/jd0403-%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E8%8A%82%E7%82%B9%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 <code>D</code>，则会创建出 <code>D</code> 个链表）。返回一个包含所有深度的链表的数组。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5,null,7,8]</span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">       &#x2F;  \ </span><br><span class="line">      2    3</span><br><span class="line">     &#x2F; \    \ </span><br><span class="line">    4   5    7</span><br><span class="line">   &#x2F;</span><br><span class="line">  8</span><br><span class="line"></span><br><span class="line">输出：[[1],[2,3],[4,5,7],[8]]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="BFS-队列"><a href="#BFS-队列" class="headerlink" title="BFS + 队列"></a>BFS + 队列</h2><p>这道题就是层序遍历, 然后将每一层的节点各自存储起来. 之前做过类似的题目, 不过这道题的不同点在于每层的节点数值用链表存储, 但是不影响层序遍历的思路.</p>
<p>做层序遍历的题目时我们会用到队列, 先进先出的特点能够正确地模拟出BFS的顺序.</p>
<p>*<em>算法流程: *</em></p>
<ol>
<li><p>*<em>初始化: *</em> 首先创建一个队列, 将根节点入队; 创建一个列表用于存放每一层的链表, 因为不知道一共有多少层, 所以最后再创建题目要求的数组.</p>
</li>
<li><p><strong>循环过程:</strong> 当队列为空时跳出循环</p>
<ol>
<li><p>每次循环时, 队列中有多少个节点, 那么就说明这一层有多少个节点, <code>int levelLength = queue.size()</code></p>
</li>
<li><p>为该层创建一个链表</p>
<ul>
<li>循环遍历该层所有节点, 将每个节点的左右子节点入队, 并存储在链表中</li>
</ul>
</li>
<li><p>将该层的链表存入列表中</p>
</li>
</ol>
</li>
<li><p>*<em>返回值: *</em> 根据列表大小创建链表数组, 将列表的元素迁移进去</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode[] listOfDepth(TreeNode tree) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ListNode[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        List&lt;ListNode&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(tree);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> levelLength = queue.size();</span><br><span class="line">            ListNode listNode = <span class="keyword">new</span> ListNode(queue.peek().val);</span><br><span class="line">            ListNode cur = listNode;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelLength; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (i!=<span class="number">0</span>)&#123;</span><br><span class="line">                    cur.next = <span class="keyword">new</span> ListNode(node.val);</span><br><span class="line">                    cur = cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(listNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> ListNode[ans.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>队列</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>jd0406.后继者</title>
    <url>/2020/07/15/jd0406-%E5%90%8E%E7%BB%A7%E8%80%85/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p>
<p>如果指定节点没有对应的“下一个”节点，则返回<code>null</code>。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [2,1,3], p &#x3D; 1</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br><span class="line"></span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], p &#x3D; 6</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   4</span><br><span class="line"> &#x2F;   </span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">输出: null</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS-迭代"><a href="#DFS-迭代" class="headerlink" title="DFS + 迭代"></a>DFS + 迭代</h2><p>题目中已经说明了是中序遍历的后继者, 所以在中序遍历的基础上进行操作</p>
<p>这里用迭代的方法完成.</p>
<p>根据二叉树的中序遍历的迭代过程可知, 每遍历完一个节点, 下面遍历到的元素一定是栈中下一个将要弹出的节点. 所以思路就是遍历的过程中如果遇到了目标节点, 就把下一个将要出栈的节点弹出即可.</p>
<p>具体的做法就是在中序遍历过程的基础上添加一个布尔变量, 初始值为<code>false</code>, 每次出栈时都检查一下是否是<code>true</code>, 若为<code>true</code>就把弹出的节点返回. 如果在遍历过程中遇到了目标节点, 就把该布尔变量变为<code>true</code>, 那么下一个节点就会返回.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == p.val) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>jd0412.求和路径</title>
    <url>/2020/07/15/jd0412-%E6%B1%82%E5%92%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>
<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>

<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS + 递归"></a>DFS + 递归</h2><p>又是一道路径求和的问题, 与剑指OFFER-34题不同的是, 本题需要返回的是满足条件的路径数量而不是具体的路径, 这是降低了难度的, 也就不需要利用回溯法计算了, 不必考虑每次递归后再回退一步.</p>
<p>直观上更偏向于采用先序遍历的方法自顶向下寻找路径. 本题有一个难点在于没有规定必须是从根节点到叶子节点才算是合法路径, 从任意节点开始到任意节点结束只要路径和等于目标值就可以. 所以每往路径里添加一个元素, 就从新添加的地方往前递加, 一旦满足条件就把结果加一.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jd0412</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dep = depth(root);</span><br><span class="line">        <span class="keyword">int</span>[] paths = <span class="keyword">new</span> <span class="keyword">int</span>[dep];</span><br><span class="line">        pathSum(root, sum, <span class="number">0</span>, paths);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> level, <span class="keyword">int</span>[] paths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        paths[level] = root.val;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            temp += paths[i];</span><br><span class="line">            <span class="keyword">if</span> (temp == sum)</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pathSum(root.left, sum, level + <span class="number">1</span>, paths);</span><br><span class="line">        pathSum(root.right, sum, level + <span class="number">1</span>, paths);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>String,StringBuffer,StringBuilder类汇总</title>
    <url>/2020/07/08/String-StringBuffer-StringBuilder%E7%B1%BB%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>字符串Java中非常重要的部分, 这里包含了大量的处理方法以及性质特点, 这篇文章对常用的String类, StringBuffer类, StringBuilder类相关知识点进行汇总.</p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="两个重要特点"><a href="#两个重要特点" class="headerlink" title="两个重要特点"></a>两个重要特点</h3><h4 id="String-常量池"><a href="#String-常量池" class="headerlink" title="String 常量池"></a>String 常量池</h4><p>常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。Java为了提高性能，静态字符串（字面量/常量/常量连接的结果）在常量池中创建，并尽量使用同一个对象，重用静态字符串。对于重复出现的字符串直接量，JVM会首先在常量池中查找，如果常量池中存在即返回该对象。</p>
<p>例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            String str1 = <span class="string">"Hello"</span>;<span class="comment">//生成了1个对象"Hello"</span></span><br><span class="line">            <span class="comment">//不会创建新的String对象，而是使用常量池中已有的"Hello"，</span></span><br><span class="line">            String str2 = <span class="string">"Hello"</span>;</span><br><span class="line">            System.out.println(str1 == str2); <span class="comment">//true</span></span><br><span class="line">            <span class="comment">//使用new关键字会创建新的String对象，不管常量池里面有没有相同的值</span></span><br><span class="line">            String str3 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);<span class="comment">//生成了2个对象"Hello"和new String("Hello")</span></span><br><span class="line">            System.out.println(str1 == str3); <span class="comment">//false </span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="String-对象不可变"><a href="#String-对象不可变" class="headerlink" title="String 对象不可变"></a>String 对象不可变</h4><p>String是常量，其对象一旦构造就不能再被改变。换句话说，<strong>String对象是不可变的</strong>，每一个看起来会修改String值的方法，实际上都是创造了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"hello"</span>;</span><br><span class="line">        String newS = StringTest02.append(s);</span><br><span class="line">        System.out.println(<span class="string">"String append---&gt;"</span> + s.toString());</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"hello"</span>);</span><br><span class="line">        StringBuilder newSb = StringTest02.append(sb);</span><br><span class="line">        System.out.println(<span class="string">"StringBuilder append---&gt;"</span> +sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">append</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s += <span class="string">"kitty"</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">append</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb.append(<span class="string">"kitty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String append---&gt;hello</span><br><span class="line">StringBuilder append---&gt;hellokitty</span><br></pre></td></tr></table></figure>

<p>由上面的例子可见StringBuilder sb的值被改变了，而String s的值没有变，所以String不可变的安全性就体现出来了</p>
<h3 id="String-类的方法"><a href="#String-类的方法" class="headerlink" title="String 类的方法"></a>String 类的方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p><strong>1、<em>public String()</em></strong><br>无参构造方法，用来创建空字符串的String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String();</span><br></pre></td></tr></table></figure>

<p><strong>2、<em>public String(String value)</em></strong><br>用已知的字符串value创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"qwer"</span>); </span><br><span class="line">String str3 = <span class="keyword">new</span> String(str2);</span><br></pre></td></tr></table></figure>

<p><strong>3、<em>public String(char[] value)</em></strong><br>用字符数组value创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">String str4 = <span class="keyword">new</span> String(value);<span class="comment">//相当于String str4 = new String("abcd");</span></span><br></pre></td></tr></table></figure>

<p><strong>4<em>、public String(char chars[], int startIndex, int numChars)</em></strong><br>用字符数组chars的startIndex开始的numChars个字符创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">String str5 = <span class="keyword">new</span> String(value, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//相当于String str5 = new String("bc");</span></span><br></pre></td></tr></table></figure>

<p><strong>5、<em>public String(byte[] values)</em></strong><br>用比特数组values创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] strb = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>&#125;;</span><br><span class="line">String str6 = <span class="keyword">new</span> String(strb);<span class="comment">//相当于String str6 = new String("ABCD");</span></span><br></pre></td></tr></table></figure>

<p><strong>6、<em>public String(byte[] values,int startIndex, int numChars)</em></strong><br>用字符数组byte的startIndex开始的numChars个字符创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] strb = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>&#125;;</span><br><span class="line">String str6 = <span class="keyword">new</span> String(strb,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//相当于String str6 = new String("A");</span></span><br></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><strong>1、<em>length()</em></strong><br>返回字该字符串的长度</p>
<p><strong>2、<em>charAt(int indext)</em></strong><br>求字符串某一位置的字符，index必须&gt;=0并且&lt;= length()-1</p>
<p><strong>3、截取字符串</strong></p>
<ul>
<li><strong><em>substring(int beginIndex)</em></strong><br>该方法从beginIndex位置起（包含这个位置）到最后截取一个字符串返回。<br><strong><em>[beginIndex,最后]</em></strong></li>
<li><strong><em>substring(int beginIndex，endIndex)</em></strong><br>该方法从beginIndex位置起（包含这个位置）到endIndex - 1截取一个字符串返回。<br><strong><em>[beginIndex,endIndex - 1]</em></strong><br>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"abcdefgkl"</span>);</span><br><span class="line">String str2 = str1.substring(<span class="number">2</span>);<span class="comment">//str2 = "cdefgkl"</span></span><br><span class="line">String str3 = str1.substring(<span class="number">2</span>,<span class="number">5</span>);<span class="comment">//str3 = "cde"</span></span><br></pre></td></tr></table></figure>

<p><strong>4、字符串比较</strong></p>
<ul>
<li><strong><em>public int compareTo(String anotherString)</em></strong><br>该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。其比较规则是：拿出字符串的第一个字符与参数的第一个字符进行比较，如果两者不等，比较结束，返回两者的ascii差。这里有一点需要注意：如果两个字符串的长度不同，并且一个字符串与另一个字符串的前面N个字符相等，那么这个方法返回返回两个字符串长度之差。</li>
<li><strong><em>public int compareToIgnore(String anotherString)</em></strong><br>与compareTo方法相似，但忽略大小写。</li>
<li><strong><em>public boolean equals(Object anotherObject)</em></strong><br>比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。</li>
<li><strong><em>public boolean equalsIgnoreCase(String anotherString)</em></strong><br>与equals方法相似，但忽略大小写。<br>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"abcd"</span>; </span><br><span class="line">String s2 = <span class="string">"abce"</span>; </span><br><span class="line">String s3 = <span class="string">"ABC"</span>; </span><br><span class="line">String s4 = <span class="string">"abcdefg"</span>; </span><br><span class="line">String s5 = <span class="string">"abc"</span>; </span><br><span class="line">System.out.println(s1.compareTo(s2)); </span><br><span class="line">System.out.println(s1.compareTo(s3)); </span><br><span class="line">System.out.println(s4.compareTo(s1)); </span><br><span class="line">System.out.println(s4.compareTo(s2)); </span><br><span class="line">System.out.println(s3.compareToIgnoreCase(s5));</span><br><span class="line">System.out.println(s3.equals(s5));</span><br><span class="line">System.out.println(s3.equalsIgnoreCase(s5));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>5、字符串连接</strong></p>
<ul>
<li><strong><em>public String concat(String str)</em></strong><br>将参数中的字符串str连接到当前字符串的后面，效果等价于”+”。</li>
</ul>
<p><strong>6、字符串中单个字符查找</strong></p>
<ul>
<li><strong><em>public int indexOf(int ch/String str)</em></strong><br>用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1。</li>
<li><strong><em>public int indexOf(int ch/String str, int fromIndex)</em></strong><br>改方法与第一种类似，区别在于该方法从fromIndex位置向后查找。</li>
<li><strong><em>public int lastIndexOf(int ch/String str)</em></strong><br>该方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找。</li>
<li><strong><em>public int lastIndexOf(int ch/String str, int fromIndex)</em></strong><br>该方法与第二种方法类似，区别于该方法从fromIndex位置向前查找。<br>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"I am a good student"</span>;</span><br><span class="line">System.out.println(str.indexOf(<span class="string">'a'</span>));</span><br><span class="line">System.out.println(str.indexOf(<span class="string">"good"</span>));</span><br><span class="line">System.out.println(str.indexOf(<span class="string">"w"</span>, <span class="number">2</span>));</span><br><span class="line">System.out.println(str.lastIndexOf(<span class="string">"a"</span>));</span><br><span class="line">System.out.println(str.lastIndexOf(<span class="string">"a"</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">7</span><br><span class="line">-1</span><br><span class="line">5</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>7、字符串中字符的大小写转换</strong></p>
<ul>
<li><strong><em>public String toLowerCase()</em></strong><br>返回将当前字符串中所有字符转换成小写后的新串</li>
<li><strong><em>public String toUpperCase()</em></strong><br>返回将当前字符串中所有字符转换成大写后的新串</li>
</ul>
<p><strong>8、字符串中字符的替换</strong></p>
<ul>
<li><strong><em>public String replace(char oldChar, char newChar)</em></strong><br>用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。</li>
<li><strong><em>public String replaceFirst(String regex, String replacement)</em></strong><br>该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。</li>
<li><strong><em>public String replaceAll(String regex, String replacement)</em></strong><br>该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。<br>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str4 = <span class="string">"asdzxcasd"</span>;</span><br><span class="line">System.out.println(str4.replace(<span class="string">'a'</span>, <span class="string">'g'</span>));</span><br><span class="line">System.out.println(str4.replace(<span class="string">"asd"</span>, <span class="string">"fgh"</span>));</span><br><span class="line">System.out.println(str4.replaceFirst(<span class="string">"asd"</span>, <span class="string">"fgh"</span>));</span><br><span class="line">System.out.println(str4.replaceAll(<span class="string">"asd"</span>, <span class="string">"fgh"</span>));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gsdzxcgsd</span><br><span class="line">fghzxcfgh</span><br><span class="line">fghzxcasd</span><br><span class="line">fghzxcfgh</span><br></pre></td></tr></table></figure>

<p><strong><em>注意：replace和preplaceAll的区别</em></strong></p>
<ol>
<li>replace的参数是char和CharSequence,即可以支持字符的替换,也支持字符串的替换(CharSequence即字符串序列的意思,说白了也就是字符串);</li>
<li>replaceAll的参数是regex,即基于规则表达式的替换,比如,可以通过replaceAll(“\d”, “*”)把一个字符串所有的数字字符都换成星号;</li>
</ol>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p><strong>1、去除首位空格</strong></p>
<ul>
<li><p><strong><em>String trim()</em></strong></p>
<p>截去字符串两端的空格，但对于中间的空格不处理。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">" a sd "</span>;</span><br><span class="line">String str1 = str.trim();</span><br><span class="line"><span class="keyword">int</span> a = str.length();<span class="comment">//a = 6</span></span><br><span class="line"><span class="keyword">int</span> b = str1.length();<span class="comment">//b = 4</span></span><br></pre></td></tr></table></figure>

<p><strong>2、确认开始或结尾字符串</strong></p>
<ul>
<li><strong><em>boolean statWith(String prefix)或boolean endWith(String suffix)</em></strong><br>用来比较当前字符串的起始字符或子字符串prefix和终止字符或子字符串suffix是否和当前字符串相同，重载方法中同时还可以指定比较的开始位置offset。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"asdfgh"</span>;</span><br><span class="line"><span class="keyword">boolean</span> a = str.statWith(<span class="string">"as"</span>);<span class="comment">//a = true</span></span><br><span class="line"><span class="keyword">boolean</span> b = str.endWith(<span class="string">"gh"</span>);<span class="comment">//b = true</span></span><br></pre></td></tr></table></figure>

<p><strong>3、包含字符串</strong></p>
<ul>
<li><strong><em>contains(String str)</em></strong><br>判断参数s是否被包含在字符串中，并返回一个布尔类型的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; &quot;student&quot;;</span><br><span class="line">str.contains(&quot;stu&quot;);&#x2F;&#x2F;true</span><br><span class="line">str.contains(&quot;ok&quot;);&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p><strong>4、分隔字符串</strong></p>
<ul>
<li><strong><em>String[] split(String str)</em></strong><br>将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"asd!qwe!zxc"</span>;</span><br><span class="line">String[] str1 = str.split(<span class="string">"!"</span>);<span class="comment">//str1[0] = "asd";str1[1] = "qwe";str1[2] = "zxc";</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串与基本类型的转换"><a href="#字符串与基本类型的转换" class="headerlink" title="字符串与基本类型的转换"></a>字符串与基本类型的转换</h4><p><strong>1、字符串转换为基本类型</strong></p>
<p>java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：</p>
<ul>
<li><p><strong><em>public static byte parseByte(String s)</em></strong></p>
</li>
<li><p><strong><em>public static short parseShort(String s)</em></strong></p>
</li>
<li><p><strong><em>public static short parseInt(String s)</em></strong></p>
</li>
<li><p><strong><em>public static long parseLong(String s)</em></strong></p>
</li>
<li><p><strong><em>public static float parseFloat(String s)</em></strong></p>
</li>
<li><p><strong><em>public static double parseDouble(String s)</em></strong></p>
<p>例如：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = Integer.parseInt(<span class="string">"12"</span>);</span><br><span class="line"><span class="keyword">float</span> f = Float.parseFloat(<span class="string">"12.34"</span>);</span><br><span class="line"><span class="keyword">double</span> d = Double.parseDouble(<span class="string">"1.124"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>2、基本类型转换为字符串类型</strong></p>
<p>String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。</p>
<ul>
<li><strong><em>static String valueOf(char data[])</em></strong></li>
<li><strong><em>static String valueOf(char data[], int offset, int count)</em></strong></li>
<li><strong><em>static String valueOf(boolean b)</em></strong></li>
<li><strong><em>static String valueOf(char c)</em></strong></li>
<li><strong><em>static String valueOf(int i)</em></strong></li>
<li><strong><em>static String valueOf(long l)</em></strong></li>
<li><strong><em>static String valueOf(float f)</em></strong></li>
<li><strong><em>static String valueOf(double d)</em></strong><br>例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = String.valueOf(<span class="number">12</span>);</span><br><span class="line">String s1 = String.valueOf(<span class="number">12.34</span>);</span><br></pre></td></tr></table></figure>

<h2 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer, StringBuilder"></a>StringBuffer, StringBuilder</h2><h3 id="共同支持的方法"><a href="#共同支持的方法" class="headerlink" title="共同支持的方法"></a>共同支持的方法</h3><ul>
<li><strong><em>public StringBuffer append(String s)</em></strong><br>将指定的字符串追加到此字符序列。</li>
<li><strong><em>public StringBuffer reverse()</em></strong><br>将此字符序列用其反转形式取代。</li>
<li><strong><em>public delete(int start, int end)</em></strong><br>移除此序列的子字符串中的字符。</li>
<li><strong><em>public insert(int offset, int i)</em></strong><br>将 int 参数的字符串表示形式插入此序列中。</li>
<li><strong><em>replace(int start, int end, String str)</em></strong><br>使用给定 String 中的字符替换此序列的子字符串中的字符。</li>
<li><strong><em>int capacity()</em></strong><br>返回当前容量</li>
<li><strong><em>void setCharAt(int index, char ch)</em></strong><br>将给定索引处的字符设置为 ch。</li>
<li><strong><em>void setLength(int newLength)</em></strong><br>设置字符序列的长度</li>
</ul>
<p><strong>在大部分情况下 StringBuilder &gt; StringBuffer</strong></p>
<p>java.lang.StringBuildejava.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>
<h3 id="三者的区别"><a href="#三者的区别" class="headerlink" title="三者的区别"></a>三者的区别</h3><p><strong>1、对象的可变与不可变</strong><br>String对象不可变，StringBuffer和StringBuilder对象可变。</p>
<p><strong>2、 线程是否安全</strong></p>
<ul>
<li>String中的对象是不可变的，也就可以理解为常量，所以线程安全。</li>
<li>StringBuffer中的方法大都采用了synchronized关键字修饰，所以是线程安全的。</li>
<li>StringBuilder没有对方法进行加同步锁，所以是非线程安全的。</li>
</ul>
<p><strong>3、 字符串追加速度比较</strong><br>StringBuilder &gt; StringBuffer &gt; String</p>
<p><strong>4、 StringBuffer和StringBuilder的共同点</strong></p>
<ul>
<li>StringBuffer和StringBuilder有公共的抽象父类AbstractStringBuilder</li>
<li>抽象类与一个接口的区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。</li>
<li>StringBuilder和StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(…)。只是StringBuffer会在方法上加上synchronized关键字，进行同步。<br>如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><em>String</em></strong>：适用于少量的字符串操作的情况<br><strong><em>StringBuilder</em></strong>：适用于单线程下在字符缓冲区进行大量操作的情况<br><strong><em>StringBuffer</em></strong>：适用于多线程下在字符缓冲区进行大量操作的情况</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title>jz27.二叉树的镜像</title>
    <url>/2020/07/09/jz27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>镜像输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>在解题之前要先了解 <strong>二叉树的镜像</strong> 是什么:</p>
<blockquote>
<p>二叉树镜像定义： 对于二叉树中任意节点<code>root</code> ，设其左 / 右子节点分别为 <code>left</code>, <code>right</code> ；则在二叉树的镜像中的对应<code>root</code>节点，其左 / 右子节点分别为 <code>right</code>, <code>left</code>。</p>
</blockquote>
<p><img src="http://qcxz71s06.bkt.clouddn.com/9ac3c2730ab2afea15e720e6e6d7ce66aa2cb8659665085e775f8fff2c5b4285-Picture1.png" alt=""></p>
<p>递归的思路很简单, 就是遍历每个节点, 交换其左右子树即可</p>
<ol>
<li><strong>终止条件:</strong> 当节点<code>root</code> 为空时, 返回<code>null</code></li>
<li><strong>递归过程:</strong><ol>
<li>初始化一个临时节点<code>temp</code> 暂存 左儿子</li>
<li>令左儿子等于右儿子</li>
<li>令右儿子等于临时节点</li>
</ol>
</li>
<li>*<em>返回值: *</em>当前的节点<code>root</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz27</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">recur</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        recur(root.left);</span><br><span class="line">        recur(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="栈遍历方法"><a href="#栈遍历方法" class="headerlink" title="栈遍历方法"></a>栈遍历方法</h2><p>利用栈或队列遍历树的所有节点, 交换每个节点的左右儿子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node.left!= <span class="keyword">null</span>)</span><br><span class="line">                stack.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>)</span><br><span class="line">                stack.add(node.right);</span><br><span class="line">            TreeNode temp = node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jd0402.最小高度树</title>
    <url>/2020/07/12/jd0402-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<p>*<em>示例: *</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">          0 </span><br><span class="line">         &#x2F; \ </span><br><span class="line">       -3   9 </span><br><span class="line">       &#x2F;   &#x2F; </span><br><span class="line">     -10  5</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="DFS-二分查找"><a href="#DFS-二分查找" class="headerlink" title="DFS + 二分查找"></a>DFS + 二分查找</h2><p>这道题给的是有序数组, 根据三个深度优先遍历的性质可知, 这是中序遍历的结果, 不过做这道题时用不到这个性质.</p>
<p>要根据有序数组创建二叉搜索树, 那么就尽量把中间的元素作为根节点, 然后把左边数组中的中间元素作为左节点, 右边数组的中间元素作为右节点, 以此往下推, 获得递归算法流程为:</p>
<ol>
<li>*<em>终止条件: *</em> 数组的长度为0, 无法创建出节点, 返回<code>null</code></li>
<li>*<em>递归过程: *</em> <ol>
<li>根据已知数组将最中间的元素作为根节点</li>
<li>把前半段的数组递归返回值作为左子节点</li>
<li>把后半段的数组递归返回值作为右子节点</li>
</ol>
</li>
<li>*<em>返回值: *</em> 根据当前数组创建的根节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode temp = <span class="keyword">new</span> TreeNode(nums[nums.length / <span class="number">2</span>]);</span><br><span class="line">    temp.left = sortedArrayToBST(Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length / <span class="number">2</span>));</span><br><span class="line">    temp.right = sortedArrayToBST(Arrays.copyOfRange(nums, nums.length / <span class="number">2</span> + <span class="number">1</span>, nums.length));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>jz07.重建二叉树</title>
    <url>/2020/07/09/jz07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   3</span><br><span class="line"> &#x2F;  \</span><br><span class="line">9   20</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    15   7</span><br></pre></td></tr></table></figure>

<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>这道题要充分用到二叉树前序遍历与中序遍历的数量关系.</p>
<p>示例中两个数组的关系进行分析可知:</p>
<blockquote>
<p><strong>前序遍历特点：</strong> 节点按照 <code>[ 根节点 | 左子树 | 右子树 ]</code> 排序，以题目示例为例：<code>[ 3 | 9 | 20 15 7 ]</code></p>
<p><strong>中序遍历特点：</strong> 节点按照 <code>[ 左子树 | 根节点 | 右子树 ]</code> 排序，以题目示例为例：<code>[ 9 | 3 | 15 20 7 ]</code></p>
</blockquote>
<p>对于根节点<code>3</code> 来说, 它排在前序遍历数组的最前面, 在中序遍历数组中找到<code>3</code> 的位置, 可以发现在它之前的元素全部属于左子树, 在它之后的元素全部属于右子树.</p>
<p>这个这个规律可以套用到所有子树中, 比如<code>20</code> 是右子树的根节点, 它在前序遍历数组中位于该子树范围中的第一位(<code>[20, 15, 7]</code>是右子树), 在中序遍历中找到<code>20</code> 的位置, 在其范围内(<code>[15, 20, 7]</code>) 左边的元素都属于新的左子树, 右边的元素都属于新的右子树. 这样就构成了递归关系.</p>
<p>所以我们的递归思路是:</p>
<ul>
<li><p><strong>递归参数:</strong> 前序遍历中根节点的索引<code>pre_root</code>、中序遍历左边界<code>in_left</code>、中序遍历右边界<code>in_right</code></p>
</li>
<li><p><strong>终止条件：</strong> 当 <code>in_left &gt; in_right</code> ，子树中序遍历为空，说明已经越过叶子节点，此时返回 <code>null</code></p>
</li>
<li><p><strong>递推工作：</strong></p>
<ol>
<li><strong>建立根节点<code>root</code></strong>： 值为前序遍历中索引为pre_root的节点值。</li>
<li><strong>搜索根节点<code>root</code>在中序遍历的索引<code>i</code>：</strong> 为了提升搜索效率，本题解使用哈希表 <code>dic</code> 预存储中序遍历的值与索引的映射关系，每次搜索的时间复杂度为 O(1)</li>
<li><strong>构建根节点<code>root</code>的左子树和右子树：</strong> 通过调用<code>recur()</code> 方法开启下一层递归。<ul>
<li>左子树： 根节点索引为<code>pre_root + 1</code> ，中序遍历的左右边界分别为 <code>in_left</code> 和<code>i - 1</code>。</li>
<li>右子树： 根节点索引为<code>i - in_left + pre_root + 1</code>（即：根节点索引 + 左子树长度 + 1），中序遍历的左右边界分别为<code>i + 1</code>和<code>in_right</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p> 判断下一次递归时子树的左右边界比较容易, 就是当前<code>i</code> 值加一或减一即可, 判断左右子树的根节点时, 左子树根节点很容易, 当前节点在前序遍历数组中的后一个元素就是左子树的根节点. 下面来分析右子树根节点如何表示:</p>
<p>我们已经知道当前树的根节点在前序遍历数组中的索引<code>pre_root</code> , 它后面紧跟着的是左子树, 所以得出左子树节点的数量就可以得到右子树根节点的索引了.我们还知道当前树根节点在中序遍历数组中的索引<code>i</code>, 以及左子树的边界<code>in_left</code> ,那么<code>i - in_left</code> 就是左子树的节点数量.  <strong>所以右子树的根节点索引为<code>i- in_left + pre_root + 1.</code></strong></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/asdf1.png" alt="">)<img src="http://qcxz71s06.bkt.clouddn.com/asgfrg2.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/ergfb3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/hq4aebdgsf4.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/qyjhg5.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/2tyesujrd6.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/2ewagrhetjy7.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/gd8.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/wertyu9.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz07</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] pre;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        pre = preorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            dic.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> pre_root, <span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in_left &gt; in_right)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = dic.get(pre[pre_root]);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[pre_root]);</span><br><span class="line"></span><br><span class="line">        root.left = recur(pre_root + <span class="number">1</span>, in_left, i - <span class="number">1</span>);</span><br><span class="line">        root.right = recur(i - in_left + pre_root + <span class="number">1</span>, i + <span class="number">1</span>, in_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jd0405.合法二叉搜索树</title>
    <url>/2020/07/12/jd0405-%E5%90%88%E6%B3%95%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>实现一个函数，检查一棵二叉树是否为二叉搜索树。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>验证是否是二叉搜索树, 我们可以根据中序遍历结果是升序数组, 所以思路就是中序遍历这棵树, 一旦发现当前节点的数值小于等于前一个数, 那么就证明不是二叉搜索树.</p>
<p>简单来说, 就是在中序遍历的基础上创建一个变量记录着前一个数值, 多一个比较的步骤. </p>
<h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS 递归"></a>DFS 递归</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isValidBST(root.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= pre) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root.val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="DFS-迭代"><a href="#DFS-迭代" class="headerlink" title="DFS 迭代"></a>DFS 迭代</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (cur.val&lt;=pre)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        pre = cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>jz28.对称的二叉树</title>
    <url>/2020/07/09/jz28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>首先要清楚对称二叉树的定义: 对于树中任意两个对称节点<code>L</code> 和 <code>R</code>, 一定有:</p>
<ul>
<li><code>L.val=R.val</code> ：即此两对称节点值相等。</li>
<li><code>L.left.val = R.right.valL.left.val=R.right.val</code> ：即 <code>L</code> 的 左子节点 和 <code>R</code>的 右子节点 对称；</li>
<li><code>L.right.val = R.left.valL.right.val=R.left.val</code> ：即 <code>L</code> 的 右子节点 和 <code>R</code> 的 左子节点 对称。</li>
</ul>
<p>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树.</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/ebf894b723530a89cc9a1fe099f36c57c584d4987b080f625b33e228c0a02bec-Picture1.png" alt=""></p>
<p>递归思路:</p>
<ol>
<li><strong>终止条件:</strong> <ul>
<li>若两个节点都为<code>null</code>, 说明之前的的节点都符合对称条件, 返回<code>true</code></li>
<li>若只有一个节点为<code>null</code>, 说明只有一个节点越过叶子节点, 不对称, 返回<code>false</code></li>
<li>若两个节点的值不相等, 返回<code>false</code>, 没什么好说的</li>
</ul>
</li>
<li>*<em>递归过程: *</em><ul>
<li>判断<code>L.left</code> 和 <code>R.right</code> 是否对称</li>
<li>判断<code>L.right</code>和<code>R.left</code>是否对称</li>
</ul>
</li>
<li>*<em>返回值: *</em> 返回值为布尔值, 将两个对称条件用<code>&amp;&amp;</code> 连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz28</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> || recur(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span> || left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(left.left, right.right) &amp;&amp; recur(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz32-Ⅱ.从上到下打印二叉树Ⅱ</title>
    <url>/2020/07/10/jz32-%E2%85%A1-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="层序遍历-BFS"><a href="#层序遍历-BFS" class="headerlink" title="层序遍历 BFS"></a>层序遍历 BFS</h2><p>这道题与同题号的第一道题都是从上到下打印每一层的节点数值, 但是这道题需要将每一层的数值单独放在一个列表里, 这就需要记录下遍历到了第几层以及每一层有多少个节点.</p>
<p>经过上一道题的遍历过程我们发现, 每次到了新的一层, 队列中存储的节点数量就是该层将要遍历的数量, 将该层的所有节点都遍历完成后就会进入下一层, 我们抓住这个性质执行以下的代码流程:</p>
<ol>
<li><p><strong>初始化:</strong></p>
<ul>
<li>创建一个队列<code>queue</code> 用来进队和出队操作, 先将<code>root</code> 根节点入队</li>
<li>初始化一个列表<code>res</code> 用来记录每一层的数值, 它就是最后要返回的列表</li>
<li>初始化一个变量<code>level = 0</code> , 用来表示当前的层数, 对应的是<code>res</code> 列表索引, 所以从0开始</li>
</ul>
</li>
<li><p><strong>循环过程:</strong> 当队列为空时跳出循环操作</p>
<ol>
<li>往<code>res</code> 中新增一个空列表用于存放本层的数值</li>
<li>创建一个变量记录本层有多少个节点, <code>int level_length = queue.size()</code></li>
<li>进入新的循环将队列中的节点全部抛出, 数值添加到列表中, 并将左右子节点入队</li>
</ol>
</li>
<li><p><strong>返回值:</strong> 返回<code>res</code> 即可</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz32_2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">            <span class="keyword">int</span> level_length = queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level_length; i++) &#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                res.get(level).add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>jz32-Ⅲ.从上到下打印二叉树Ⅲ</title>
    <url>/2020/07/10/jz32-%E2%85%A2-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E2%85%A2/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>经过前两道题的分析, 我们已经可以操控每一层的节点了, 这道题延伸出来的是层数的奇偶问题, 如果奇数层正序摆放, 偶数层逆序摆放. </p>
<p>既然经过上一道题每一层的层数我们已经记录下来了, 那就只剩摆放的问题了.</p>
<p>将每一层打印的数用双端队列存储, 那么每遍历到一层时只需要判断该层的奇偶性然后采用头部添加还是尾部添加就好了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> level_length = queue.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level_length; i++) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>) temp.addLast(node.val);</span><br><span class="line">                <span class="keyword">else</span> temp.addFirst(node.val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>jz32-Ⅰ.从上到下打印二叉树</title>
    <url>/2020/07/09/jz32-%E2%85%A0-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。</p>
<p>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/f824fdd8052ae4ee657365c98633480caf03c60e42e4661797618e318baf8664-Picture0.png" alt=""></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li><p><strong>特例处理：</strong> 当树的根节点为空，则直接返回空列表 [] ；</p>
</li>
<li><p><strong>初始化：</strong> 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root]</code> ；</p>
</li>
<li><p><strong>BFS 循环：</strong> 当队列 <code>queue</code> 为空时跳出；</p>
<ol>
<li><strong>出队：</strong> 队首元素出队，记为 <code>node</code>；</li>
<li><strong>打印：</strong> 将 <code>node.val</code>添加至列表 <code>tmp</code>尾部；</li>
<li><strong>添加子节点：</strong> 若 <code>node</code>的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code>；</li>
</ol>
</li>
<li><p><strong>返回值：</strong> 返回打印结果列表<code>res</code>即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz32</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            ans.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>jz34.二叉树中和为某一值的路径</title>
    <url>/2020/07/10/jz34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>

<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>这道题明显可以通过回溯算法进行遍历求解, 就是<code>先序遍历+路径记录</code></p>
<p>首先考虑递归的终止条件, 需要注意的是题目中描述只有到达叶子节点才算一条完整的路径, 所以不必考虑路径中途停止的情况, 直接将终止条件设置成<code>root == null</code>即可, 表示已经遍历穿了.</p>
<ol>
<li><strong>终止条件:</strong> <code>root== null</code>, 直接返回</li>
<li>*<em>递归过程: *</em> <ol>
<li>路径更新: 将当前的节点值加入路径中</li>
<li>目标更新: 将当前的目标值减去当前的节点值</li>
<li>判断路径是否满足条件: 若当前节点为叶子节点并且目标值为0, 则将当前路径加入到<code>res</code> 列表中.</li>
<li>遍历左右子节点</li>
<li>路径恢复</li>
</ol>
</li>
</ol>
<blockquote>
<p>值得注意的是，记录路径时若直接执行 res.append(path) ，则是将 path 对象加入了 res ；后续 path 改变时， res 中的 path 对象也会随之改变。</p>
<p>正确做法：res.append(list(path)) ，相当于复制了一个 path 并加入到 res 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz34</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        recur(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        path.addLast(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        recur(root.left, target);</span><br><span class="line">        recur(root.right, target);</span><br><span class="line">        path.removeLast();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>DFS</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>jz55-Ⅰ.二叉树的深度</title>
    <url>/2020/07/11/jz55-%E2%85%A0-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>之前做层序遍历的相关题目时有记录过当前遍历所在层数, 那么直接把这个值拿来用就是最大的深度了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> levelNums = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNums; i++) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p><strong>关键点: ** 树的深度和其左右子树的深度之间有着重要关系. 显然, **此树的深度</strong> 等于 <strong>左子树深度</strong> 与 <strong>右子树深度</strong> 中的 <strong>最大值 +1</strong></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/9b063f1f2b7ba125b97a2a11c5f774c0f8ff4df594696993a8eb8282750dae0d-Picture1.png" alt=""></p>
<ol>
<li><strong>终止条件：</strong> 当 <code>root</code> 为空，说明已越过叶节点，因此返回 深度 0 。</li>
<li>*<em>递归过程： *</em> 本质上是对树做后序遍历<ol>
<li>计算节点 <code>root</code> 的 <strong>左子树的深度</strong> ，即调用 <code>maxDepth(root.left)</code></li>
<li>计算节点 <code>root</code> 的 <strong>右子树的深度</strong> ，即调用 <code>maxDepth(root.right)</code></li>
</ol>
</li>
<li><strong>返回值：</strong> 返回 <strong>此树的深度</strong> ，即 <code>max(maxDepth(root.left), maxDepth(root.right)) + 1</code>。</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/ca69f6f15b15999009e903a7c1284effc33ec2317f213ce9170a5d638e1d8b0c-Picture2.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/8026850d70bbeb67a495d9d59eba48cdb43662208e27b430f866436db6fa6673-Picture3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/41c5379ebad1af9e846bbd5f3885968b5186f414e145b6468350ce2c70063f9c-Picture4.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/15270a1bf3ce624fc2928a9bd76810221987abb940ff4c06d7c283be5e25c348-Picture5.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/a27fbe2c4f711cfc1d3c0b7166ad370a1b0c1d7241eeec27d0581abf9722011d-Picture6.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/acb83071a507b8c5b33a31cf0bf2469127df59dcf853c0f75cc299b26042f632-Picture7.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/a10e134e2d20b51b7c444f3102464148c7758851452cf7cff2ef3df5666afbaf-Picture8.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/65f9e2a001a58e4fba481a428a7f07011b6e9fead22909c0acb14fa6d88fc28c-Picture9.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/770a9ba56e74def0292539aa6814785a81cbc2e4e6ef559427d23a91703d096e-Picture10.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/7ecf07e4017438980ea0fe8145e71f33b41f6799c2b567ab0c16cfd25d037f02-Picture11.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>jz54.二叉搜索树的第K大节点</title>
    <url>/2020/07/11/jz54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="BFS-排序"><a href="#BFS-排序" class="headerlink" title="BFS + 排序"></a>BFS + 排序</h2><p>直观印象就是先将二叉树的节点遍历出来, 然后经过排序得出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res.get(res.size() - k);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是这样做的时间复杂度很差.</p>
<hr>
<h2 id="中序遍历-重要"><a href="#中序遍历-重要" class="headerlink" title="中序遍历(重要)"></a>中序遍历(重要)</h2><blockquote>
<p>二叉搜索数的中序遍历为<strong>递增序列</strong></p>
</blockquote>
<p>只要得到二叉搜索树的中序遍历数组, 就直接免去了排序的过程, 大大加快程序执行速度.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest2</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    recur(res, root);</span><br><span class="line">    <span class="keyword">return</span> res.get(res.size() - k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(List&lt;Integer&gt; res, TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>)</span><br><span class="line">            recur(res, root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>)</span><br><span class="line">            recur(res, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>jz55-Ⅱ.平衡二叉树</title>
    <url>/2020/07/12/jz55-%E2%85%A1-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p><strong>示例一</strong>：给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回 <code>true</code> 。</p>
<p><strong>示例二</strong>：给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>

<p>返回 <code>false</code> 。</p>
<hr>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="先序遍历-判断深度-自顶向下"><a href="#先序遍历-判断深度-自顶向下" class="headerlink" title="先序遍历 + 判断深度(自顶向下)"></a>先序遍历 + 判断深度(自顶向下)</h2><p>根据上道题(jz55-Ⅰ)算出的树的深度进行拓展, 我们通过递归的方法已经算出了每个子树的深度, 假设用<code>depth(root)</code> 表示, 那么再嵌套一个递归:</p>
<p><code>isBalance(root):</code></p>
<ol>
<li><p>*<em>特例处理: *</em> 如果<code>root == null</code> , 直接返回<code>true</code> ;</p>
</li>
<li><p>*<em>递归过程: *</em> 判断三个内容:</p>
<ol>
<li>当前左右子树的差值是否小于等于1: <code>Math.abs(depth(root.left) - depth(root.right)) &lt;= 1</code></li>
<li>左子树是否为平衡树:  <code>isBalance(root.left)</code></li>
<li>右子树是否为平衡树: <code>isBalance(root.right)</code></li>
</ol>
</li>
<li><p>*<em>返回值: *</em> 将递归过程求出的三个内容用 <code>&amp;&amp;</code> 连接起来, 返回值类型为 <code>boolean</code></p>
</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/8464f2bae6181353f9960c9ada3f060672a7b309dd313155526efba0d3a8b38d-Picture12.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/997c6c77469be3c3cfada7d89a45cf56634742ee86140a7f0c970d8cd335cafe-Picture13.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/23fc976dcc45a11c7c2398da3d5c4bc49768f0fb6a8eacb14837f1e48bb16897-Picture14.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/36272beee5f24ed421e0267f39408c7304862e73a5e40737090226da24e93300-Picture15.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/f7b74ef888f602cd1215e8ebb04a3638e8a9566ce9b76a945e3f45e2f101a367-Picture16.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/06490aa3308753df2554cf86efccf70345394200fe98c2cf01b2451faee18d4b-Picture17.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="后序遍历-剪枝-从底至顶"><a href="#后序遍历-剪枝-从底至顶" class="headerlink" title="后序遍历 + 剪枝(从底至顶)"></a>后序遍历 + 剪枝(从底至顶)</h2><p>思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</p>
<p><strong>算法流程：</strong></p>
<p><strong><code>recur(root)</code> 函数：</strong></p>
<ul>
<li><p><strong>返回值：</strong></p>
<ol>
<li>当节点root 左 / 右子树的深度差 ≤1 ：则返回当前子树的深度，即节点 root 的左 / 右子树的深度最大值 +1 （ max(left, right) + 1 ）；</li>
<li>当节点root 左 / 右子树的深度差 &gt; 2：则返回 -1, 代表 <strong>此子树不是平衡树</strong> </li>
</ol>
</li>
<li><p><strong>终止条件：</strong></p>
<ol>
<li>当 <code>root</code> 为空：说明越过叶节点，因此返回高度 0；</li>
<li>当左（右）子树深度为 -1：代表此树的 <strong>左（右）子树</strong> 不是平衡树，因此剪枝，直接返回 -1 ；</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">recur</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = recur(root.left);</span><br><span class="line">    <span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = recur(root.right);</span><br><span class="line">    <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left, right) : -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>jz37.序列换二叉树</title>
    <url>/2020/07/11/jz37-%E5%BA%8F%E5%88%97%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p><strong>示例:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>这道题要求实现两个方法, 一个是层序遍历将一个二叉树序列化, 还要根据已知的序列化字符串还原出原二叉树. </p>
<p>首先先来解决序列化问题:</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>这个序列化问题与之前的各种BFS问题一样, 无非就是需要把<code>null</code> 也打印出来, 并且最终结果生成字符串的形式. 字符串形式好说, 直接利用列表的<code>toString()</code> 方法即可. 下面主要来讨论如何把<code>null</code> 打印出来.</p>
<p>之前的BFS过程中, 都有这么一个步骤:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)</span><br><span class="line">    queue.add(temp.left);</span><br><span class="line"><span class="keyword">if</span> (temp.right != <span class="keyword">null</span>)</span><br><span class="line">    queue.add(temp.right);</span><br></pre></td></tr></table></figure>

<p>这么写是为了不让<code>null</code> 入队, 而这道题我们需要将<code>null</code> 入队, 所以两个判断句省去.</p>
<p>另外, 判断一下如果当前出队的节点为<code>null</code>, 则向列表中加入<code>null</code> , 不再考虑<code>null</code> 的左右子节点.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(temp.val);</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>给定一个包含<code>null</code> 的字符串, 将它还原成一个完整二叉树. 这就要分析层序遍历中各节点元素的顺序关系了</p>
<p>直接看图解:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/a372d9c99fecd301e82a34fbe417264c4c09629df2a75c9fea564653f2aa4d6c-Picture15.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/279936eb04ae459c9bc8e87e6dc967b21dca2603648b161a52a93510a3916c1a-Picture16.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/0d118b74490c624afbb18fbf82cd4fc844bce7aea4246efe6c599df9d1e005ca-Picture17.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/6762b541459782314176442011b699913085b7d34ab2598d6044374fe8ee9c6d-Picture18.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/ce3d8c2f587f6f384784b9915f301115ece35dcc8f18aa9c4120e40972e43594-Picture19.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/cb179bc30eab589fc4ce90f7ebdf4269a330e87e1bb5498f241c4634b00c0dc1-Picture20.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/00b3903a3e296ffdd91da6fce33ac9b81ee6d43a5171589cb43d15ba64d61dd8-Picture21.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/8180b8a750c32af66868f7550547effed37d77602c1d4347674bef4803270b82-Picture22.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/455c33478d9236a851313e402f1ef7453686001263ca1002c146923c9d0a1033-Picture23.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/8d207a75cf994e0762b2a420c593553355f1e31ab0b08eaa6245bb5b6a6697b4-Picture24.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/76fe0ddf83303622aa4d954fec53f663c9a5bad3187afbe9c586ec127fd0e8f0-Picture25.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3180c5691fe13aa9d94f352fef42a1e14f931e9327f6041dadb8da3e450b6de1-Picture26.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/dc493c0a7f30e042ee563e13a16bc4c60964d7f4c9d6e52f14625b9b14672f67-Picture27.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/0351597bfa8ec0fa9e715d2182d5166498df3de35b53668fc121115e2478ffc8-Picture28.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/4abbdbb9ee212f3e89515c8909265df08b641dc389a076064ef71bfe8d9b53bd-Picture29.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/f3a8767a785cf7d384e0be4e607593f800fc8822cdfae0ce54290748a82f511b-Picture30.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/2dde0419c3d7a134e6fb8fcc38c85a5180df04b197f8b6cd37137d38da33e8f5-Picture31.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.equals(<span class="string">"[]"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String[] strings = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>).split(<span class="string">", "</span>);</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(strings[<span class="number">0</span>]));</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!strings[i].equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">            temp.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(strings[i]));</span><br><span class="line">            queue.add(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!strings[i].equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">            temp.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(strings[i]));</span><br><span class="line">            queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















































]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>jz68--Ⅰ.二叉搜索树的最近公共祖先</title>
    <url>/2020/07/12/jz68-%E2%85%A0-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/binarysearchtree_improved.png" alt=""></p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><strong>祖先的定义：</strong> 若节点 p 在节点 root的左（右）子树中，或 p = root，则称 root是 p的祖先。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/28242ac7394dfa60a3598a4cf145af9b8311d8f325838e5875d65f6d4ed692fa-Picture1.png" alt=""></p>
<p><strong>最近公共祖先的定义：</strong> 设节点 root为节点 p,q的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。</p>
<p>根据以上定义，若 root 是 p,q的 最近公共祖先 ，则只可能为以下情况之一：</p>
<ol>
<li>p 和 q 在 root 的子树中，且分列 root的 异侧（即分别在左、右子树中）；</li>
<li>p = root，且 q 在 root 的左或右子树中；</li>
<li>q = root，且 pp 在 root 的左或右子树中；</li>
</ol>
<p><strong>本题给定了两个重要条件：</strong>① 树为 二叉搜索树 ，② 树的所有节点的值都是 唯一 的。根据以上条件，可方便地判断 p,q 与 root 的子树关系，即：</p>
<p>若<code>root.val &lt; p.val</code>，则 p 在 root 右子树 中；<br>若 <code>root.val &gt; p.val</code>，则 p 在 root 左子树 中；<br>若 <code>root.val = p.val</code>，则 p 和 root 指向 同一节点 。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>这道题一定要用到二分搜索树的性质, 即左子树的元素肯定都比当前节点小, 右子树的元素都比当前节点大. </p>
<p>如果两个目标节点都比当前节点大, 那么满足条件的节点一定都都在右子树中, 反之一定在左子树中, 如果左右子树一边一个 或者说当前节点就等于一个目标值, 那么当前节点就是最近的公共祖先.</p>
<p>以这个思路去编写代码很容易:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">            root = root.right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">            root = root.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor2</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前中后序遍历</title>
    <url>/2020/07/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>汇总二叉树的前, 中, 后序遍历.每种遍历都有经典的递归和迭代方法.</p>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left, res);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p><img src="http://qcxz71s06.bkt.clouddn.com/f1c189e18ab21142095be343b507a206_3.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    TreeNode curNode = root;</span><br><span class="line">    stack.push(curNode);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        curNode = stack.pop();</span><br><span class="line">        res.add(curNode.val);</span><br><span class="line">        <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(curNode.right);</span><br><span class="line">        <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(curNode.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归方法-1"><a href="#递归方法-1" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.left, res);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.right, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代方法-1"><a href="#迭代方法-1" class="headerlink" title="迭代方法"></a>迭代方法</h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="http://qcxz71s06.bkt.clouddn.com/f6e4510b7c3446075698d9fd10595f2d.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/55fc6e5a3a213807d281b9ed360e89f0.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/f9d089302bcccba69e83adf17ce98382.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/350a01b043f194dc409076b65bbbbb61.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/c1f7b568c46ace2815d7653b1a47e092.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3fb26798163cecf6ed46ae823256809e.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/b564b85e0e54727ab791d94f63834209.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/9b3541ab2cefb2a16efe0929a2f173c3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/6995c79bfc19b0fc7bdb6af3a2ede56d.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/27ae5a883182fbf7ed00897de3348f64.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/88de3e29515e65b31b1f6c776587163a.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/636fb34cd17e20b998b4e78c95a32066.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/14056baa203348c036a36cb2eddd217c.png" alt=""></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归方法-2"><a href="#递归方法-2" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left, res);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代方法-2"><a href="#迭代方法-2" class="headerlink" title="迭代方法"></a>迭代方法</h3><ol>
<li>前序遍历的过程是<code>中左右</code>。 <ul>
<li>将其转化成<code>中右左</code>。也就是压栈的过程中优先压入左子树，再压入右子树。</li>
</ul>
</li>
<li>然后将这个结果反过来，用<code>addFirst()</code>方法将元素输出到数组即可完成逆序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    stack.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode curNode = stack.pop();</span><br><span class="line">        res.addFirst(curNode.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(curNode.left);</span><br><span class="line">        <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(curNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz68-Ⅱ.二叉树的最近公共祖先</title>
    <url>/2020/07/12/jz68-%E2%85%A1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/binarytree.png" alt=""></p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="后序遍历DFS"><a href="#后序遍历DFS" class="headerlink" title="后序遍历DFS"></a>后序遍历DFS</h2><p><strong>祖先的定义：</strong> 若节点 p 在节点 root的左（右）子树中，或 p = root，则称 root是 p的祖先。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/83402bb4c1bba2746effc5607d9654aeb9c3496b4a846d41ce61adb5af02c0f5-Picture1.png" alt=""></p>
<p><strong>最近公共祖先的定义：</strong> 设节点 root为节点 p,q的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。</p>
<p>根据以上定义，若 root 是 p,q的 最近公共祖先 ，则只可能为以下情况之一：</p>
<ol>
<li>p 和 q 在 root 的子树中，且分列 root的 异侧（即分别在左、右子树中）；</li>
<li>p = root，且 q 在 root 的左或右子树中；</li>
<li>q = root，且 pp 在 root 的左或右子树中；</li>
</ol>
<hr>
<p>这道题与上道题的区别或者说拓展点在于, 上道题是二叉搜索树, 可以根据值的大小进行判断在左子树还是右子树中, 但是二叉树没有大小的要求, 所以只能遍历到具体的节点, 然后根据位置判断在哪个子树中.</p>
<p>我们采用后序遍历的方法, 一旦遍历到目标节点, 就层层向上返回.</p>
<ul>
<li>若左子树递归返回一个节点, 右子树返回一个节点, 说明左右子树中各发现了一个目标节点, 那么当前节点就是最近的公共祖先节点</li>
<li>若左子树递归返回了一个节点, 右子树返回<code>null</code>, 那就继续上交左子树返回的节点, 左子树返回的这个节点有两种可能:<ul>
<li>可能是两个目标节都在左子树中找到了, 这个节点就是他们的公共祖先节点</li>
<li>可能是只找到了一个目标节点, 那么这个节点就是目标节点, 需要在上传的某一层中与另外的一个目标节点汇合</li>
</ul>
</li>
<li>若右子树递归返回了一个节点, 左子树返回<code>null</code>, 情况类比左子树的情况即可, 完全对称</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>||root.val==p.val||root.val == q.val)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="keyword">null</span> )</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>jd1712.BiNode</title>
    <url>/2020/07/15/jd1712-BiNode/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>
<p>返回转换后的单向链表的头节点。</p>
<p>注意：本题相对原题稍作改动</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： [4,2,5,1,3,null,6,0]</span><br><span class="line">输出： [0,null,1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="中序遍历迭代"><a href="#中序遍历迭代" class="headerlink" title="中序遍历迭代"></a>中序遍历迭代</h2><p>因为要符合二叉搜索树的性质, 所以要保持顺序, 因此采用中序遍历的方法.</p>
<p>每遍历到一个节点, 需要将当前的左节点置空, 然后接在上一个节点上, 作为上一个节点的右节点. 因为要时刻记录上一个节点的情况, 所以提前初始化一个哨兵节点, 随着遍历的进行, 这个哨兵节点也不断移动.</p>
<p>所以算法大致流程为, 在中序遍历的基础上:</p>
<ol>
<li>将当前从栈中弹出的节点左子节点置空</li>
<li>将当前从栈中弹出的节点接在上一个节点的右边</li>
<li>将上一个节点移动到当前节点处</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBiNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        TreeNode prev = head;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                cur.left = <span class="keyword">null</span>;</span><br><span class="line">                prev.right = cur;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="中序遍历递归"><a href="#中序遍历递归" class="headerlink" title="中序遍历递归"></a>中序遍历递归</h2><p>思路跟迭代法一样, 都是在遍历到当前节点时进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBiNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        inorder(root, head);</span><br><span class="line">        <span class="keyword">return</span> head.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">inorder</span><span class="params">(TreeNode root, TreeNode prev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            prev = inorder(root.left, prev);</span><br><span class="line">            root.left = <span class="keyword">null</span>;</span><br><span class="line">            prev.right = root;</span><br><span class="line">            prev = root;</span><br><span class="line">            prev = inorder(root.right, prev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>jz26.树的子结构</title>
    <url>/2020/07/09/jz26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><hr>
<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>看到这道题时经过分析可知需要两个递归过程:</p>
<p>过程一是<code>判断当前节点为根节点的树与树B是否相同</code> || <code>当前节点的左子树与树B是否相同</code> || <code>当前节点的右子树与树B是否相同</code>,   写成<code>isSubStructure(A, B)</code> 方法:</p>
<ol>
<li><p><strong>特例:</strong><br>当 树<code>A</code> 为空 <strong>或</strong> 树 <code>B</code> 为空 时，直接返回 <code>false</code> </p>
</li>
<li><p><strong>返回值</strong>: 若树<code>B</code>是树 <code>A</code>的子结构，则必满足以下三种情况之一，因此用或 <code>||</code> 连接</p>
<ol>
<li>以 节点 <code>A</code>为根节点的子树 包含树 <code>B</code> ，对应 recur(A, B)；</li>
<li>树 <code>B</code> 是 树 <code>A</code>左子树 的子结构，对应 isSubStructure(A.left, B)；</li>
<li>树 <code>B</code>是 树 <code>A</code>右子树 的子结构，对应 isSubStructure(A.right, B)；</li>
</ol>
</li>
</ol>
<p>过程二是判断两个树是否相同, 要求是两节点的值相同, 左右子树也相同, 写成<code>recur()</code> 方法:</p>
<ol>
<li><p><strong>终止条件:</strong></p>
<ol>
<li>当节点<code>B</code> 为空：说明树 <code>B</code> 已匹配完成（越过叶子节点），因此返回<code>true</code> ；</li>
<li>当节点<code>A</code>为空：说明已经越过树 <code>A</code>叶子节点，即匹配失败，返回<code>false</code> ；</li>
<li>当节点<code>A</code> 和 <code>B</code>的值不同：说明匹配失败，返回 <code>false</code> ；</li>
</ol>
</li>
<li><p><strong>返回值:</strong></p>
<ol>
<li>判断 <code>A</code> 和 <code>B</code> 的左子节点是否相等，即 recur(A.left, B.left) ；</li>
<li>判断 <code>A</code> 和 <code>B</code> 的右子节点是否相等，即 recur(A.right, B.right) ；</li>
</ol>
</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/0e15908809807327aa87c748c4cf1d850eeb63cc13df94c87439cbaffb535005-Picture2.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/5d9592ec644c6fc765d6e223d4beb3a74ecf46a32b703d9d02cdbeb9f88e9523-Picture3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/76016cb01f7c051318761388eeadd774b334c6da3c5722754452fc82da87c04b-Picture4.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/efe061c2ae8ae6c75b4f36bfd766d60471b4bc985cb330cdae5805043b19f440-Picture5.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/987e1803a3600ef2b8e18320589e058e189888fb4d88389527f33499340f149a-Picture6.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3850986482cd6344935ac823e8b396b52f02ae196b573cea1e7ebecb97eb063c-Picture7.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/cb14268630fd9efa872f077ee625f8066cd7c818f11df9fc9436fa371994de8a-Picture8.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/24d94f730e0a7fc091ab321349c4524dd51828db1fa6a9c1b6455561fa27708e-Picture9.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>团灭四道搜索旋转排序数组题</title>
    <url>/2020/07/07/%E5%9B%A2%E7%81%AD%E5%9B%9B%E9%81%93%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在刷关于二分查找的算法题目时, 有一块内容是绕不过去的, 那就是旋转排序数组的题目. </p>
<p>我们知道, 在查找排序数组时往往采用二分查找的方法, 但是旋转排序数组只保留了区域性的排序, 这就让人比较头疼.通常的二分查找题目有两类, 一类是目标值查找, 即从数组中查找目标值, 返回其下标; 另一类考察的是边界, 这类题目更加灵活, 可能会考察第K大的数, 第一个重复出现的数等等.</p>
<p>结合了旋转数组之后, 就有了四道非常典型的题目, 他们是:</p>
<ul>
<li>LeetCode 33: <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></li>
<li>LeetCode 81: <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">搜索旋转排序数组 Ⅱ</a></li>
<li>LeetCode 153: <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></li>
<li>LeetCode 154: <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值 Ⅱ</a></li>
</ul>
<p>总体而言分别考察了目标值和最小值, 只是按是否存在重复的数又各拓展出一道题. 下面分别来解决.</p>
<hr>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>首先，<code>mid</code>将数组分成前后两段：</p>
<p>如果<code>nums[start]&lt;=nums[mid]</code>，则说明前半段是<strong>递增</strong>的</p>
<ul>
<li><p>如果<code>nums*[*start*]* &lt;= target &amp;&amp; target &lt; nums*[*mid*]</code>,目标值在前半段，使<code>end=mid-1</code>*</p>
</li>
<li><p>否则，目标值在后半段，使<code>start=mid+1</code>*</p>
</li>
</ul>
<p>否则，说明后半段是<strong>递增</strong>的</p>
<ul>
<li><p>如果<code>nums[mid] &lt; target &amp;&amp; target &lt;= nums[end]</code>,目标值在后半段，使<code>start=mid+1</code></p>
</li>
<li><p>否则，目标值在前半段，使<code>end=mid-1</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) &#123;</span><br><span class="line">                <span class="comment">// 说明数组在[0, mid]区间上是递增的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    <span class="comment">// 说明target在[left, mid-1]区间内</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 说明target在[mid+1, right]区间内</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明数组在[mid, right]区间上是递增的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                    <span class="comment">// 说明target在区间[mid+1, right]内</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 说明target在区间[left, mid-1]内</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="81-搜索旋转排序数组-Ⅱ"><a href="#81-搜索旋转排序数组-Ⅱ" class="headerlink" title="81: 搜索旋转排序数组 Ⅱ"></a>81: 搜索旋转排序数组 Ⅱ</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h4><p>因为存在重复的元素, 因此在33题中判断前后段升降时遇到了特殊情况. 在33题中是通过<code>nums[mid] &gt;= nums[left]</code> 来判断前半段是否为增, 若存在重复元素, 则无法通过该方法判断例如 <code>10111</code> 的数组. 有两种判断方法:</p>
<ol>
<li>出现这种情况时<code>nums[left]</code> 和<code>nums[right]</code> 一定是相等的.<code>left++</code> 即可</li>
<li>将原来的判断条件分开来处理, 当<code>nums[mid] &gt; nums[left]</code>时, 还按33题的方法去做, 添加一个<code>nums[mid] = nums[left]</code>的处理方法: 也是<code>left++</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] == nums[mid]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="153-搜索旋转排序数组中的最小值"><a href="#153-搜索旋转排序数组中的最小值" class="headerlink" title="153.搜索旋转排序数组中的最小值"></a>153.搜索旋转排序数组中的最小值</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找-2"><a href="#二分查找-2" class="headerlink" title="二分查找"></a>二分查找</h4><p>因为不存在重复的数字, 所以只需要考虑大于和等于的情况, 比较对象为<code>nums[right]</code></p>
<ol>
<li><p>循环二分： 设置 <code>i</code>,<code>j</code> 指针分别指向<code>numbers</code> 数组左右两端，<code>m = (i + j) / 2</code> 为每次二分的中点（ “/“ 代表向下取整除法），可分为以下三种情况：</p>
<ol>
<li><p>当<code>numbers[m] &gt; numbers[j]</code>时： <code>m</code> 一定在 左排序数组 中，即旋转点 <code>x</code>一定在<code>[m + 1, j]</code>闭区间内，因此执行<code>i = m + 1</code>；</p>
</li>
<li><p>当 <code>numbers[m] &lt; numbers[j]</code>时： <code>m</code> 一定在 右排序数组 中，即旋转点 <code>x</code> 一定在<code>[i, m]</code> 闭区间内，因此执行<code>j = m</code>；</p>
</li>
</ol>
</li>
<li><p>返回值： 当<code>i = j</code>时跳出二分循环，并返回 <code>numbers[i]</code>即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="154-搜索旋转排序数组中的最小值-Ⅱ"><a href="#154-搜索旋转排序数组中的最小值-Ⅱ" class="headerlink" title="154.搜索旋转排序数组中的最小值 Ⅱ"></a>154.搜索旋转排序数组中的最小值 Ⅱ</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>注意数组中可能存在重复的元素。</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找-3"><a href="#二分查找-3" class="headerlink" title="二分查找"></a>二分查找</h4><p>这道题与153题有着高度的相似,  依然是将<code>nums[mid]</code>与<code>nums[right]</code>相比较, 不过是多考虑一个等于的情况, 采取的措施是<code>right--</code>. </p>
<p>如下图所示，寻找旋转数组的最小元素即为寻找 右排序数组 的首个元素 <code>numbers[x]</code> ，称 <code>x</code> 为 旋转点</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/e4c293fbc50538a0af581f455a2d8ce4_2.png" alt=""></p>
<ol>
<li><p>循环二分： 设置 <code>i</code>,<code>j</code> 指针分别指向<code>numbers</code> 数组左右两端，<code>m = (i + j) / 2</code> 为每次二分的中点（ “/“ 代表向下取整除法），可分为以下三种情况：</p>
<ol>
<li><p>当<code>numbers[m] &gt; numbers[j]</code>时： <code>m</code> 一定在 左排序数组 中，即旋转点 <code>x</code>一定在<code>[m + 1, j]</code>闭区间内，因此执行<code>i = m + 1</code>；</p>
</li>
<li><p>当 <code>numbers[m] &lt; numbers[j]</code>时： <code>m</code> 一定在 右排序数组 中，即旋转点 <code>x</code> 一定在<code>[i, m]</code> 闭区间内，因此执行<code>j = m</code>；</p>
</li>
<li><p>当 <code>numbers[m] == numbers[j]</code>时： 无法判断 <code>m</code> 在哪个排序数组中，即无法判断旋转点<code>x</code> 在 <code>[i, m]</code> 还是 <code>[m + 1, j]</code> 区间中。解决方案： 执行<code>j = j - 1</code> 缩小判断范围.</p>
</li>
</ol>
</li>
<li><p>返回值： 当<code>i = j</code>时跳出二分循环，并返回 <code>numbers[i]</code>即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) j = m;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较来看<strong>153题</strong>的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>旋转排序数组</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2020/07/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 多线程的内容很重要, 第一遍没学好, 重新梳理总结一下. 把基础内容总结好之后, 会学习JUC并发编程的相关知识, 会一直总结学习下去. 这块内容我还是想深入学习的, 不只是记一些概念性的知识.</p>
<hr>
<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h3><p>多线程简化理解为, 一条路上交通很拥挤, 通过开辟多个车道分流, 解决拥堵问题.</p>
<p>单线程调用方法和多线程的区别:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708130847.png" alt=""></p>
<p>很明显左边的效率低, 右边开辟新线程, 各走各的, 效率高.</p>
<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>在操作系统中运行的程序就是进程, 比如QQ, 播放器, 游戏等</p>
<p>一个进程可以有多个线程, 如视频中同时听到声音, 看到图像, 看弹幕等等</p>
<p>需要注意的是, <strong>程序</strong>是指令和数据的有序集合, 是一个静态的概念, 执行程序的一次执行过程叫做<strong>进程</strong>, 这才是动态的概念</p>
<p>通常在一个进程中可以包含若干个线程, 线程是CPU调度和执行的单位</p>
<p><strong>核心概念:</strong></p>
<ul>
<li>在程序执行时, 即使没有创建线程, 后台也会有多个线程, 如主线程, gc线程;</li>
<li>main()称之为主线程, 为系统的入口, 用于执行整个程序</li>
<li>对同一份资源操作时, 会存在资源抢夺的问题, 需要加入并发控制</li>
<li>线程会带来额外的开销, 如CPU调度时间, 并发控制开销</li>
</ul>
<hr>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><h3 id="三种创建方式"><a href="#三种创建方式" class="headerlink" title="三种创建方式"></a>三种创建方式</h3><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708232259.png" alt=""></p>
<h4 id="Thread方式"><a href="#Thread方式" class="headerlink" title="Thread方式"></a>Thread方式</h4><p><code>Thread</code>类实现了<code>Runnable</code>接口</p>
<ol>
<li>自定义线程类继承<code>Thread</code> 类</li>
<li>重写<code>run()</code> 方法, 编写线程执行体</li>
<li>创建线程对象, 调用<code>start()</code> 方法启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run 方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在看代码----"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main线程, 主线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程对象</span></span><br><span class="line">        TestThread testThread1 = <span class="keyword">new</span> TestThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start()方法开启线程</span></span><br><span class="line">        testThread1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在学习多线程-----"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708233832.png"  />

<p>可以看到自定义线程和主线程的输出结果交错显示.</p>
<p>线程不一定立即执行, 由CPU安排调度. 这里如果把<code>start()</code> 方法替换成<code>run()</code> 的话, 就按顺序执行了.</p>
<p>下面写一个从网络同时下载三张图片, 再熟悉一下多线程的使用, 这里因为要处理IO流, 所以导入了<code>commons-io</code> 包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">// 网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread2</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebDownLoader webDownLoader = <span class="keyword">new</span> WebDownLoader();</span><br><span class="line">        webDownLoader.downloader(url, name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件名为: "</span>+ name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread2 t1 = <span class="keyword">new</span> TestThread2(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708232259.png"</span>, <span class="string">"1.png"</span></span><br><span class="line">                );</span><br><span class="line">        TestThread2 t2 = <span class="keyword">new</span> TestThread2(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708130847.png"</span>, <span class="string">"2.png"</span></span><br><span class="line">                );</span><br><span class="line">        TestThread2 t3 = <span class="keyword">new</span> TestThread2(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/46a8eb9c7e647c684c0b92d098727b9b.png"</span>, <span class="string">"3.png"</span></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url), <span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"IO异常, downloader方法出现问题"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来分析一下这段代码, 将下载和存储的功能单独做成一个下载器的类, 这个是主要功能代码, 我们根据创建线程的流程可以知道待会要在重写的<code>run()</code> 方法中调用.</p>
<p>然后来按照流程创建自定义线程类, 要点是继承<code>Thread</code> 类, 重写<code>run()</code> 方法, 然后将功能代码写进<code>run()</code> 方法中. </p>
<p>在主线程中创建三个自定义线程对象, 他们各自负责下载一张图片, 然后使用<code>start()</code> 方法, 输出的结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载了文件名为: 2.png</span><br><span class="line">下载了文件名为: 3.png</span><br><span class="line">下载了文件名为: 1.png</span><br></pre></td></tr></table></figure>

<p>可以看出多线程的效果.</p>
<h4 id="Runnable方法"><a href="#Runnable方法" class="headerlink" title="Runnable方法"></a>Runnable方法</h4><ol>
<li>实现MyRunnable类实现Runnable接口</li>
<li>实现<code>run()</code> 方法, 编写线程执行体</li>
<li>创建线程对象, 调用<code>start()</code> 方法启动线程</li>
</ol>
<blockquote>
<p><strong>避免单继承局限性, 灵活方便, 方便同一个对象被多个线程使用</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run 方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在看代码----"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main线程, 主线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程对象</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 创建线程对象, 通过线程对象来开启我们的线程, 这是个代理</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(testThread3);</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 简写方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testThread3).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在学习多线程-----"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果与<code>Thread方法</code> 类似, 不再贴出, 需要注意的是, 在使用<code>start()</code> 方法开启新的线程时通过一个<code>Thread</code> 类的对象调用, 它被称为自定义线程的<strong>静态代理</strong>.</p>
<p>用实现<code>Runnable</code>接口的方法改写下载网络图片的示例, 只需要改动自定义线程类的名称以及调用方法即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(t1).start();</span><br><span class="line"><span class="keyword">new</span> Thread(t2).start();</span><br><span class="line"><span class="keyword">new</span> Thread(t3).start();</span><br></pre></td></tr></table></figure>

<h5 id="龟兔赛跑小例子"><a href="#龟兔赛跑小例子" class="headerlink" title="龟兔赛跑小例子"></a>龟兔赛跑小例子</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟龟兔赛跑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lxb0124</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-09 13:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Race</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 胜利者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String winner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟兔子休息</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"兔子"</span>) &amp;&amp; i % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断比赛是否结束</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = gameOver(i);</span><br><span class="line">            <span class="comment">// 如果比赛结束, 停止程序</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" ---&gt; 跑了 "</span> + i + <span class="string">" 步"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否完成比赛</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">gameOver</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否有胜利者</span></span><br><span class="line">        <span class="keyword">if</span> (winner != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (steps &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                winner = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(<span class="string">"winner is "</span> + winner + <span class="string">" !"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Race race = <span class="keyword">new</span> Race();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(race, <span class="string">"兔子"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(race, <span class="string">"乌龟"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Callable方法-了解即可"><a href="#Callable方法-了解即可" class="headerlink" title="Callable方法(了解即可)"></a>Callable方法(了解即可)</h4><ol>
<li><p>实现<code>Callable</code> 接口, 需要返回值类型</p>
</li>
<li><p>重写<code>call</code> 方法, 需要抛出异常</p>
</li>
<li><p>创建目标对象</p>
</li>
<li><p>创建执行服务:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService ser = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交执行:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Boolean&gt; result1 = ser.submit(t1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> r1 = result.get();</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭服务:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ser.shutdownNow;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>改写下载网络图片案例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">// 网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebDownLoader webDownLoader = <span class="keyword">new</span> WebDownLoader();</span><br><span class="line">        webDownLoader.downloader(url, name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件名为: "</span>+ name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable t1 = <span class="keyword">new</span> TestCallable(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708232259.png"</span>, <span class="string">"1.png"</span></span><br><span class="line">        );</span><br><span class="line">        TestCallable t2 = <span class="keyword">new</span> TestCallable(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708130847.png"</span>, <span class="string">"2.png"</span></span><br><span class="line">        );</span><br><span class="line">        TestCallable t3 = <span class="keyword">new</span> TestCallable(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/46a8eb9c7e647c684c0b92d098727b9b.png"</span>, <span class="string">"3.png"</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行服务:</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; r1 = ser.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; r2 = ser.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; r3 = ser.submit(t3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        Boolean rs1 = r1.get();</span><br><span class="line">        Boolean rs2 = r2.get();</span><br><span class="line">        Boolean rs3 = r3.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        ser.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>callable的好处</strong></p>
<ol>
<li>可以定义返回值</li>
<li>可以抛出异常</li>
</ol>
<h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p>多个线程同时操作同一个对象</p>
<p>以买火车票为例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNums&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟延时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 拿到了第"</span> + ticketNums-- + <span class="string">" 票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread4 ticket = <span class="keyword">new</span> TestThread4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(ticket, <span class="string">"小明"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket, <span class="string">"老师"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket, <span class="string">"黄牛"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析这段代码的功能, 首先是在自定义线程里设置了共享的资源, 然后开启三个线程对这个资源进行操作. 这里可能会有疑问: 为什么三个线程会对同一个资源进行操作呢? 这要注意我们只创建了一个自定义线程的对象<code>ticket</code> , 然后开启了三次也就是申请了三个代理, 所以只有一个共享资源. </p>
<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200709130233.png" alt=""></p>
<p>我们发现了问题: 拿第10张票来说, 三个线程都对其进行了操作, 这就出现了并发的问题.多个线程操作同一个资源的情况下, 线程不安全, 数据紊乱.</p>
<p>为什么龟兔赛跑的例子中没有出现并发问题呢? 这是因为龟兔赛跑中创建的<code>race</code> 对象模拟的是一个赛道, 在整个循环的框架中让线程进来, 所以不会存在冲突的问题.</p>
<hr>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ol>
<li><p>真实对象和代理对象都要实现同一个接口</p>
</li>
<li><p>代理对象要代理真实角色</p>
</li>
</ol>
<p>这样做的好处是:</p>
<ol>
<li>代理对象可以做很多真实对象做不了的事情</li>
<li>真实对象专注做自己的事情</li>
</ol>
<p>下面通过代码深刻了解这一过程:</p>
<p>我们模拟婚庆公司代理举行婚礼的过程</p>
<p>首先创建一个<code>Marry</code>接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个真实对象的类<code>You</code>, 这个是真正要结婚的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真实角色, 你去结婚</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xxx要结婚了, 超开心"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义婚庆公司的类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理角色, 帮助你去结婚</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Marry target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="keyword">this</span>.target.HappyMarry();</span><br><span class="line">        afer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"结婚之前布置现场"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"结婚之后收尾款"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这两段代码的对比可以看到, 它们都重写的<code>HappyMarry()</code> 方法, 如果不用婚庆公司的话, 只能实现结婚这一个动作, 使用了代理之后, 不仅原来的功能可以实现(因为传入了<code>You</code>对象), 还可以添加额外的功能.</p>
<p>如果没有用到代理的话, 我们是这样调用的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        You you = <span class="keyword">new</span> You();</span><br><span class="line">        you.HappyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxx要结婚了, 超开心</span><br></pre></td></tr></table></figure>

<p>使用代理之后的话:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeddingCompany weddingCompany = <span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You());</span><br><span class="line">        weddingCompany.HappyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结婚之前布置现场</span><br><span class="line">xxx要结婚了, 超开心</span><br><span class="line">结婚之后收尾款</span><br></pre></td></tr></table></figure>

<p>由婚庆公司的例子可以类比到线程的创建过程, 我们发现线程的创建过程也用到了静态代理的思想</p>
<p>我们将上面创建婚庆公司的对象代码简化一下, 并和线程创建代码写在一起对比:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You()).HappyMarry();</span><br><span class="line">   <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">"我爱多线程!"</span>)).start();</span><br></pre></td></tr></table></figure>

<p>这里<code>WeddingCompany</code> 和<code>Thread</code> 都是静态代理, 需要传入真实对象, 婚庆公司和<code>You</code> 都实现了<code>Marry</code> 接口; <code>Thread</code> 和 自定义线程类都实现了<code>Runnable</code> 接口.</p>
<p>然后最后调用的方法都是代理类中定义的方法.</p>
<hr>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>*<em>定义: *</em> 任何接口, 如果只包含唯一一个抽象方法, 那么它就是函数式接口. 例如现在经常接触的<code>Runnable</code> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于函数式接口, 我们可以通过 Lambda 表达式来创建该接口的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ILike like = <span class="keyword">new</span> Like();</span><br><span class="line">        like.lambda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Like</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"i like lambda."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个函数式接口的例子, 先用常规方法调用<code>lambda()</code> 函数</p>
<p>利用<strong>静态内部类</strong>的方式进行代码优化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"i like lambda2."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Like2 like = <span class="keyword">new</span> Like2();</span><br><span class="line">        like.lambda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<strong>局部内部类</strong>的方式进行代码优化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"i like lambda2."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Like3 like3 = <span class="keyword">new</span> Like3();</span><br><span class="line">    like3.lambda();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<strong>匿名内部类</strong>进行简化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名内部类, 没有类的名称, 必须借助接口或父类</span></span><br><span class="line">    ILike like4 = <span class="keyword">new</span> ILike() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"i like lambda4."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    like4.lambda();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终, 利用<strong>Lambda表达式</strong>再进行简化:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda表达式</span></span><br><span class="line">    ILike like5 = ()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">"i like lambda5."</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    like5.lambda();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要使用<code>Lambda</code> 表达式:</p>
<ul>
<li>避免匿名内部类定义过多</li>
<li>简化代码</li>
<li>去掉了一堆没有意义的代码, 只留下核心的逻辑</li>
</ul>
<h3 id="带参数的Lambda表达式"><a href="#带参数的Lambda表达式" class="headerlink" title="带参数的Lambda表达式"></a>带参数的Lambda表达式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Ilove ilove = (<span class="keyword">int</span> a)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">"i love you ---&gt;"</span> + a);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ilove.love(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Ilove</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">love</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步简化, 将参数类型和括号都简化掉:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Ilove ilove = a -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"i love you ---&gt;"</span> + a);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ilove.love(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将花括号都给去掉:</p>
<p>去掉花括号的原因是重写的方法里只有一行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Ilove ilove = a -&gt; System.out.println(<span class="string">"i love you ---&gt;"</span> + a);</span><br><span class="line"></span><br><span class="line">    ilove.love(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>lambda表达式只能有一行代码的情况下才能简化成一行, 如果有多行, 那么就用代码块包裹</li>
<li>能写成lambda表达式的前提是为函数式接口</li>
<li>多个参数也可以去掉参数类型, 要去掉就全都去掉, 但是必须加括号</li>
</ul>
<hr>
<h2 id="线程的五大状态"><a href="#线程的五大状态" class="headerlink" title="线程的五大状态"></a>线程的五大状态</h2><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200710122350.png" alt=""></p>
<p>一些常见的线程方法:</p>
<ul>
<li><strong><em>setPriority(int newPriority):</em></strong> 更改线程的优先级</li>
<li><strong><em>static void sleep(long millis):</em></strong> 在指定的毫秒数内让当前正在执行的线程休眠</li>
<li><strong><em>void join():</em></strong> 等待该线程终止</li>
<li><strong><em>static void yield():</em></strong> 暂停当前正在执行的线程对象, 并执行其他线程</li>
<li><strong><em>void interrupt():</em></strong> 中断线程, 别用这种方式</li>
<li><strong><em>boolean isAlive():</em></strong> 测试线程是否处于活动状态</li>
</ul>
<h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><p>不推荐使用JDK提供的<code>stop()</code>, <code>destroy()</code> 方法. 推荐线程自己停止下来, 可以使用一个标志位进行终止变量当 flag = false, 则终止线程运行.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试stop</span></span><br><span class="line"><span class="comment"> * 1. 建议线程正常停止, 利用次数, 不建议死循环</span></span><br><span class="line"><span class="comment"> * 2. 建议使用标志位</span></span><br><span class="line"><span class="comment"> * 3. 不要使用stop 或者destroyed方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lxb0124</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-10 12:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置一个标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">"run ... Thread "</span> + i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一个公开的方法停止线程, 转换标志位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        TestStop testStop = <span class="keyword">new</span> TestStop();</span><br><span class="line">        <span class="keyword">new</span> Thread(testStop).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main "</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">900</span>)&#123;</span><br><span class="line">                <span class="comment">// 调用stop方法, 让线程停止</span></span><br><span class="line">                testStop.stop();</span><br><span class="line">                System.out.println(<span class="string">"该线程停止了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析这段代码, 在主线程中开启了自定义线程, 两个线程同时运行, 各自计数, 当主线程记到900时, 将自定义的线程停掉, 结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200710125803.png" alt=""></p>
<h3 id="线程休眠-sleep"><a href="#线程休眠-sleep" class="headerlink" title="线程休眠: sleep"></a>线程休眠: sleep</h3><ul>
<li>sleep(时间) 指定当前线程阻塞的毫秒数</li>
<li>sleep存在异常InterruptedException;</li>
<li>sleep时间达到后线程进入就绪状态</li>
<li>sleep看可以模拟网络延时, 倒计时等</li>
<li><strong>每个对象都有一个锁, sleep不会释放锁</strong></li>
</ul>
<p>之前写的三个人抢火车票的代码就应用了网络延时, 可以放大问题的发生性. 下面写一个倒计时的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印当前系统时间</span></span><br><span class="line">    Date startTime = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(startTime));</span><br><span class="line">            startTime = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程礼让-yield"><a href="#线程礼让-yield" class="headerlink" title="线程礼让: yield"></a>线程礼让: yield</h3><ul>
<li>礼让线程, 让当前正在执行的线程暂停, 但不阻塞</li>
<li>将线程从运行状态转为就绪状态</li>
<li><strong>让CPU重新调度, 礼让不一定成功, 看CPU心情!!</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyYield myYield = <span class="keyword">new</span> MyYield();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield, <span class="string">"a"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(myYield, <span class="string">"b"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyYield</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 线程开始执行"</span>);</span><br><span class="line">        Thread.yield();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 线程停止执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程强制执行-join"><a href="#线程强制执行-join" class="headerlink" title="线程强制执行: join"></a>线程强制执行: join</h3><ul>
<li>Join合并线程, 待此线程执行完成后, 再执行其他线程, 其他线程阻塞</li>
<li>可以想象成插队</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程vip来了 "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestJoin testJoin = <span class="keyword">new</span> TestJoin();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(testJoin);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">50</span>)&#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"main "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚开始自定义线程和主线程同时执行, 当主线程计数到50时, 自定义线程强行执行, 直到该线程执行结束主线程再继续执行. 输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200710134632.png" alt=""></p>
<h3 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h3><p>通过<code>Thread.State</code> 可以查看线程的状态:</p>
<ul>
<li>NEW: 尚未启动的线程处于此状态</li>
<li>RUNNABLE: 在Java虚拟机中执行的线程处于此状态</li>
<li>BLOCKED: 被阻塞等待监视器锁定的线程处于此状态</li>
<li>WAITING: 正在等待另一个线程执行特定动作的线程处于此状态</li>
<li>TERMINATED: 已退出的线程处于此状态</li>
</ul>
<p>一个线程可以在给定时间点处于一个状态, 这些状态是不反映任何操作系统线程状态的虚拟机状态.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"////////"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 观测状态</span></span><br><span class="line">        Thread.State state = thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 观察启动后</span></span><br><span class="line">        thread.start();</span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println(state);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (state != Thread.State.TERMINATED) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                state = thread.getState();</span><br><span class="line">                System.out.println(state);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析这段代码, 自定义线程的<code>run()</code> 编写了一个5秒的倒计时, 然后观测这个线程整个过程中的状态. 首先是启动前应该是<code>NEW</code>, 启动了瞬间应该为<code>RUNNABLE</code>, 进入倒计时后应该为<code>TIMED_WAITING</code>, <code>run()</code> 方法跑完之后应该为<code>TERMINATED</code>.</p>
<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NEW</span><br><span class="line">RUNNABLE</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">TERMINATED</span><br></pre></td></tr></table></figure>

<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程, 线程调度器按照优先级决定应该调度哪个线程来执行.</p>
<p>线程的优先级用数字表示, 范围从1-10:</p>
<ul>
<li>Thread.MIN_PRIORITY = 1;</li>
<li>Thread.MAX_PRIORITY = 10;</li>
<li>Thread.NORM_PRIORITY = 5;</li>
</ul>
<p>使用以下方式改变或获取优先级:</p>
<ul>
<li>getPriority</li>
<li>setPriority(int xxx)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPriority</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程默认优先级</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" --&gt; "</span> + Thread.currentThread().getPriority());</span><br><span class="line"></span><br><span class="line">        MyPriority myPriority = <span class="keyword">new</span> MyPriority();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(myPriority);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        t2.setPriority(<span class="number">1</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t3.setPriority(<span class="number">4</span>);</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        t4.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">        t5.setPriority(<span class="number">8</span>);</span><br><span class="line">        t5.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPriority</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" --&gt; "</span> +Thread.currentThread().getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main --&gt; 5</span><br><span class="line">Thread-3 --&gt; 10</span><br><span class="line">Thread-4 --&gt; 8</span><br><span class="line">Thread-2 --&gt; 4</span><br><span class="line">Thread-0 --&gt; 5</span><br><span class="line">Thread-1 --&gt; 1</span><br></pre></td></tr></table></figure>

<p>需要注意的是, 优先级低只是意味着获得调度的概率低, 并不是优先级低就不会被调用了, 都是看CPU的调度.</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>线程分为用户线程和守护线程, 虚拟机必须确保用户线程执行完毕, 而不用等待守护线程执行完毕, 如后台记录操作日志, 监控内存, 垃圾回收等待…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaemon</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        God god = <span class="keyword">new</span> God();</span><br><span class="line">        Youa youa =  <span class="keyword">new</span> Youa();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(god);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);     <span class="comment">// 默认是false表示用户线程, 正常的线程都是用户线程</span></span><br><span class="line"></span><br><span class="line">        thread.start(); <span class="comment">// 上帝守护线程启动</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(youa).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上帝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"上帝永远保佑着你"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Youa</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">36500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"你一生都开心的活着"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"======goodbye!world!======="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200710175623.png" alt=""></p>
<hr>
<h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><p>线程同步问题发生在多个线程操作同一个资源时.</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>同一个对象被多个线程同时操作. 处理多线程问题时, 多个线程访问同一个对象, 并且某些线程还想修改这个对象, 这时候我们就需要线程同步. 线程同步其实就是一种等待机制, 多个需要同时访问此对象的线程进入这个对象的等待池形成队列, 等待前面线程使用完毕, 下一个线程再使用.</p>
<h3 id="队列-和-锁"><a href="#队列-和-锁" class="headerlink" title="队列 和 锁"></a>队列 和 锁</h3><p>队列是对线程而言, 是一种排队的机制, 但是只有队列也不行, 还需要资源对象保证安全, 这就是锁 .  队列 + 锁才能保证线程的安全性.</p>
<p>由于同一进程的多个线程共享同一块存储空间, 在带来方便的同时, 也带来了访问冲突问题, 为了保证数据在方法中被访问时的正确性, 在访问时加入<strong>锁机制 synchronized</strong>, 当一个线程获得对象的排他锁, 独占资源, 其他线程必须等待, 使用后释放锁即可, 存在以下问题:</p>
<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起.</li>
<li>在多线程竞争下, 加锁, 释放锁会导致比较多的上下文切换和调度延时, 引起性能问题</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁, 会导致优先级倒置, 引起性能问题.</li>
</ul>
<h3 id="三大不安全案例"><a href="#三大不安全案例" class="headerlink" title="三大不安全案例"></a>三大不安全案例</h3><p>先来分析抢票的过程:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBuyTicket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyTicket station = <span class="keyword">new</span> BuyTicket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(station, <span class="string">"我"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(station, <span class="string">"你"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(station, <span class="string">"黄牛"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            buy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 拿到了 "</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我 拿到了 10</span><br><span class="line">你 拿到了 8</span><br><span class="line">黄牛 拿到了 9</span><br><span class="line">我 拿到了 7</span><br><span class="line">你 拿到了 6</span><br><span class="line">黄牛 拿到了 5</span><br><span class="line">我 拿到了 4</span><br><span class="line">你 拿到了 3</span><br><span class="line">黄牛 拿到了 2</span><br><span class="line">我 拿到了 1</span><br><span class="line">你 拿到了 0</span><br><span class="line">黄牛 拿到了 -1</span><br></pre></td></tr></table></figure>

<p>为什么会出现-1呢? 当票还剩一张时, 每个人看到的都是1, 对它进行了重复操作, 所以变成了-1. 这显然说明线程是不安全的.</p>
<p>再来看一个取钱的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeBank</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account(<span class="number">100</span>, <span class="string">"基金"</span>);</span><br><span class="line"></span><br><span class="line">        Drawing you = <span class="keyword">new</span> Drawing(account, <span class="number">50</span>, <span class="string">"你"</span>, <span class="number">50</span>);</span><br><span class="line">        Drawing wife = <span class="keyword">new</span> Drawing(account, <span class="number">100</span>, <span class="string">"girlfriend"</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        you.start();</span><br><span class="line">        wife.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个银行账户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> money, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟取款</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drawing</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    Account account;</span><br><span class="line">    <span class="comment">// 取了多少钱</span></span><br><span class="line">    <span class="keyword">int</span> drawingMoney;</span><br><span class="line">    <span class="comment">// 现在手里有多少钱</span></span><br><span class="line">    <span class="keyword">int</span> nowMoney;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Drawing</span><span class="params">(Account account, <span class="keyword">int</span> drawingMoney, String name, <span class="keyword">int</span> nowMoney)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawingMoney = drawingMoney;</span><br><span class="line">        <span class="keyword">this</span>.nowMoney = nowMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取钱</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (account.money - drawingMoney &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"钱不够, 取不了"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 卡内余额</span></span><br><span class="line">        account.money = account.money - drawingMoney;</span><br><span class="line">        nowMoney = nowMoney + drawingMoney;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"余额为: "</span> + account.money);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 手里的钱 "</span> + nowMoney);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">余额为: -50</span><br><span class="line">余额为: 0</span><br><span class="line">你 手里的钱 100</span><br><span class="line">girlfriend 手里的钱 150</span><br></pre></td></tr></table></figure>

<p>集合中有不少都是线程不安全的, 比如<code>List</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(Thread.currentThread().getName());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按常理来讲, 列表中应该添加了1000个元素, 但是实际的输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">401</span><br></pre></td></tr></table></figure>

<p>可能是因为主线程中的打印操作执行得过早, 还没等线程全部加进去, 那我们添加一个延时, 给足添加的时间:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(Thread.currentThread().getName());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里给了五秒钟, 足够将所有线程添加到列表中了, 输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">992</span><br></pre></td></tr></table></figure>

<p>分析原因是某一时间两个元素添加到了列表的同一位置, 然后覆盖掉了一个.</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>解决上述的不安全案例, 所用的方法就是同步</p>
<p>由于我们可以通过private关键字来保证数据对象只能被方法访问, 所以我们只需要针对方法提出一套机制, 这套机制就是 <strong>synchronized</strong> 关键字, 它包括两种方法: </p>
<p>synchronized 方法 和 synchronized 块.</p>
<blockquote>
<p>同步方法: <strong>public synchronized void method(int args){}</strong></p>
</blockquote>
<p>synchronized 方法控制对”对象”的访问, 每个对象对应一把锁, 每个 synchronized 方法都必须获得调用该方法的对象的锁才能执行, 否则线程会阻塞, 方法一旦执行, 就独占该锁, 直到该方法返回才会释放锁, 后面被阻塞的线程才能获得这个锁, 继续执行.</p>
<blockquote>
<p>缺陷: <strong>若将一个大的方法申明为synchronized将会影响效率</strong></p>
</blockquote>
<p><strong>在使用synchronize修饰方法时要注意以下几点:</strong></p>
<ol>
<li><p>synchronized关键字不能继承.</p>
<p>虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。这两种方式的例子代码如下：</p>
<ul>
<li>在子类方法中加上synchronized关键字:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在子类方法中调用父类的同步方法:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; <span class="keyword">super</span>.method();   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在定义接口方法时不能使用synchronized关键字。</p>
</li>
<li><p>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。</p>
</li>
</ol>
<h4 id="修饰一个静态方法"><a href="#修饰一个静态方法" class="headerlink" title="修饰一个静态方法"></a>修饰一个静态方法</h4><p>Synchronized也可修饰一个静态方法，用法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类的所有对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + (count++));</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      method();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SyncThread syncThread1 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">SyncThread syncThread2 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(syncThread1, <span class="string">"SyncThread1"</span>);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(syncThread2, <span class="string">"SyncThread2"</span>);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SyncThread1:0</span><br><span class="line">SyncThread1:1</span><br><span class="line">SyncThread1:2</span><br><span class="line">SyncThread1:3</span><br><span class="line">SyncThread1:4</span><br><span class="line">SyncThread2:5</span><br><span class="line">SyncThread2:6</span><br><span class="line">SyncThread2:7</span><br><span class="line">SyncThread2:8</span><br><span class="line">SyncThread2:9</span><br></pre></td></tr></table></figure>

<p>syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁。这与Demo1是不同的。</p>
<h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><p>同步块: <strong>synchronized(Obj) {}</strong></p>
<p><code>Obj</code> 称之为 <strong>同步监视器</strong></p>
<ul>
<li>Obj 可以是任何对象, 但是推荐使用共享资源作为同步监视器</li>
<li>同步方法中无需指定同步监视器, 因为同步方法的同步监视器就是this, 就是这个对象本身, 或者是 class</li>
</ul>
<p>同步监视器的执行过程:</p>
<ol>
<li>第一个线程访问, 锁定同步监视器, 执行其中代码</li>
<li>第二个线程访问, 发现同步监视器被锁定, 无法访问</li>
<li>第一个线程访问完毕, 解锁同步监视器</li>
<li>第二个线程访问, 发现同步监视器没有锁, 然后锁定并访问</li>
</ol>
<p>对于三个不安全的案例进行修改, 抢票的案例中, 把买票的方法加上关键词 synchronized 即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步方法, 锁的是this</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 拿到了 "</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你 拿到了 10</span><br><span class="line">我 拿到了 9</span><br><span class="line">黄牛 拿到了 8</span><br><span class="line">我 拿到了 7</span><br><span class="line">你 拿到了 6</span><br><span class="line">你 拿到了 5</span><br><span class="line">我 拿到了 4</span><br><span class="line">我 拿到了 3</span><br><span class="line">黄牛 拿到了 2</span><br><span class="line">我 拿到了 1</span><br></pre></td></tr></table></figure>

<p>对于银行取钱的案例进行修改, 使用同步块, 将共用的账户资源作为同步监视器, 然后将取钱的过程放在代码块中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取钱</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (account)&#123;</span><br><span class="line">        <span class="keyword">if</span> (account.money - drawingMoney &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"钱不够, 取不了"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 卡内余额</span></span><br><span class="line">        account.money = account.money - drawingMoney;</span><br><span class="line">        nowMoney = nowMoney + drawingMoney;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"余额为: "</span> + account.money);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 手里的钱 "</span> + nowMoney);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">余额为: 50</span><br><span class="line">你 手里的钱 100</span><br><span class="line">钱不够, 取不了</span><br></pre></td></tr></table></figure>

<p>对不安全的集合案例进行修改, 把list作为同步监视器即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                    list.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出也正常了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure>

<p>以下两个写法是等价的:</p>
<p>写法一:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法二:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>多个线程各自占有一些共享资源, 并且互相等待其他线程占有的资源才能运行, 而导致两个或者多个线程都在等待对方释放资源, 都停止执行的情形. 某一个同步块同时拥有 <strong>两个以上对象的锁</strong> 时, 就可能会发生死锁的问题.</p>
<p>下面写一个互相抱着对方的锁的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Makeup g1 = <span class="keyword">new</span> Makeup(<span class="number">0</span>, <span class="string">"灰姑娘"</span>);</span><br><span class="line">        Makeup g2 = <span class="keyword">new</span> Makeup(<span class="number">1</span>, <span class="string">"白雪公主"</span>);</span><br><span class="line"></span><br><span class="line">        g1.start();</span><br><span class="line">        g2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lipstick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mirror</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Makeup</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要的资源只有一份, 用static来保证</span></span><br><span class="line">    <span class="keyword">static</span> Lipstick lipstick = <span class="keyword">new</span> Lipstick();</span><br><span class="line">    <span class="keyword">static</span> Mirror mirror = <span class="keyword">new</span> Mirror();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> choice;</span><br><span class="line">    String girlName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Makeup</span><span class="params">(<span class="keyword">int</span> choice, String girlName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.choice = choice;</span><br><span class="line">        <span class="keyword">this</span>.girlName = girlName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeup();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeup</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lipstick) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.girlName + <span class="string">" 获得口红的锁 "</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (mirror) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.girlName + <span class="string">" 获得镜子的锁"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mirror) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.girlName + <span class="string">" 获得镜子的锁"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (lipstick) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">this</span>.girlName + <span class="string">" 获得口红的锁 "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿g1来说, 因为她抱着口红的锁, 想要镜子的锁, 但是镜子的锁拿不到, 所以同步块一直执行不完, g2也是这样, 相互僵持着, 发生死锁.</p>
<h3 id="死锁的避免方法"><a href="#死锁的避免方法" class="headerlink" title="死锁的避免方法"></a>死锁的避免方法</h3><p>产生死锁的四个必要条件:</p>
<ol>
<li><strong>互斥条件:</strong> 一个资源每次只能被一个进程使用</li>
<li>*<em>请求与保持条件: *</em> 一个进程因请求资源而阻塞时, 对已获得的资源保持不放</li>
<li>*<em>不剥夺条件: *</em> 进程已获得的资源, 在未使用完之前, 不能强行剥夺</li>
<li>*<em>循环等待条件: *</em> 若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<p>上面的四个必要条件中, 我们只要想办法破其中任意一个或多个条件就可以避免死锁的发生</p>
<hr>
<h2 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock(锁)"></a>Lock(锁)</h2><p>从JDK 5.0 开始, Java 提供了更强大的线程同步机制—-通过显示定义同步锁对象来实现同步, 同步锁使用Lock对象充当.</p>
<ul>
<li>java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具. 锁提供了对共享资源的独占访问, 每次只能有一个线程对Lock 对象加锁, 线程开始访问共享资源之前应先获得Lock 对象</li>
<li>ReentrantLock 类实现了 Lock, 他拥有与 synchronized 相同的并发性和内存语义, 在实现线程安全的控制中, 比较常用的是ReentrantLock, 可以显式加锁, 释放锁.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestLock2 testLock2 = <span class="keyword">new</span> TestLock2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2, <span class="string">"aaa"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2, <span class="string">"bbb"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2, <span class="string">"ccc"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock锁</span></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (ticketNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">" 抢到了 "</span> + ticketNums--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aaa 抢到了 10</span><br><span class="line">ccc 抢到了 9</span><br><span class="line">bbb 抢到了 8</span><br><span class="line">bbb 抢到了 7</span><br><span class="line">aaa 抢到了 6</span><br><span class="line">ccc 抢到了 5</span><br><span class="line">bbb 抢到了 4</span><br><span class="line">aaa 抢到了 3</span><br><span class="line">ccc 抢到了 2</span><br><span class="line">ccc 抢到了 1</span><br></pre></td></tr></table></figure>

<p>利用重入锁进行编码的流程为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function">pubilc <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//保证线程安全的代码</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="comment">// 如果同步代码有异常, 要将unlock()写入finally块中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronized-与-Lock-的对比"><a href="#synchronized-与-Lock-的对比" class="headerlink" title="synchronized 与 Lock 的对比"></a>synchronized 与 Lock 的对比</h3><ul>
<li><p>Lock 是显式锁(手动开启和关闭锁, 别忘记关闭), synchronized 是隐式锁, 出了作用域自动释放</p>
</li>
<li><p>Lock 只有代码块锁, synchronize有代码块锁和方法锁</p>
</li>
<li><p>使用Lock锁, JVM将花费较少时间来调度线程, 性能更好. 并且具有更好的扩展性(提供更多的子类)</p>
</li>
<li><p>优先使用顺序:</p>
<p><strong>Lock &gt; 同步代码块(已经进入了方法体, 分配了相应资源) &gt; 同步方法(在方法体之外)</strong></p>
</li>
</ul>
<hr>
<h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p>应用场景: 生产者和消费者问题</p>
<ul>
<li>假设仓库中只能存放一件产品, 生产者将生产出来的产品放入仓库, 消费者将仓库中产品取走消费</li>
<li>如果仓库中没有产品, 则生产者将产品放入仓库, 否则停止生产并等待, 直到仓库中的产品被消费者取走为止</li>
<li>如果仓库中放有产品, 则消费者可以将产品取走消费, 否则停止消费并等待, 直到仓库中再次放入产品为止</li>
</ul>
<p>这是一个线程同步问题, 生产者和消费者共享同一个资源, 并且生产者和消费者之间相互依赖, 互为条件:</p>
<ul>
<li>对于生产者, 没有生产产品之前, 要通知消费者等待, 而生产了产品之后, 又需要通知消费者消费</li>
<li>对于消费者, 在消费之后, 要通知生产者已经结束消费, 需要生产新的产品以供消费</li>
<li>在生产者消费者问题中, 仅有 synchronized是不够的<ul>
<li>synchronized可阻止并发更新同一个共享资源, 实现了同步</li>
<li>synchronized不能用来实现不同线程之间的信息传递(通信)</li>
</ul>
</li>
</ul>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><p>Java提供了几个方法解决线程之间的通信问题</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>wait()</td>
<td>表示线程一直等待, 直到其他线程通知, 与sleep不同, 会释放锁</td>
</tr>
<tr>
<td>wait(long timeout)</td>
<td>指定等待的毫秒数</td>
</tr>
<tr>
<td>notify()</td>
<td>唤醒一个处于等待状态的线程</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>唤醒同一个对象上所有调用wait()方法的线程, 优先级高的线程优先调度</td>
</tr>
</tbody></table>
<p><strong>注意: 均是Object类的方法, 都只能在同步方法或者同步代码块中使用, 否则会抛出异常IllegalMonitorStateException</strong></p>
<h3 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h3><p>并发协作模型”生产者/ 消费者模式” –&gt; 管程法</p>
<ul>
<li>生产者: 负责生产数据的模块(可能是方法, 对象, 线程, 进程);</li>
<li>消费者: 负责处理数据的模块(可能是方法, 对象, 线程, 进程);</li>
<li>缓冲区: 消费者不能直接使用生产者的数据, 他们之间有个缓冲区</li>
</ul>
<p><strong>生产者将生产好的数据放入缓冲区, 消费者从缓冲区拿出数据</strong></p>
<p>写一个例子来理解管程法的过程. 这是一个炸鸡店的例子. 假设库存最大能保留十只鸡, 多于十只则生产者不生产, 生产者线程<code>wait()</code>, 少于零只则消费者不消费,消费者线程<code>wait()</code>. 当消费者成功消费一个炸鸡, 就<code>notifyAll()</code> 一下, 当生产者成功生产一个炸鸡, 就<code>notifyAll()</code> 一下.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者, 消费者, 产品, 缓冲区</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynContainer container = <span class="keyword">new</span> SynContainer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Productor(container).start();</span><br><span class="line">        <span class="keyword">new</span> Consumer(container).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            container.push(<span class="keyword">new</span> Chicken(i));</span><br><span class="line">            System.out.println(<span class="string">"生产--&gt; "</span> + i + <span class="string">" 只鸡"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SynContainer container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消费了--&gt; "</span> + container.pop().id + <span class="string">" 只鸡"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chicken</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chicken</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器计数器</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要一个容器大小</span></span><br><span class="line">    Chicken[] chickens = <span class="keyword">new</span> Chicken[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者放入产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Chicken chicken)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果容器满了, 就要等待消费者消费</span></span><br><span class="line">        <span class="keyword">if</span> (count == chickens.length) &#123;</span><br><span class="line">            <span class="comment">// 通知消费者消费, 生产者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有满, 我们就需要丢入产品</span></span><br><span class="line">        chickens[count] = chicken;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以通知消费者消费了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者消费产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Chicken <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断能否消费</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 等待生产者生产, 消费者等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果可以消费</span></span><br><span class="line">        Chicken chicken = chickens[count - <span class="number">1</span>];</span><br><span class="line">        count--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 吃完了, 通知生产者生产</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> chicken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号灯法"><a href="#信号灯法" class="headerlink" title="信号灯法"></a>信号灯法</h3><p>并发协作模型”生产者/ 消费者模式” –&gt; 信号灯法</p>
<p>通过标志位解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Player(tv).start();</span><br><span class="line">        <span class="keyword">new</span> Watcher(tv).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者-- 演员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">"快乐大本营"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.tv.play(<span class="string">"新闻联播"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者-- 观众</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Watcher</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            tv.watch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品-- 节目</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 演员表演, 观众等待 T</span></span><br><span class="line">    <span class="comment">// 观众观看, 演员等待 F</span></span><br><span class="line">    String voice;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表演</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String voice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"演员表演了 "</span> + voice);</span><br><span class="line">        <span class="comment">// 通知观众观看</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">this</span>.voice = voice;</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"观看了 "</span> + voice);</span><br><span class="line">        <span class="comment">// 通知演员表演</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">this</span>.flag = !<span class="keyword">this</span>.flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">演员表演了 快乐大本营</span><br><span class="line">观看了 快乐大本营</span><br><span class="line">演员表演了 新闻联播</span><br><span class="line">观看了 新闻联播</span><br><span class="line">演员表演了 快乐大本营</span><br><span class="line">观看了 快乐大本营</span><br><span class="line">演员表演了 新闻联播</span><br><span class="line">观看了 新闻联播</span><br><span class="line">演员表演了 快乐大本营</span><br><span class="line">观看了 快乐大本营</span><br><span class="line">演员表演了 新闻联播</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ul>
<li><strong>背景</strong>: 经常创建和销毁, 使用量特别大的资源, 比如并发情况下的线程, 对性能影响很大</li>
<li>*<em>思路: *</em> 提前创建好多个线程, 放入线程池中, 使用时直接获取, 使用完放回池中. 可以避免频繁创建销毁, 实现重复利用. 类似生活中的公共交通工具</li>
<li><strong>好处:</strong><ul>
<li>提高响应速度(减少了创建新线程的时间)</li>
<li>降低资源消耗(重复利用线程池中线程, 不需要每次都创建)</li>
<li>便于线程管理<ul>
<li>corePoolSize: 核心池的大小</li>
<li>maximumPoolSize: 最大线程数</li>
<li>keepAliveTime: 线程没有任务时最多保持多长时间会终止</li>
</ul>
</li>
</ul>
</li>
<li>JDK 5.0 起提供了线程池相关API: <strong>ExecutorService</strong> 和 <strong>Executors</strong></li>
<li>ExecutorServive: 真正的线程池接口. 常见子类ThreadPoolExecutor<ul>
<li>void execute(Runnable command): 执行任务/命令, 没有返回值, 一般用来执行Runnable</li>
<li><T> Future<T> submit(Callable<T> task): 执行任务, 有返回值, 一般又来执行Callable</li>
<li>void shutdown() : 关闭连接池</li>
</ul>
</li>
<li>Executors: 工具类, 线程池的工厂类, 用于创建并返回不同类型的线程池 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建服务, 创建线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 关闭连接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
