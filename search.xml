<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>29.两数相除</title>
    <url>/2020/07/04/29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: dividend &#x3D; 10, divisor &#x3D; 3</span><br><span class="line">输出: 3</span><br><span class="line">解释: 10&#x2F;3 &#x3D; truncate(3.33333..) &#x3D; truncate(3) &#x3D; 3</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">输出: -2</span><br><span class="line">解释: 7&#x2F;-3 &#x3D; truncate(-2.33333..) &#x3D; -2</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>首先想到的是对被除数循环递减, 记录能减多少次就好了, 但是明显效率太低.</p>
<p>那么这个循环递减的过程就可以使用移位运算优化一下.<strong>计算机在做移位时效率很高, 向左移1位相当于乘以2, 向右移1位相当于除以2</strong></p>
<p>设循环初始值为<code>i = 31</code>, 每次循环都比较<code>dividend&gt;&gt;i</code> 和 <code>devisor</code>的大小, 起初结果肯定是小于关系. 一旦变成了等于或大于关系, 则说明商至少是<code>2^i</code></p>
<p>以100除以3为例说明:</p>
<p><code>i</code>从31, 30, …,开始循环, 当<code>i=5</code>时, 有<code>(100&gt;&gt;5)&gt;=3</code>, 即<code>100/32&gt;=3</code>, 说明100中至少有32个3, 然后让余数4继续完成遍历.</p>
<p>这样的方法最多只只需要遍历31个数字即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> negative = (dividend ^ divisor) &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> t = Math.abs((<span class="keyword">long</span>) dividend);</span><br><span class="line">        <span class="keyword">long</span> d = Math.abs((<span class="keyword">long</span>) divisor);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((t &gt;&gt; i) &gt;= d) &#123;</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                t -= d &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? -res : res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>287.寻找重复数</title>
    <url>/2020/07/03/287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>之所以不使用暴力遍历查找和哈希表记录, 是因为时间复杂度或者空间复杂度超出要求.</p>
<p>使用<code>cnt[i]</code>表示<code>nums[]</code>数组中小于等于<code>i</code> 的数有多少个, 假设我们重复的数是<code>target</code>, 那么<code>[1, target-1]</code>里的所有数满足<code>cnt[i]&lt;=i</code>, <code>[target, n]</code>里的所有数满足<code>cnt[i]&gt;i</code>, 具有单调性.</p>
<p>以示例1为例, 列出每个数字的<code>cnt</code>值:</p>
<table>
<thead>
<tr>
<th align="center">nums</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cnt</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
</tbody></table>
<p>示例中重复的整数是2, 我们可以看到[1, 1]中的数满足<code>cnt[i]&lt;=i</code>, [2, 4]中的数满足<code>cnt[i]&gt;i</code></p>
<p>一旦知道了<code>cnt[i]</code>数组的单调性和以上的大小关系, 就可以使用二分查找来找到重复的数. 对于所有测试用例, 考虑一下两种情况:</p>
<ul>
<li>如果测试用例的数组中 <code>target</code> 出现了两次，其余的数各出现了一次，这个时候肯定满足上文提及的性质，因为小于<code>target</code> 的数 <code>i</code>满足<code>cnt[i]=i</code>，大于等于<code>target</code> 的数 <code>j</code>满足 <code>cnt[j]=j+1</code></li>
<li>如果测试用例的数组中<code>target</code>出现了三次及以上，那么必然有一些数不在 <code>nums[]</code>数组中了，这个时候相当于我们用 <code>target</code> 去替换了这些数，我们考虑替换的时候对 <code>cnt[]</code>数组的影响。如果替换的数<code>i</code>小于 <code>target</code>，那么 <code>[i,target-1]</code> 的 <code>cnt</code> 值均减一，其他不变，满足条件。如果替换的数 <code>j</code>大于等于 <code>target</code>，那么<code>[target, j-1]</code>的 <code>cnt</code> 值均加一，其他不变，亦满足条件。</li>
</ul>
<p><strong>总结来说就是, 对于每个区间[left, right], 根据<code>mid</code>计算出<code>cnt</code>的值, 然后比较<code>mid</code>和<code>cnt</code>的大小, 以比较的结果调整左右边界</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= mid) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= mid) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>153.寻找旋转排序数组中的最小值</title>
    <url>/2020/07/04/153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>因为不存在重复的数字, 所以只需要考虑大于和等于的情况, 比较对象为<code>nums[right]</code></p>
<ol>
<li><p>循环二分： 设置 <code>i</code>,<code>j</code> 指针分别指向<code>numbers</code> 数组左右两端，<code>m = (i + j) / 2</code> 为每次二分的中点（ “/“ 代表向下取整除法），可分为以下三种情况：</p>
<ol>
<li><p>当<code>numbers[m] &gt; numbers[j]</code>时： <code>m</code> 一定在 左排序数组 中，即旋转点 <code>x</code>一定在<code>[m + 1, j]</code>闭区间内，因此执行<code>i = m + 1</code>；</p>
</li>
<li><p>当 <code>numbers[m] &lt; numbers[j]</code>时： <code>m</code> 一定在 右排序数组 中，即旋转点 <code>x</code> 一定在<code>[i, m]</code> 闭区间内，因此执行<code>j = m</code>；</p>
</li>
</ol>
</li>
<li><p>返回值： 当<code>i = j</code>时跳出二分循环，并返回 <code>numbers[i]</code>即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>240.搜索二维矩阵Ⅱ</title>
    <url>/2020/07/08/240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%E2%85%A1/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。<br>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p>
<p><strong>示例一</strong>：</p>
<p>给定 target = 5，返回 true。</p>
<p><strong>示例二</strong>：</p>
<p>给定 target = 20，返回 false。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="左下角出发遍历法"><a href="#左下角出发遍历法" class="headerlink" title="左下角出发遍历法"></a>左下角出发遍历法</h2><p>根据本文所描述的特征, 每一行从左到右递增, 每一列从上到下递增, 所以可以根据贪婪思想决定每一步怎么走, 即:</p>
<ul>
<li>当<code>matrix[i][j]&gt;target</code>, 则直接删除改行数组, <code>i--</code>, 因为只能往上走才能找到更小的数</li>
<li>当<code>matrix[i][j]&lt;target</code>, 则直接删除该列数组, <code>j++</code>, 因为只能往右走才能找到更大的数</li>
<li>若相等, 直接返回<code>true</code></li>
</ul>
<p>越界说明没找到, 返回<code>false</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt;= matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二分查找-较慢"><a href="#二分查找-较慢" class="headerlink" title="二分查找(较慢)"></a>二分查找(较慢)</h2><p>因为矩阵已经排过序, 所以可采用二分查找的方法.</p>
<p>思路是遍历每一行的数组进行查找, 每当遍历到新的一行, 如果该行第一个元素都比目标值大, 那么直接返回<code>false</code>, 因为这已经是目前还没有遍历的数中最小的了.</p>
<p>如果该行数组最右的元素都比目标值小, 则直接开始遍历下一行, 因为这已经是这一行最大的数了, 没有查找的必要.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix2</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>]&gt;target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][matrix[<span class="number">0</span>].length-<span class="number">1</span>]&lt;target)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> col = binarySearch1(matrix[i], target);</span><br><span class="line">            <span class="keyword">if</span> (col!=-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span>[] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid]&lt;target) i = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid]&gt;target) j = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>315.计算右侧小于当前元素的个数</title>
    <url>/2020/07/08/315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [5,2,6,1]</span><br><span class="line">输出: [2,1,1,0] </span><br><span class="line">解释:</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1).</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1).</span><br><span class="line">6 的右侧有 1 个更小的元素 (1).</span><br><span class="line">1 的右侧有 0 个更小的元素.</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>这道题目要想到二分查找的一个性质: 在一个排序数组中, 可以通过二分查找目标值的左边界来表示数组中有多少个元素小于目标值</p>
<p>比如一个数组为:<code>[1, 2, 2, 4, 5, 6]</code>, 查找数字<code>4</code>的返回值是<code>3</code>, 结果不言而喻.</p>
<p>那么我们需要想办法创造出排序数组的条件.</p>
<p>首先初始化一个空的列表用于存放遍历后的元素, 因为这道题目是考察右侧有多少个更小的元素, 所以要从右往左遍历, 这能保证每遍历到一个元素, 列表中的元素都位于它的右边, 只需要在它们之间查找即可.</p>
<p>二分查找的结果即为元素右边有多少更小的值, 并将其插入到合适的位置使列表仍然是有序的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res.addFirst(binarySearch(list, nums[i]));</span><br><span class="line">            list.add(binarySearch(list, nums[i]), nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = list.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (list.get(mid) &gt;= target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (list.get(mid) &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在做这道题时因为要用到向列表中某个位置插入元素, 找响应的<code>insert()</code> 方法, 怎么也找不到, 原来直接用<code>add()</code> 方法就好了, 如果只填一个元素, 默认为列表尾部添加元素, 如果在前面写上索引, 即为在指定位置插入元素, 剩余元素后移.</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>32.最长有效括号</title>
    <url>/2020/07/04/32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>刚做这道题时忽略了题目中<strong>子串</strong>的要求, 直接求了共有多少有效括号, 提交后才发现.</p>
<p>首先想到的还是用栈来解决有效括号的问题, 这道题麻烦在必须是子串才可以, 字符前后需要建立联系.</p>
<p>具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：</p>
<ul>
<li>对于遇到的每个<code>(</code> ，我们将它的下标放入栈中</li>
<li>对于遇到的每个<code>)</code>，我们先弹出栈顶元素表示匹配了当前右括号：<ul>
<li>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</li>
<li>如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」</li>
</ul>
</li>
</ul>
<p>需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1−1 的元素。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/1.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/2.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/4.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/5.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/6.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/7.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/8.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/9.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/10.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/11.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>)</span><br><span class="line">                stack.push(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = Math.max(max, i - stack.peek());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb小记</title>
    <url>/2020/07/05/JavaWeb%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h2><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li><p>编写一个类去实现Filter接口</p>
</li>
<li><p>实现过滤方法doFilter()</p>
</li>
<li><p>到web.xml中去配置Filter的拦截路径</p>
</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li><p>构造器方法</p>
</li>
<li><p>init 初始化方法</p>
<p> 第1,2步, 在web工程启动的时候执行(Filter已经创建)</p>
</li>
<li><p>doFilter 过滤方法</p>
<p> 第3步, 每次拦截到请求就会执行</p>
</li>
<li><p>destroy 销毁</p>
<p> 第4步, 停止web工程的时候,就会执行(停止web工程, 也会销毁Filter过滤器)</p>
</li>
</ol>
<h3 id="FilterConfig类"><a href="#FilterConfig类" class="headerlink" title="FilterConfig类"></a>FilterConfig类</h3><p>见名知义, 它是Filter过滤器的配置文件类</p>
<p>Tomcat 每次创建Filter的时候, 也会同时创建一个FilterConfig类, 这里包含了Filter配置文件的配置信息</p>
<p>FilterConfig类的作用是获取Filter过滤器的配置内容:</p>
<ol>
<li>获取Filter的名称 <code>filter-name</code>的内容</li>
</ol>
<pre><code>就是xml文件中`filter-name`的值</code></pre><ol>
<li><p>获取在Filter中配置的<code>init-param</code>初始化参数</p>
<p>  就是xml文件中自定义的’init-param’初始化参数</p>
</li>
<li><p>获取<code>ServletContext</code>对象</p>
<p> 获取ServletContext对象</p>
</li>
</ol>
<h3 id="FilterChain过滤器链"><a href="#FilterChain过滤器链" class="headerlink" title="FilterChain过滤器链"></a>FilterChain过滤器链</h3><p>  Filter:   过滤器</p>
<p>  Chain:   链, 链条</p>
<p>  FilterChain:   就是过滤器链(多个过滤器如何一起工作)</p>
<p>程序执行顺序:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/46a8eb9c7e647c684c0b92d098727b9b.png" alt=""></p>
<h3 id="Filter的拦截路径"><a href="#Filter的拦截路径" class="headerlink" title="Filter的拦截路径"></a>Filter的拦截路径</h3><ol>
<li>精确匹配</li>
</ol>
<pre><code>&lt;url-pattern&gt;/target.jsp&lt;/url-pattern&gt;

以上配置的路径, 表示请求地址必须为: http://ip:port/工程路径/target.jsp</code></pre><ol start="2">
<li><p>目录匹配</p>
<p> <url-pattern>/admin/*</url-pattern></p>
<p> 以上配置的路径, 表示请求地址必须为: <a href="http://ip:port/工程路径/admin/">http://ip:port/工程路径/admin/</a>*</p>
</li>
<li><p>后缀名匹配</p>
<p> <url-pattern>*.html</url-pattern></p>
<p> 以上配置的路径, 表示请求地址必须以 .html结尾才会拦截到</p>
</li>
</ol>
<p>Filter过滤器只关心请求的地址是否匹配,不关心请求的资源是否存在</p>
<h2 id="ThreadLocal-的使用"><a href="#ThreadLocal-的使用" class="headerlink" title="ThreadLocal 的使用"></a>ThreadLocal 的使用</h2><p>  ThreaLocal 的作用,它可以解决多线程的数据安全问题</p>
<p>  ThreaLocal 它可以给当前线程关联一个数据(可以是普通变量,可以是对象,也可以是数组,集合)</p>
<h3 id="ThreadLocal-的特点"><a href="#ThreadLocal-的特点" class="headerlink" title="ThreadLocal 的特点"></a>ThreadLocal 的特点</h3><ol>
<li><p>ThreadLocal 可以为当前线程关联一个数据. (它可以像Map一样存取数据, Key为当前线程)</p>
</li>
<li><p>每一个ThreadLocal对象, 只能为当前线程关联一个数据, 如果要为当前线程关联多个数据, 就需要使用多ThreadLocal对象实例</p>
</li>
<li><p>每个ThreadLocal对象实例定义的时候, 一般都是static 类型</p>
</li>
<li><p>ThreadLocal中保存的数据, 在线程销毁后.  会由JVM虚拟机自动释放.</p>
</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/0eaee7d2aeea706e84a7691e49a43806.png" alt=""></p>
<p>*<em>使用Filter过滤器统一给所有的 Service 方法都加上try-catch *</em></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3e75caf50d4eb4d75addbe3f17244f61.png" alt=""></p>
<p><strong>将所有异常都统一交给Tomcat，让Tomcat展示友好的错误信息页面</strong></p>
<p>在web.xml中我们可以通过错误页面配置来进行管理。</p>
<error-page>

</error-page>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON是一种轻量级的数据交换格式。易于人阅读和编写，同时也易于机器解析和生成。JSON采用完全独立于语言的文本格式，而且很多语言都提供了对JSON的支持。</p>
<p>JSON是一种轻量级的数据交换格式, 轻量级指的是跟xml做比较.</p>
<p>数据交换指的是客户端和服务器之间业务数据的传递格式.</p>
<h3 id="JSON的定义"><a href="#JSON的定义" class="headerlink" title="JSON的定义"></a>JSON的定义</h3><p>JSON是由键值对组成, 并且由大括号包围, 每个键用引号引起来, 键和值之间使用冒号进行分隔, 多组键值对之间使用逗号进行分隔.</p>
<h3 id="JSON的访问"><a href="#JSON的访问" class="headerlink" title="JSON的访问"></a>JSON的访问</h3><p>json本身是一个对象, json中的key我们可以理解为是对象中的一个属性, json中的key 访问就跟访问对象的属性一样: json对象.key</p>
<h3 id="JSON-在-JAVA-中的应用"><a href="#JSON-在-JAVA-中的应用" class="headerlink" title="JSON 在 JAVA 中的应用"></a>JSON 在 JAVA 中的应用</h3><h4 id="javabean-和-json-的互转"><a href="#javabean-和-json-的互转" class="headerlink" title="javabean 和 json 的互转"></a>javabean 和 json 的互转</h4><ol>
<li><p>自定义一个<code>Javabean</code>, 创建一个示例对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"aaa!"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>Gson</code>对象, 并使用<code>toJson</code>方法将<code>person</code>对象转换成<code>json</code>对象.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">String personJsonString = gson.toJson(person);</span><br><span class="line">System.out.println(personJsonString);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704165732.png" alt=""></p>
</li>
<li><p>同样可以将字符串转换回<code>Person</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fromJson把json字符串转换回Java对象</span></span><br><span class="line"><span class="comment">// 第一个参数是json字符串</span></span><br><span class="line"><span class="comment">// 第二个参数是转换回去的Java对象</span></span><br><span class="line">Person person1 = gson.fromJson(personJsonString, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(person1);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
</li>
</ol>
<p>   <img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704165738.png" alt=""></p>
<p>   可以看出格式是使用了<code>Person</code>类的<code>toString</code>格式, 说明已经转回.</p>
<h4 id="List-和-json-的互传"><a href="#List-和-json-的互传" class="headerlink" title="List 和 json 的互传"></a>List 和 json 的互传</h4><ol>
<li><p>还是使用<code>Person</code>类,  定义多个示例对象放入<code>List</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"cx"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>Gson</code>对象, 依然使用<code>toJson</code>的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"></span><br><span class="line">String personListJsonString = gson.toJson(personList);</span><br><span class="line">System.out.println(personListJsonString);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704165836.png" alt=""></p>
</li>
<li><p>转回<code>Person</code>列表时, 还是使用<code>fromJson</code>方法, 但是第二个形参需要注意, <strong>不是</strong><code>personList.getClass()</code>, 那该将什么作为列表的格式呢.</p>
<blockquote>
<p>gson包自带了一个<code>TypeToken</code>类, 使用这个类可以解决困惑</p>
<ol>
<li><p>首先创建一个新的类<code>PersonListType</code>, 然后继承<code>TypeToken</code>类, 注意填入的泛型为需要转回的类型:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704164430.png" alt=""></p>
<p>这个类放在这里就可以了.</p>
</li>
<li><p>我们去看一下<code>TypeTokken</code>的源码, 可以看到一个关键的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Type <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法返回的就是我们所需要的格式, 因为是继承了这个类, 直接使用就可以了. 这样就解决了<code>fromJson()</code>方法中第二个形参写什么的问题.</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; list = gson.fromJson(personListJsonString, <span class="keyword">new</span> PersonListType().getType());</span><br><span class="line">        System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704165843.png" alt=""></p>
</li>
</ol>
<h4 id="Map-和-json-的互转"><a href="#Map-和-json-的互转" class="headerlink" title="Map 和 json 的互转"></a>Map 和 json 的互转</h4><ol>
<li><p>创建哈希表, 然后将<code>Person</code>示例对象添加进去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Person&gt; personMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">personMap.put(<span class="number">1</span>, <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>));</span><br><span class="line">personMap.put(<span class="number">2</span>, <span class="keyword">new</span> Person(<span class="number">2</span>, <span class="string">"cx"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>Gson</code>对象, 使用<code>toJson</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">String personMapJsonString = gson.toJson(personMap);</span><br><span class="line">System.out.println(personMapJsonString);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704171016.png" alt=""></p>
<p>这里就要注意与<code>List</code>互换的区别了. <code>List</code>转换成<code>json</code>对象时, 是将多个<code>json</code>对象放到一个列表中, 而<code>Map</code>转过去之后, 变成了嵌套的形式. </p>
</li>
<li><p>转回<code>Map</code>形式, 方法与上面类似, 也是定义一个继承<code>TypeToken</code>的类, 然后将其放入<code>fromJson</code>方法的第二个形参中.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Person&gt; map = gson.fromJson(personMapJsonString, <span class="keyword">new</span> PersonMapType().getType());</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200704182530.png" alt=""></p>
</li>
</ol>
<h4 id="使用匿名内部类进行代码优化"><a href="#使用匿名内部类进行代码优化" class="headerlink" title="使用匿名内部类进行代码优化"></a>使用匿名内部类进行代码优化</h4><p>在与<code>List</code>和<code>Map</code>结构进行互换时, 都有专门定义一个类, 但都只是在声明时使用了一次, 所以可以使用匿名内部类来优化代码.以转回<code>Map</code>为例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Person&gt; map = gson.fromJson(personMapJsonString, <span class="keyword">new</span> TypeToken&lt;HashMap&lt;Integer, Person&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<h3 id="JSON-vs-XML"><a href="#JSON-vs-XML" class="headerlink" title="JSON vs XML"></a>JSON vs XML</h3><p>JSON 和 XML 都用于接收 web 服务端的数据, 在写法上有所不同</p>
<p>Json实例:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sites"</span>: [</span><br><span class="line">    &#123; <span class="attr">"name"</span>:<span class="string">"github"</span> , <span class="attr">"url"</span>:<span class="string">"www.github.com"</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">"name"</span>:<span class="string">"google"</span> , <span class="attr">"url"</span>:<span class="string">"www.google.com"</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">"name"</span>:<span class="string">"微博"</span> , <span class="attr">"url"</span>:<span class="string">"www.weibo.com"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML实例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sites</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>github<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.runoob.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>google<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.google.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>微博<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="tag">&lt;<span class="name">url</span>&gt;</span>www.weibo.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sites</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>两者的相同之处:</p>
<ul>
<li>JSON 和 XML 数据都是 “自我描述” ，都易于理解。</li>
<li>JSON 和 XML 数据都是有层次的结构</li>
<li>JSON 和 XML 数据可以被大多数编程语言使用</li>
</ul>
<p>两者不同之处:</p>
<ul>
<li>JSON 不需要结束标签</li>
<li>JSON 更加简短</li>
<li>JSON 读写速度更快</li>
<li>JSON 可以使用数组</li>
</ul>
<p>最大的不同之处:</p>
<p>XML 需要使用 XML 解析器来解析，JSON 可以使用标准的 JavaScript 函数来解析。</p>
<ul>
<li><p><code>JSON.parse()</code>: 将一个 JSON 字符串转换为 JavaScript 对象。</p>
</li>
<li><p><code>JSON.stringify()</code>: 于将 JavaScript 值转换为 JSON 字符串。</p>
</li>
</ul>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="AJAX定义"><a href="#AJAX定义" class="headerlink" title="AJAX定义"></a>AJAX定义</h3><p>AJAX即”Asynchronous Javascript And XML”(异步 JavaScript和XML), 是指一种创建交互式网页应用的网页开发技术.</p>
<p><strong>AJAX是一种浏览器通过js异步发起请求, 局部更新页面的技术</strong></p>
<p>异步请求能大大提升用户体验, 不同请求各自响应, 不需要排队等候</p>
<p>AJAX请求局部更新, 浏览器地址栏不会发生变化, 局部更新不会舍弃原来页面的内容</p>
<h3 id="原生AJAX实例"><a href="#原生AJAX实例" class="headerlink" title="原生AJAX实例"></a>原生AJAX实例</h3><ol>
<li><p>编写<code>AjaxServlet</code>类, 让它继承<code>BaseServlet</code>类。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705114824.png" alt=""></p>
<p>然后在<code>web.xml</code>文件中修改配置</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705115150.png" alt=""></p>
</li>
<li><p>在<code>ajax.html</code>页面中编写js代码设置<code>ajax</code>请求, 这里要用到<code>.open()</code>方法, 然后用<code>.send()</code>方法来发送请求.注释中写明了具体的步骤.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"cache-control"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Expires"</span> <span class="attr">content</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">			<span class="comment">// 在这里使用JavaScript语言发起Ajax请求, 访问服务器AjaxServlet中的javaScriptAjax</span></span></span><br><span class="line"><span class="actionscript">			<span class="function"><span class="keyword">function</span> <span class="title">ajaxRequest</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 				1、我们首先要创建XMLHttpRequest </span></span></span><br><span class="line"><span class="actionscript">				<span class="keyword">var</span> xmlhttprequest = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 				2、调用open方法设置请求参数</span></span></span><br><span class="line"><span class="actionscript">				xmlhttprequest.open(<span class="string">"Get"</span>, <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet?action=javaScriptAjax"</span>, <span class="literal">true</span>)</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 				3、调用send方法发送请求</span></span></span><br><span class="line">				xmlhttprequest.send();</span><br><span class="line"><span class="actionscript"><span class="comment">// 				4、在send方法前绑定onreadystatechange事件，处理请求完成后的操作。</span></span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>	</span><br><span class="line">		<span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"ajaxRequest()"</span>&gt;</span>ajax request<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div01"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>AjaxServlet</code>中编写请求处理方法. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">javaScriptAjax</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ajax请求过来了"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>点击<code>html</code>页面的请求按钮之后, 控制台输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705141743.png" alt=""></p>
<p>说明能够正确接收到网页发送的<code>ajax</code>请求.</p>
</li>
<li><p>向客户端发送信息, 采用<code>json</code>字符串的形式. 如果需要获取来自服务器的相应, 使用<code>XMLHttpRequest</code>对象的<code>responseText</code>或<code>responseXML</code>属性.</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>responseText</td>
<td>获得字符串形式的响应数据</td>
</tr>
<tr>
<td>responseXML</td>
<td>获得XML形式的响应数据</td>
</tr>
</tbody></table>
<p>当请求被发送到服务器时, 需要执行一些基于响应的任务. 每当<code>readyState</code>改变时, 就会触发<code>onreadystatechange</code>事件.</p>
<p><code>readyState</code>属性存有<code>XMLHttpRequest</code>的状态信息</p>
<p>下面是<code>XMLHttpRequest</code>对象的三个重要属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>onreadystatechange</td>
<td>存储函数(或函数名), 每当readyState属性改变时, 就会调用该函数</td>
</tr>
<tr>
<td>readyState</td>
<td>存有XMLHttpRequest的状态.从0到4发生变化</td>
</tr>
<tr>
<td>status</td>
<td>200:”OK”, 404:”未找到页面”</td>
</tr>
</tbody></table>
<p>其中<code>readyState</code>的值表达的含义为:</p>
<ul>
<li>0: 请求未初始化</li>
<li>1: 服务器连接已建立</li>
<li>2: 请求已接收</li>
<li>3: 请求处理中</li>
<li>4: 请求已完成, 且响应已就绪</li>
</ul>
<p>也就是说我们从客户端向服务器发送了请求, 服务器处理完成后发出了响应, 这个过程中都伴随着这三个属性的变化. </p>
<p>对服务器响应所执行的任务我们写在<code>onreadystatechange</code>事件中, 这里理所应当地添加上状态已就绪的条件:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttprequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (xmlhttprequest.readyState == <span class="number">4</span> &amp;&amp; xmlhttprequest.status == <span class="number">200</span>) &#123;</span><br><span class="line">                    alert(xmlhttprequest.responseText);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是, <code>onreadystatechange</code>事件要在<code>send()</code>方法之前绑定.</p>
<p>这里传给客户端的信息为一个<code>Person</code>实例, 在<code>AjaxServlet</code>程序中编写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">javaScriptAjax</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Ajax请求过来了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line">        </span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>页面输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705150355.png" alt=""></p>
<p>把返回的数据显示在页面上:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttprequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (xmlhttprequest.readyState == <span class="number">4</span> &amp;&amp; xmlhttprequest.status == <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="built_in">document</span>.getElementById(<span class="string">"div01"</span>).innerHTML = xmlhttprequest.responseText;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>页面为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705150625.png" alt=""></p>
<p>对返回的<code>json</code>对象进行操作, 提取对象中的值:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttprequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (xmlhttprequest.readyState == <span class="number">4</span> &amp;&amp; xmlhttprequest.status == <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="keyword">let</span> jsonObj = <span class="built_in">JSON</span>.parse(xmlhttprequest.responseText);</span><br><span class="line">                    <span class="built_in">document</span>.getElementById(<span class="string">"div01"</span>).innerHTML = <span class="string">"编号: "</span>+ jsonObj.id + <span class="string">", 姓名: "</span>+ jsonObj.name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>页面为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705151411.png" alt=""></p>
</li>
</ol>
<h3 id="jQuery-中的-AJAX-请求"><a href="#jQuery-中的-AJAX-请求" class="headerlink" title="jQuery 中的 AJAX 请求"></a>jQuery 中的 AJAX 请求</h3><p>一般不会写原生的AJAX请求, 更多的是依托与框架.</p>
<h4 id="ajax-方法"><a href="#ajax-方法" class="headerlink" title="$.ajax 方法"></a><code>$.ajax</code> 方法</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>表示请求的地址</td>
</tr>
<tr>
<td>type</td>
<td>表示请求的类型GET或POST</td>
</tr>
<tr>
<td>data</td>
<td>表示发送给服务器的数据</td>
</tr>
<tr>
<td>success</td>
<td>请求响应, 响应的回调函数</td>
</tr>
<tr>
<td>dataType</td>
<td>响应的数据类型, 常用的类型有: text 表示纯文本, xml 表示xml数据 , json 表示json对象</td>
</tr>
</tbody></table>
<p>在<code>html</code> 页面中添加相应的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax请求</span></span><br><span class="line">            $(<span class="string">"#ajaxBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url: <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet"</span>,</span><br><span class="line">                    data: <span class="string">"action=jQueryAjax"</span>,</span><br><span class="line">                    type: <span class="string">"GET"</span>,</span><br><span class="line">                    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        alert(<span class="string">"服务器返回的数据是: "</span> + data);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    dataType: <span class="string">"text"</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>success</code> 后跟的<code>function</code> 括号中要写入服务器返回的数据. </p>
<p>在<code>AjaxServlet</code> 类中编写请求处理方法, 为了区别于上面的原生<code>AJAX</code>实例, 再写一个<code>jQueryAjax</code> 方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQueryAjax</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQueryAjax == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705160736.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705161352.png" alt=""></p>
<p>依然是对返回的<code>JSON</code> 字符串进行操作, 使它显示得更直观.</p>
<p>在页面中合适的地方添加<code>&lt;div&gt;&lt;/div&gt;</code>块, 然后修改<code>success</code> 属性:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// alert("服务器返回的数据是: " + data);</span></span><br><span class="line">                        <span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(data);</span><br><span class="line">                        $(<span class="string">"msg"</span>).html(<span class="string">"编号: "</span> + jsonObj.id + <span class="string">" , 姓名:"</span> + jsonObj.name);</span><br><span class="line">                    &#125;,</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705162117.png" alt=""></p>
<p><strong>如果<code>dataType</code> 属性填的是<code>json</code>, 会自动转为<code>json</code> 对象, 不需要再手动转换.</strong></p>
<h4 id="get-方法和-post-方法"><a href="#get-方法和-post-方法" class="headerlink" title="$.get 方法和 $.post 方法"></a><code>$.get</code> 方法和 <code>$.post</code> 方法</h4><blockquote>
<p>这两个方法本质就是把上面的方法中的<code>type</code> 属性固定下来</p>
</blockquote>
<p><strong>$.get方法</strong></p>
<p>通过远程 HTTP GET 请求载入信息</p>
<p>这是一个简单的GET请求功能以取代复杂的<code>$.ajax</code>. 请求成功时可调用回调函数. 如果需要在出错时执行函数, 需要使用<code>$.ajax</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>请求的地址</td>
</tr>
<tr>
<td>data</td>
<td>发送的数据</td>
</tr>
<tr>
<td>callback</td>
<td>成功的回调函数</td>
</tr>
<tr>
<td>type</td>
<td>返回的数据类型</td>
</tr>
</tbody></table>
<p>比<code>$.ajax</code> 少了<code>type</code>属性, 因为方式已经确定</p>
<p>在<code>html</code>页面中编写:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax--get请求</span></span><br><span class="line">            $(<span class="string">"#getBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// get请求</span></span><br><span class="line">                $.<span class="keyword">get</span>(</span><br><span class="line">                    "http://localhost:8080/json_ajax_i18n/ajaxServlet",</span><br><span class="line">                    "action=jQueryGet",</span><br><span class="line">                    function (data) &#123;</span><br><span class="line">                        <span class="comment">// alert("服务器返回的数据是: " + data);</span></span><br><span class="line">                        $(<span class="string">"#msg"</span>).html(<span class="string">"get 编号: "</span> + data.id + <span class="string">" , 姓名:"</span> + data.name);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"json"</span></span><br><span class="line">                );</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<p>在<code>AjaxServlet</code>类中编写<code>get</code> 请求处理方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQueryGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQueryGet == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705165624.png" alt=""></p>
<p><strong>$.post</strong>方法</p>
<p>函数调用的属性与<code>get</code>一模一样, 直接贴出代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax--post请求</span></span><br><span class="line">            $(<span class="string">"#postBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// post请求</span></span><br><span class="line">                $.post(</span><br><span class="line">                    <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet"</span>,</span><br><span class="line">                    <span class="string">"action=jQueryPost"</span>,</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// alert("服务器返回的数据是: " + data);</span></span><br><span class="line">                        $(<span class="string">"#msg"</span>).html(<span class="string">"post 编号: "</span> + data.id + <span class="string">" , 姓名:"</span> + data.name);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"json"</span></span><br><span class="line">                );</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQueryPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQueryPost == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705165818.png" alt=""></p>
<h4 id="getJSON-方法"><a href="#getJSON-方法" class="headerlink" title="$.getJSON 方法"></a><code>$.getJSON</code> 方法</h4><p>通过 GET 请求载入 JSON 数据</p>
<blockquote>
<p>本质上就是<code>$.get</code> 方法中的<code>dataType</code>属性被固定成<code>json</code> </p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>url</td>
<td>请求的地址</td>
</tr>
<tr>
<td>data</td>
<td>发送的数据</td>
</tr>
<tr>
<td>callback</td>
<td>成功的回调函数</td>
</tr>
</tbody></table>
<p>直接贴代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax--getJson请求</span></span><br><span class="line">            $(<span class="string">"#getJSONBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 调用</span></span><br><span class="line">                $.getJSON(</span><br><span class="line">                    <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet"</span>,</span><br><span class="line">                    <span class="string">"action=jQueryGetJson"</span>,</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        <span class="comment">// alert("服务器返回的数据是: " + data);</span></span><br><span class="line">                        $(<span class="string">"#msg"</span>).html(<span class="string">"getJson 编号: "</span> + data.id + <span class="string">" , 姓名:"</span> + data.name);</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQueryGetJson</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQueryGetJson == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705211905.png" alt=""></p>
<h4 id="serialize-方法"><a href="#serialize-方法" class="headerlink" title="serialize()方法"></a><code>serialize()</code>方法</h4><p>可以把表单中所有表单项的内容都获取到, 并以 name=value&amp;name=value 的形式进行拼接.</p>
<p>首先创建一个表单:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form01"</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    下拉单选：<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"single"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Single"</span>&gt;</span>Single<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Single2"</span>&gt;</span>Single2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    下拉多选：</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"multiple"</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span> <span class="attr">value</span>=<span class="string">"Multiple"</span>&gt;</span>Multiple<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Multiple2"</span>&gt;</span>Multiple2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span> <span class="attr">value</span>=<span class="string">"Multiple3"</span>&gt;</span>Multiple3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    复选：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"check"</span> <span class="attr">value</span>=<span class="string">"check1"</span>/&gt;</span> check1</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"check"</span> <span class="attr">value</span>=<span class="string">"check2"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span> check2<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    单选：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"radio1"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span> radio1</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"radio"</span> <span class="attr">value</span>=<span class="string">"radio2"</span>/&gt;</span> radio2<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit"</span>&gt;</span>提交--serialize()<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表单效果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705212249.png" alt=""></p>
<p>之前的做法是将整个表单都提交, 现在只需要提交键值即可.</p>
<p>在按钮的单击事件中添加:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert($(<span class="string">"#form01"</span>).serialize());</span><br></pre></td></tr></table></figure>

<p>然后随便填写表单, 输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705213127.png" alt=""></p>
<p>已经获取参数并拼接好.</p>
<p>修改客户端代码将所有参数都发给服务器:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.getJSON(</span><br><span class="line">                    <span class="string">"http://localhost:8080/json_ajax_i18n/ajaxServlet"</span>,</span><br><span class="line">                    <span class="string">"action=jQuerySerialize&amp;"</span> + $(<span class="string">"#form01"</span>).serialize(),</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        $(<span class="string">"#msg"</span>).html(<span class="string">"jQuerySerialize 编号: "</span> + data.id + <span class="string">" , 姓名:"</span> + data.name);</span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br></pre></td></tr></table></figure>

<p>然后在服务器端接收:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">jQuerySerialize</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"jQuerySerialize == 方法调用了"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"用户名: "</span> + req.getParameter(<span class="string">"username"</span>));</span><br><span class="line">        System.out.println(<span class="string">"密码: "</span> + req.getParameter(<span class="string">"password"</span>));</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">1</span>, <span class="string">"lxb"</span>);</span><br><span class="line">        <span class="comment">// json格式的字符串</span></span><br><span class="line">        Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">        String personJsonString = gson.toJson(person);</span><br><span class="line"></span><br><span class="line">        resp.getWriter().write(personJsonString);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>随便填写表单, 输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705214305.png" alt=""></p>
<h2 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h2><p>国际化三要素:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200705231026.png" alt=""></p>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
        <tag>Filter</tag>
        <tag>Json</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>Java拾遗</title>
    <url>/2020/07/07/Java%E6%8B%BE%E9%81%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 语言基础中知识点繁多, 大多数只是在第一次学习时有印象, 但是因为长时间没有运用到会遗忘, 这篇博文就用来记录和总结遇到的生僻的知识点.</p>
<hr>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><code>abstract</code> 修饰符可以用来修饰方法, 也可以用来修饰类, 如果修饰方法, 那么该方法就是抽象方法; 如果修饰类, 那么该类就是抽象类.</p>
<ul>
<li>不能<code>new</code> 抽象类, 只能靠子类去实现它</li>
<li>抽象类中可以写普通方法</li>
<li>抽象方法必须在抽象类中</li>
</ul>
<hr>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>在接口中定义的常量会默认加上修饰符 <code>public static final</code>, 在实现了该接口的类中可以直接拿来用</li>
<li>在接口中定义的方法会默认加上修饰符 <code>pubilc abstract</code> </li>
<li>接口中没有构造方法, 这是不能被实例化的原因</li>
</ul>
<hr>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>定义以下的类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是外部类的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"这是内部类的方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个类中分别定义了各自的方法. 然后实例化外部类的对象, 对该类进行测试.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br><span class="line">        inner.in();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就要注意 <code>new</code> 内部类对象时写法上的区别了.</p>
<p>可以通过定义内部类的方法来获取外部类的私有属性, 修改外部类如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是外部类的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"这是内部类的方法"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过内部类的对象调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br><span class="line">        inner.in();</span><br><span class="line">        inner.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200707193414.png" alt=""></p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>在定义内部类时添加 <code>statc</code> 关键字即可. </p>
<p>因为创建内部类的方式与调用方法的步骤与成员内部类相同, 所以就不再赘述.</p>
<p>但是需要注意的是, 静态内部类是随外部类加载时创建的, 所以<strong>不能调用成员变量</strong>.</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>在外部类的方法中定义的类叫局部内部类.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"这是内部类的方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200707200724.png" alt=""></p>
<p><strong>Error</strong>:</p>
<p>通常是灾难性的致命的错误, 是程序员无法控制和处理的, 当出现这些异常时, JVM一般会终止线程</p>
<p><strong>Exception</strong>:</p>
<p>通常情况下是可以被程序处理, 并且在程序中应该尽可能的去处理这些异常</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>主动抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Demo01().test(a, b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(); <span class="comment">// 主动抛出异常, 一般在方法中使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>假设方法中处理不了这个异常, 直接在方法上抛出, 使用<code>throws</code> 关键字, 然后调用该方法时用<code>try-catch</code> 捕获处理</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>使用<code>try-catch</code>捕获异常并处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Demo01().test(a, b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"运算失败, 除数为0"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"调用结束"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> ArithmeticException</span>&#123;</span><br><span class="line">        System.out.println(a/b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运算失败, 除数为0</span><br><span class="line">调用结束</span><br></pre></td></tr></table></figure>

<h3 id="异常处理五个关键字"><a href="#异常处理五个关键字" class="headerlink" title="异常处理五个关键字"></a>异常处理五个关键字</h3><p><strong>try, catch, throw, throws, finally</strong></p>
<p>先看<code>try</code> , <code>catch</code>, <code>finally</code> 关键字的常见用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;   <span class="comment">// try监控区域</span></span><br><span class="line">        System.out.println(a / b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">// catch(想要捕获的异常类型)捕获异常</span></span><br><span class="line">        System.out.println(<span class="string">"程序出现异常, 变量b不能为0"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 处理善后工作</span></span><br><span class="line">        System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序出现异常, 变量b不能为0</span><br><span class="line">finally</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是<code>finally</code>, 不管是否能捕获到异常, 都会执行该代码块, 属于善后工作, 也可以不要</p>
<p>可以写多个<code>catch</code> 进行捕获, 如果要写多个的话,小的异常写上面, 层层递进, 大的写上面就给覆盖掉了</p>
<p><code>thow</code>和<code>throws</code> 的区别在于, 前者为方法中主动抛出异常, 后者是该方法中处理不了让调用该方法的方法通过<code>try-catch</code>处理.</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>创建自定义异常要继承<code>Exception</code> 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递数字 &gt; 10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> detail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.detail = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toString: 异常的打印信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MyException&#123;"</span> + detail + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用该异常:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可能会存在异常的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"传递的参数为: "</span> + a);</span><br><span class="line">        <span class="keyword">if</span> (a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(a);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传递的参数为: 11</span><br><span class="line">MyException&#123;11&#125;</span><br></pre></td></tr></table></figure>



<p>在这段代码中, 判断<code>a&gt;10</code> 的时候抛出我们所定义的异常, 这里有两种处理方式, 一是在该方法中<code>try-catch</code> 进行异常的处理, 或者在方法层面抛出, 让该方法的调用者去<code>try-catch</code> 去处理. 这里采用的是第二种处理方法.</p>
<p>总之, 只要抛出了异常, 要么就地处理, 要么抛出去谁调用谁处理, 总是要还的.</p>
<p>以下是就地处理的代码和结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可能会存在异常的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"传递的参数为: "</span> + a);</span><br><span class="line">        <span class="keyword">if</span> (a&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MyException(a);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"OK"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">传递的参数为: 11</span><br><span class="line">MyException&#123;11&#125;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p><strong>要注意输出的结果是不一样的!!</strong></p>
<hr>
<h2 id="类加载器与构造器的调用顺序"><a href="#类加载器与构造器的调用顺序" class="headerlink" title="类加载器与构造器的调用顺序"></a>类加载器与构造器的调用顺序</h2><p>今天遇到一个考察继承的题目, 牵涉到类加载器和构造器调用顺序的问题, 很有趣.</p>
<p><strong>问</strong>: new一个C02对象, 会输出什么信息?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n1 = getVal01();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"A02的一个静态代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"A02的第一个普通代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n3 = getVal02();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getVal01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal01"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal02"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A02的构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B02</span> <span class="keyword">extends</span> <span class="title">A02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n3 = getVal03();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"B02的一个静态代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n5 = getVal04();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"B02的第一个普通代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getVal03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal03"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal04"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B02的构造器"</span>);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C02</span> <span class="keyword">extends</span> <span class="title">B02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n6 = getVal06();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"C02的一个静态代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"C02的第一个普通代码块.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n8 = getVal08();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getVal06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal06"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVal08</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getVal08"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">C02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"C02的构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        C02 c = <span class="keyword">new</span> C02();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>:</p>
<p>这里有三个类,<code>A02</code>是父类, <code>B02</code>继承<code>A02</code>, <code>C02</code>继承<code>B02</code>. 每个类都有各自的静态代码块和无参构造器. </p>
<p>根据继承的特点可知, 当<code>new</code> 一个<code>C02</code>对象时, 会去调用<code>C02</code>的构造器, <code>C02</code>构造器第一行默认为<code>super()</code> , 即调用父类<code>B02</code>的构造器, 同理调用<code>A02</code> 的构造器, 然后顺序执行类<code>A02</code> 的代码 -&gt; <code>A02</code>构造器内的代码 -&gt; 顺序执行类<code>B02</code> 的代码 -&gt; <code>B02</code>构造器内的代码 -&gt; 顺序执行<code>C02</code> 的代码 -&gt; <code>C02</code> 构造器内的代码.</p>
<p>然而加了类构造器之后该是什么顺序呢?  直接贴结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getVal01</span><br><span class="line">A02的一个静态代码块..</span><br><span class="line">getVal03</span><br><span class="line">B02的一个静态代码块..</span><br><span class="line">getVal06</span><br><span class="line">C02的一个静态代码块..</span><br><span class="line">A02的第一个普通代码块..</span><br><span class="line">getVal02</span><br><span class="line">A02的构造器</span><br><span class="line">getVal04</span><br><span class="line">B02的第一个普通代码块..</span><br><span class="line">B02的构造器</span><br><span class="line">C02的第一个普通代码块..</span><br><span class="line">getVal08</span><br><span class="line">C02的构造器</span><br></pre></td></tr></table></figure>

<p>我们刚才分析的步骤是从第七行开始的, 后面全部严格按照分析的步骤打印信息, 所以可以得出结论: 类加载器工作的时间整体都在构造器之前.</p>
<p>不难看出, 类加载器的调用顺序与构造器是类似的, 也是从子类一路到父类, 然后再到子类. 更加严谨的调用顺序如下所述:</p>
<h3 id="类加载器调用顺序"><a href="#类加载器调用顺序" class="headerlink" title="类加载器调用顺序"></a>类加载器调用顺序</h3><p>JVM会用类加载器加载xxx.C02这个class文件</p>
<p>加载(class){</p>
<p>　　if(class有父类){</p>
<p>　　　　加载(superclass);</p>
<p>　　}</p>
<p>　　1.静态域申明,默认初始化为0,false,null</p>
<p>　　2.按照申明顺序(从上而下书写顺序)执行静态域(赋值)和静态代码块(执行代码块体),</p>
<p>　　　　二者等价,因此不可在静态代码块中<strong>使用</strong>位于代码块之后申明的静态域,但是<strong>可以初始化</strong></p>
<p>　　3.按照申明顺序加载静态方法</p>
<p>}</p>
<h3 id="构造器调用顺序"><a href="#构造器调用顺序" class="headerlink" title="构造器调用顺序"></a>构造器调用顺序</h3><ol>
<li><p>所有实例域初始化为默认值0,false,null</p>
</li>
<li><p>按照申明顺序执行域初始化及块初始化</p>
</li>
<li><p><strong>如果构造器”第一行”调用了其他构造器,则执行</strong></p>
</li>
<li><p>执行构造器体</p>
</li>
</ol>
<h3 id="方法调用顺序"><a href="#方法调用顺序" class="headerlink" title="方法调用顺序"></a>方法调用顺序</h3><ol>
<li><p>编译器查看对象的<strong>申明</strong>类型,找到它所有与方法名相同的方法</p>
</li>
<li><p>根据参数类型,找到相应”最合适”的父类方法可能会出现类型转换(向上转型)</p>
</li>
<li><p>如果是private,static,final,构造器 方法,那么已经确定就是该方法(这四种类型的方法没有多态特征),</p>
</li>
</ol>
<p>　　因为没有多态所以也叫静态绑定</p>
<ol start="4">
<li><p>如果是其他方式,采用动态绑定:JVM去寻找改类的实际类型中对应的最合适方法</p>
</li>
<li><p>执行调用</p>
</li>
</ol>
<p><strong>结合理论表述, 本题的顺序总结来说就是:</strong></p>
<ol>
<li>父类的静态代码块和静态属性(优先级一样，按定义顺序执行)</li>
<li>子类的静态代码块和静态属性(优先级一样，按定义顺序执行)</li>
<li>父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)</li>
<li>子类的构造方法</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>接口</tag>
        <tag>内部类</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>String,StringBuffer,StringBuilder类汇总</title>
    <url>/2020/07/08/String-StringBuffer-StringBuilder%E7%B1%BB%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>字符串Java中非常重要的部分, 这里包含了大量的处理方法以及性质特点, 这篇文章对常用的String类, StringBuffer类, StringBuilder类相关知识点进行汇总.</p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="两个重要特点"><a href="#两个重要特点" class="headerlink" title="两个重要特点"></a>两个重要特点</h3><h4 id="String-常量池"><a href="#String-常量池" class="headerlink" title="String 常量池"></a>String 常量池</h4><p>常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。Java为了提高性能，静态字符串（字面量/常量/常量连接的结果）在常量池中创建，并尽量使用同一个对象，重用静态字符串。对于重复出现的字符串直接量，JVM会首先在常量池中查找，如果常量池中存在即返回该对象。</p>
<p>例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            String str1 = <span class="string">"Hello"</span>;<span class="comment">//生成了1个对象"Hello"</span></span><br><span class="line">            <span class="comment">//不会创建新的String对象，而是使用常量池中已有的"Hello"，</span></span><br><span class="line">            String str2 = <span class="string">"Hello"</span>;</span><br><span class="line">            System.out.println(str1 == str2); <span class="comment">//true</span></span><br><span class="line">            <span class="comment">//使用new关键字会创建新的String对象，不管常量池里面有没有相同的值</span></span><br><span class="line">            String str3 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);<span class="comment">//生成了2个对象"Hello"和new String("Hello")</span></span><br><span class="line">            System.out.println(str1 == str3); <span class="comment">//false </span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="String-对象不可变"><a href="#String-对象不可变" class="headerlink" title="String 对象不可变"></a>String 对象不可变</h4><p>String是常量，其对象一旦构造就不能再被改变。换句话说，<strong>String对象是不可变的</strong>，每一个看起来会修改String值的方法，实际上都是创造了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"hello"</span>;</span><br><span class="line">        String newS = StringTest02.append(s);</span><br><span class="line">        System.out.println(<span class="string">"String append---&gt;"</span> + s.toString());</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"hello"</span>);</span><br><span class="line">        StringBuilder newSb = StringTest02.append(sb);</span><br><span class="line">        System.out.println(<span class="string">"StringBuilder append---&gt;"</span> +sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">append</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s += <span class="string">"kitty"</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">append</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb.append(<span class="string">"kitty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String append---&gt;hello</span><br><span class="line">StringBuilder append---&gt;hellokitty</span><br></pre></td></tr></table></figure>

<p>由上面的例子可见StringBuilder sb的值被改变了，而String s的值没有变，所以String不可变的安全性就体现出来了</p>
<h3 id="String-类的方法"><a href="#String-类的方法" class="headerlink" title="String 类的方法"></a>String 类的方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p><strong>1、<em>public String()</em></strong><br>无参构造方法，用来创建空字符串的String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String();</span><br></pre></td></tr></table></figure>

<p><strong>2、<em>public String(String value)</em></strong><br>用已知的字符串value创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"qwer"</span>); </span><br><span class="line">String str3 = <span class="keyword">new</span> String(str2);</span><br></pre></td></tr></table></figure>

<p><strong>3、<em>public String(char[] value)</em></strong><br>用字符数组value创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">String str4 = <span class="keyword">new</span> String(value);<span class="comment">//相当于String str4 = new String("abcd");</span></span><br></pre></td></tr></table></figure>

<p><strong>4<em>、public String(char chars[], int startIndex, int numChars)</em></strong><br>用字符数组chars的startIndex开始的numChars个字符创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">String str5 = <span class="keyword">new</span> String(value, <span class="number">1</span>, <span class="number">2</span>);<span class="comment">//相当于String str5 = new String("bc");</span></span><br></pre></td></tr></table></figure>

<p><strong>5、<em>public String(byte[] values)</em></strong><br>用比特数组values创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] strb = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>&#125;;</span><br><span class="line">String str6 = <span class="keyword">new</span> String(strb);<span class="comment">//相当于String str6 = new String("ABCD");</span></span><br></pre></td></tr></table></figure>

<p><strong>6、<em>public String(byte[] values,int startIndex, int numChars)</em></strong><br>用字符数组byte的startIndex开始的numChars个字符创建一个String对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] strb = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>&#125;;</span><br><span class="line">String str6 = <span class="keyword">new</span> String(strb,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//相当于String str6 = new String("A");</span></span><br></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p><strong>1、<em>length()</em></strong><br>返回字该字符串的长度</p>
<p><strong>2、<em>charAt(int indext)</em></strong><br>求字符串某一位置的字符，index必须&gt;=0并且&lt;= length()-1</p>
<p><strong>3、截取字符串</strong></p>
<ul>
<li><strong><em>substring(int beginIndex)</em></strong><br>该方法从beginIndex位置起（包含这个位置）到最后截取一个字符串返回。<br><strong><em>[beginIndex,最后]</em></strong></li>
<li><strong><em>substring(int beginIndex，endIndex)</em></strong><br>该方法从beginIndex位置起（包含这个位置）到endIndex - 1截取一个字符串返回。<br><strong><em>[beginIndex,endIndex - 1]</em></strong><br>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"abcdefgkl"</span>);</span><br><span class="line">String str2 = str1.substring(<span class="number">2</span>);<span class="comment">//str2 = "cdefgkl"</span></span><br><span class="line">String str3 = str1.substring(<span class="number">2</span>,<span class="number">5</span>);<span class="comment">//str3 = "cde"</span></span><br></pre></td></tr></table></figure>

<p><strong>4、字符串比较</strong></p>
<ul>
<li><strong><em>public int compareTo(String anotherString)</em></strong><br>该方法是对字符串内容按字典顺序进行大小比较，通过返回的整数值指明当前字符串与参数字符串的大小关系。若当前对象比参数大则返回正整数，反之返回负整数，相等返回0。其比较规则是：拿出字符串的第一个字符与参数的第一个字符进行比较，如果两者不等，比较结束，返回两者的ascii差。这里有一点需要注意：如果两个字符串的长度不同，并且一个字符串与另一个字符串的前面N个字符相等，那么这个方法返回返回两个字符串长度之差。</li>
<li><strong><em>public int compareToIgnore(String anotherString)</em></strong><br>与compareTo方法相似，但忽略大小写。</li>
<li><strong><em>public boolean equals(Object anotherObject)</em></strong><br>比较当前字符串和参数字符串，在两个字符串相等的时候返回true，否则返回false。</li>
<li><strong><em>public boolean equalsIgnoreCase(String anotherString)</em></strong><br>与equals方法相似，但忽略大小写。<br>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">"abcd"</span>; </span><br><span class="line">String s2 = <span class="string">"abce"</span>; </span><br><span class="line">String s3 = <span class="string">"ABC"</span>; </span><br><span class="line">String s4 = <span class="string">"abcdefg"</span>; </span><br><span class="line">String s5 = <span class="string">"abc"</span>; </span><br><span class="line">System.out.println(s1.compareTo(s2)); </span><br><span class="line">System.out.println(s1.compareTo(s3)); </span><br><span class="line">System.out.println(s4.compareTo(s1)); </span><br><span class="line">System.out.println(s4.compareTo(s2)); </span><br><span class="line">System.out.println(s3.compareToIgnoreCase(s5));</span><br><span class="line">System.out.println(s3.equals(s5));</span><br><span class="line">System.out.println(s3.equalsIgnoreCase(s5));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>5、字符串连接</strong></p>
<ul>
<li><strong><em>public String concat(String str)</em></strong><br>将参数中的字符串str连接到当前字符串的后面，效果等价于”+”。</li>
</ul>
<p><strong>6、字符串中单个字符查找</strong></p>
<ul>
<li><strong><em>public int indexOf(int ch/String str)</em></strong><br>用于查找当前字符串中字符或子串，返回字符或子串在当前字符串中从左边起首次出现的位置，若没有出现则返回-1。</li>
<li><strong><em>public int indexOf(int ch/String str, int fromIndex)</em></strong><br>改方法与第一种类似，区别在于该方法从fromIndex位置向后查找。</li>
<li><strong><em>public int lastIndexOf(int ch/String str)</em></strong><br>该方法与第一种类似，区别在于该方法从字符串的末尾位置向前查找。</li>
<li><strong><em>public int lastIndexOf(int ch/String str, int fromIndex)</em></strong><br>该方法与第二种方法类似，区别于该方法从fromIndex位置向前查找。<br>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"I am a good student"</span>;</span><br><span class="line">System.out.println(str.indexOf(<span class="string">'a'</span>));</span><br><span class="line">System.out.println(str.indexOf(<span class="string">"good"</span>));</span><br><span class="line">System.out.println(str.indexOf(<span class="string">"w"</span>, <span class="number">2</span>));</span><br><span class="line">System.out.println(str.lastIndexOf(<span class="string">"a"</span>));</span><br><span class="line">System.out.println(str.lastIndexOf(<span class="string">"a"</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">7</span><br><span class="line">-1</span><br><span class="line">5</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>7、字符串中字符的大小写转换</strong></p>
<ul>
<li><strong><em>public String toLowerCase()</em></strong><br>返回将当前字符串中所有字符转换成小写后的新串</li>
<li><strong><em>public String toUpperCase()</em></strong><br>返回将当前字符串中所有字符转换成大写后的新串</li>
</ul>
<p><strong>8、字符串中字符的替换</strong></p>
<ul>
<li><strong><em>public String replace(char oldChar, char newChar)</em></strong><br>用字符newChar替换当前字符串中所有的oldChar字符，并返回一个新的字符串。</li>
<li><strong><em>public String replaceFirst(String regex, String replacement)</em></strong><br>该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串，应将新的字符串返回。</li>
<li><strong><em>public String replaceAll(String regex, String replacement)</em></strong><br>该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串，应将新的字符串返回。<br>例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str4 = <span class="string">"asdzxcasd"</span>;</span><br><span class="line">System.out.println(str4.replace(<span class="string">'a'</span>, <span class="string">'g'</span>));</span><br><span class="line">System.out.println(str4.replace(<span class="string">"asd"</span>, <span class="string">"fgh"</span>));</span><br><span class="line">System.out.println(str4.replaceFirst(<span class="string">"asd"</span>, <span class="string">"fgh"</span>));</span><br><span class="line">System.out.println(str4.replaceAll(<span class="string">"asd"</span>, <span class="string">"fgh"</span>));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gsdzxcgsd</span><br><span class="line">fghzxcfgh</span><br><span class="line">fghzxcasd</span><br><span class="line">fghzxcfgh</span><br></pre></td></tr></table></figure>

<p><strong><em>注意：replace和preplaceAll的区别</em></strong></p>
<ol>
<li>replace的参数是char和CharSequence,即可以支持字符的替换,也支持字符串的替换(CharSequence即字符串序列的意思,说白了也就是字符串);</li>
<li>replaceAll的参数是regex,即基于规则表达式的替换,比如,可以通过replaceAll(“\d”, “*”)把一个字符串所有的数字字符都换成星号;</li>
</ol>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p><strong>1、去除首位空格</strong></p>
<ul>
<li><p><strong><em>String trim()</em></strong></p>
<p>截去字符串两端的空格，但对于中间的空格不处理。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">" a sd "</span>;</span><br><span class="line">String str1 = str.trim();</span><br><span class="line"><span class="keyword">int</span> a = str.length();<span class="comment">//a = 6</span></span><br><span class="line"><span class="keyword">int</span> b = str1.length();<span class="comment">//b = 4</span></span><br></pre></td></tr></table></figure>

<p><strong>2、确认开始或结尾字符串</strong></p>
<ul>
<li><strong><em>boolean statWith(String prefix)或boolean endWith(String suffix)</em></strong><br>用来比较当前字符串的起始字符或子字符串prefix和终止字符或子字符串suffix是否和当前字符串相同，重载方法中同时还可以指定比较的开始位置offset。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"asdfgh"</span>;</span><br><span class="line"><span class="keyword">boolean</span> a = str.statWith(<span class="string">"as"</span>);<span class="comment">//a = true</span></span><br><span class="line"><span class="keyword">boolean</span> b = str.endWith(<span class="string">"gh"</span>);<span class="comment">//b = true</span></span><br></pre></td></tr></table></figure>

<p><strong>3、包含字符串</strong></p>
<ul>
<li><strong><em>contains(String str)</em></strong><br>判断参数s是否被包含在字符串中，并返回一个布尔类型的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String str &#x3D; &quot;student&quot;;</span><br><span class="line">str.contains(&quot;stu&quot;);&#x2F;&#x2F;true</span><br><span class="line">str.contains(&quot;ok&quot;);&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<p><strong>4、分隔字符串</strong></p>
<ul>
<li><strong><em>String[] split(String str)</em></strong><br>将str作为分隔符进行字符串分解，分解后的字字符串在字符串数组中返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"asd!qwe!zxc"</span>;</span><br><span class="line">String[] str1 = str.split(<span class="string">"!"</span>);<span class="comment">//str1[0] = "asd";str1[1] = "qwe";str1[2] = "zxc";</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串与基本类型的转换"><a href="#字符串与基本类型的转换" class="headerlink" title="字符串与基本类型的转换"></a>字符串与基本类型的转换</h4><p><strong>1、字符串转换为基本类型</strong></p>
<p>java.lang包中有Byte、Short、Integer、Float、Double类的调用方法：</p>
<ul>
<li><p><strong><em>public static byte parseByte(String s)</em></strong></p>
</li>
<li><p><strong><em>public static short parseShort(String s)</em></strong></p>
</li>
<li><p><strong><em>public static short parseInt(String s)</em></strong></p>
</li>
<li><p><strong><em>public static long parseLong(String s)</em></strong></p>
</li>
<li><p><strong><em>public static float parseFloat(String s)</em></strong></p>
</li>
<li><p><strong><em>public static double parseDouble(String s)</em></strong></p>
<p>例如：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = Integer.parseInt(<span class="string">"12"</span>);</span><br><span class="line"><span class="keyword">float</span> f = Float.parseFloat(<span class="string">"12.34"</span>);</span><br><span class="line"><span class="keyword">double</span> d = Double.parseDouble(<span class="string">"1.124"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>2、基本类型转换为字符串类型</strong></p>
<p>String类中提供了String valueOf()放法，用作基本类型转换为字符串类型。</p>
<ul>
<li><strong><em>static String valueOf(char data[])</em></strong></li>
<li><strong><em>static String valueOf(char data[], int offset, int count)</em></strong></li>
<li><strong><em>static String valueOf(boolean b)</em></strong></li>
<li><strong><em>static String valueOf(char c)</em></strong></li>
<li><strong><em>static String valueOf(int i)</em></strong></li>
<li><strong><em>static String valueOf(long l)</em></strong></li>
<li><strong><em>static String valueOf(float f)</em></strong></li>
<li><strong><em>static String valueOf(double d)</em></strong><br>例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = String.valueOf(<span class="number">12</span>);</span><br><span class="line">String s1 = String.valueOf(<span class="number">12.34</span>);</span><br></pre></td></tr></table></figure>

<h2 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer, StringBuilder"></a>StringBuffer, StringBuilder</h2><h3 id="共同支持的方法"><a href="#共同支持的方法" class="headerlink" title="共同支持的方法"></a>共同支持的方法</h3><ul>
<li><strong><em>public StringBuffer append(String s)</em></strong><br>将指定的字符串追加到此字符序列。</li>
<li><strong><em>public StringBuffer reverse()</em></strong><br>将此字符序列用其反转形式取代。</li>
<li><strong><em>public delete(int start, int end)</em></strong><br>移除此序列的子字符串中的字符。</li>
<li><strong><em>public insert(int offset, int i)</em></strong><br>将 int 参数的字符串表示形式插入此序列中。</li>
<li><strong><em>replace(int start, int end, String str)</em></strong><br>使用给定 String 中的字符替换此序列的子字符串中的字符。</li>
<li><strong><em>int capacity()</em></strong><br>返回当前容量</li>
<li><strong><em>void setCharAt(int index, char ch)</em></strong><br>将给定索引处的字符设置为 ch。</li>
<li><strong><em>void setLength(int newLength)</em></strong><br>设置字符序列的长度</li>
</ul>
<p><strong>在大部分情况下 StringBuilder &gt; StringBuffer</strong></p>
<p>java.lang.StringBuildejava.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>
<h3 id="三者的区别"><a href="#三者的区别" class="headerlink" title="三者的区别"></a>三者的区别</h3><p><strong>1、对象的可变与不可变</strong><br>String对象不可变，StringBuffer和StringBuilder对象可变。</p>
<p><strong>2、 线程是否安全</strong></p>
<ul>
<li>String中的对象是不可变的，也就可以理解为常量，所以线程安全。</li>
<li>StringBuffer中的方法大都采用了synchronized关键字修饰，所以是线程安全的。</li>
<li>StringBuilder没有对方法进行加同步锁，所以是非线程安全的。</li>
</ul>
<p><strong>3、 字符串追加速度比较</strong><br>StringBuilder &gt; StringBuffer &gt; String</p>
<p><strong>4、 StringBuffer和StringBuilder的共同点</strong></p>
<ul>
<li>StringBuffer和StringBuilder有公共的抽象父类AbstractStringBuilder</li>
<li>抽象类与一个接口的区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。</li>
<li>StringBuilder和StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(…)。只是StringBuffer会在方法上加上synchronized关键字，进行同步。<br>如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><em>String</em></strong>：适用于少量的字符串操作的情况<br><strong><em>StringBuilder</em></strong>：适用于单线程下在字符缓冲区进行大量操作的情况<br><strong><em>StringBuffer</em></strong>：适用于多线程下在字符缓冲区进行大量操作的情况</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>jz07.重建二叉树</title>
    <url>/2020/07/09/jz07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   3</span><br><span class="line"> &#x2F;  \</span><br><span class="line">9   20</span><br><span class="line">     &#x2F;  \</span><br><span class="line">    15   7</span><br></pre></td></tr></table></figure>

<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>这道题要充分用到二叉树前序遍历与中序遍历的数量关系.</p>
<p>示例中两个数组的关系进行分析可知:</p>
<blockquote>
<p><strong>前序遍历特点：</strong> 节点按照 <code>[ 根节点 | 左子树 | 右子树 ]</code> 排序，以题目示例为例：<code>[ 3 | 9 | 20 15 7 ]</code></p>
<p><strong>中序遍历特点：</strong> 节点按照 <code>[ 左子树 | 根节点 | 右子树 ]</code> 排序，以题目示例为例：<code>[ 9 | 3 | 15 20 7 ]</code></p>
</blockquote>
<p>对于根节点<code>3</code> 来说, 它排在前序遍历数组的最前面, 在中序遍历数组中找到<code>3</code> 的位置, 可以发现在它之前的元素全部属于左子树, 在它之后的元素全部属于右子树.</p>
<p>这个这个规律可以套用到所有子树中, 比如<code>20</code> 是右子树的根节点, 它在前序遍历数组中位于该子树范围中的第一位(<code>[20, 15, 7]</code>是右子树), 在中序遍历中找到<code>20</code> 的位置, 在其范围内(<code>[15, 20, 7]</code>) 左边的元素都属于新的左子树, 右边的元素都属于新的右子树. 这样就构成了递归关系.</p>
<p>所以我们的递归思路是:</p>
<ul>
<li><p><strong>递归参数:</strong> 前序遍历中根节点的索引<code>pre_root</code>、中序遍历左边界<code>in_left</code>、中序遍历右边界<code>in_right</code></p>
</li>
<li><p><strong>终止条件：</strong> 当 <code>in_left &gt; in_right</code> ，子树中序遍历为空，说明已经越过叶子节点，此时返回 <code>null</code></p>
</li>
<li><p><strong>递推工作：</strong></p>
<ol>
<li><strong>建立根节点<code>root</code></strong>： 值为前序遍历中索引为pre_root的节点值。</li>
<li><strong>搜索根节点<code>root</code>在中序遍历的索引<code>i</code>：</strong> 为了提升搜索效率，本题解使用哈希表 <code>dic</code> 预存储中序遍历的值与索引的映射关系，每次搜索的时间复杂度为 O(1)</li>
<li><strong>构建根节点<code>root</code>的左子树和右子树：</strong> 通过调用<code>recur()</code> 方法开启下一层递归。<ul>
<li>左子树： 根节点索引为<code>pre_root + 1</code> ，中序遍历的左右边界分别为 <code>in_left</code> 和<code>i - 1</code>。</li>
<li>右子树： 根节点索引为<code>i - in_left + pre_root + 1</code>（即：根节点索引 + 左子树长度 + 1），中序遍历的左右边界分别为<code>i + 1</code>和<code>in_right</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p> 判断下一次递归时子树的左右边界比较容易, 就是当前<code>i</code> 值加一或减一即可, 判断左右子树的根节点时, 左子树根节点很容易, 当前节点在前序遍历数组中的后一个元素就是左子树的根节点. 下面来分析右子树根节点如何表示:</p>
<p>我们已经知道当前树的根节点在前序遍历数组中的索引<code>pre_root</code> , 它后面紧跟着的是左子树, 所以得出左子树节点的数量就可以得到右子树根节点的索引了.我们还知道当前树根节点在中序遍历数组中的索引<code>i</code>, 以及左子树的边界<code>in_left</code> ,那么<code>i - in_left</code> 就是左子树的节点数量.  <strong>所以右子树的根节点索引为<code>i- in_left + pre_root + 1.</code></strong></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/asdf1.png" alt="">)<img src="http://qcxz71s06.bkt.clouddn.com/asgfrg2.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/ergfb3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/hq4aebdgsf4.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/qyjhg5.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/2tyesujrd6.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/2ewagrhetjy7.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/gd8.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/wertyu9.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz07</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] pre;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        pre = preorder;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            dic.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> pre_root, <span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in_left &gt; in_right)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = dic.get(pre[pre_root]);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[pre_root]);</span><br><span class="line"></span><br><span class="line">        root.left = recur(pre_root + <span class="number">1</span>, in_left, i - <span class="number">1</span>);</span><br><span class="line">        root.right = recur(i - in_left + pre_root + <span class="number">1</span>, i + <span class="number">1</span>, in_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz26.树的子结构</title>
    <url>/2020/07/09/jz26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:<br>给定的树 A:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure>

<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><hr>
<h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>看到这道题时经过分析可知需要两个递归过程:</p>
<p>过程一是<code>判断当前节点为根节点的树与树B是否相同</code> || <code>当前节点的左子树与树B是否相同</code> || <code>当前节点的右子树与树B是否相同</code>,   写成<code>isSubStructure(A, B)</code> 方法:</p>
<ol>
<li><p><strong>特例:</strong><br>当 树<code>A</code> 为空 <strong>或</strong> 树 <code>B</code> 为空 时，直接返回 <code>false</code> </p>
</li>
<li><p><strong>返回值</strong>: 若树<code>B</code>是树 <code>A</code>的子结构，则必满足以下三种情况之一，因此用或 <code>||</code> 连接</p>
<ol>
<li>以 节点 <code>A</code>为根节点的子树 包含树 <code>B</code> ，对应 recur(A, B)；</li>
<li>树 <code>B</code> 是 树 <code>A</code>左子树 的子结构，对应 isSubStructure(A.left, B)；</li>
<li>树 <code>B</code>是 树 <code>A</code>右子树 的子结构，对应 isSubStructure(A.right, B)；</li>
</ol>
</li>
</ol>
<p>过程二是判断两个树是否相同, 要求是两节点的值相同, 左右子树也相同, 写成<code>recur()</code> 方法:</p>
<ol>
<li><p><strong>终止条件:</strong></p>
<ol>
<li>当节点<code>B</code> 为空：说明树 <code>B</code> 已匹配完成（越过叶子节点），因此返回<code>true</code> ；</li>
<li>当节点<code>A</code>为空：说明已经越过树 <code>A</code>叶子节点，即匹配失败，返回<code>false</code> ；</li>
<li>当节点<code>A</code> 和 <code>B</code>的值不同：说明匹配失败，返回 <code>false</code> ；</li>
</ol>
</li>
<li><p><strong>返回值:</strong></p>
<ol>
<li>判断 <code>A</code> 和 <code>B</code> 的左子节点是否相等，即 recur(A.left, B.left) ；</li>
<li>判断 <code>A</code> 和 <code>B</code> 的右子节点是否相等，即 recur(A.right, B.right) ；</li>
</ol>
</li>
</ol>
<p><img src="http://qcxz71s06.bkt.clouddn.com/0e15908809807327aa87c748c4cf1d850eeb63cc13df94c87439cbaffb535005-Picture2.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/5d9592ec644c6fc765d6e223d4beb3a74ecf46a32b703d9d02cdbeb9f88e9523-Picture3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/76016cb01f7c051318761388eeadd774b334c6da3c5722754452fc82da87c04b-Picture4.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/efe061c2ae8ae6c75b4f36bfd766d60471b4bc985cb330cdae5805043b19f440-Picture5.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/987e1803a3600ef2b8e18320589e058e189888fb4d88389527f33499340f149a-Picture6.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3850986482cd6344935ac823e8b396b52f02ae196b573cea1e7ebecb97eb063c-Picture7.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/cb14268630fd9efa872f077ee625f8066cd7c818f11df9fc9436fa371994de8a-Picture8.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/24d94f730e0a7fc091ab321349c4524dd51828db1fa6a9c1b6455561fa27708e-Picture9.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz27.二叉树的镜像</title>
    <url>/2020/07/09/jz27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>

<p>镜像输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>

<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>在解题之前要先了解 <strong>二叉树的镜像</strong> 是什么:</p>
<blockquote>
<p>二叉树镜像定义： 对于二叉树中任意节点<code>root</code> ，设其左 / 右子节点分别为 <code>left</code>, <code>right</code> ；则在二叉树的镜像中的对应<code>root</code>节点，其左 / 右子节点分别为 <code>right</code>, <code>left</code>。</p>
</blockquote>
<p><img src="http://qcxz71s06.bkt.clouddn.com/9ac3c2730ab2afea15e720e6e6d7ce66aa2cb8659665085e775f8fff2c5b4285-Picture1.png" alt=""></p>
<p>递归的思路很简单, 就是遍历每个节点, 交换其左右子树即可</p>
<ol>
<li><strong>终止条件:</strong> 当节点<code>root</code> 为空时, 返回<code>null</code></li>
<li><strong>递归过程:</strong><ol>
<li>初始化一个临时节点<code>temp</code> 暂存 左儿子</li>
<li>令左儿子等于右儿子</li>
<li>令右儿子等于临时节点</li>
</ol>
</li>
<li>*<em>返回值: *</em>当前的节点<code>root</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz27</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">recur</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        recur(root.left);</span><br><span class="line">        recur(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="栈遍历方法"><a href="#栈遍历方法" class="headerlink" title="栈遍历方法"></a>栈遍历方法</h2><p>利用栈或队列遍历树的所有节点, 交换每个节点的左右儿子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node.left!= <span class="keyword">null</span>)</span><br><span class="line">                stack.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span>)</span><br><span class="line">                stack.add(node.right);</span><br><span class="line">            TreeNode temp = node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz28.对称的二叉树</title>
    <url>/2020/07/09/jz28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p><strong>示例一</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例二</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>首先要清楚对称二叉树的定义: 对于树中任意两个对称节点<code>L</code> 和 <code>R</code>, 一定有:</p>
<ul>
<li><code>L.val=R.val</code> ：即此两对称节点值相等。</li>
<li><code>L.left.val = R.right.valL.left.val=R.right.val</code> ：即 <code>L</code> 的 左子节点 和 <code>R</code>的 右子节点 对称；</li>
<li><code>L.right.val = R.left.valL.right.val=R.left.val</code> ：即 <code>L</code> 的 右子节点 和 <code>R</code> 的 左子节点 对称。</li>
</ul>
<p>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树.</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/ebf894b723530a89cc9a1fe099f36c57c584d4987b080f625b33e228c0a02bec-Picture1.png" alt=""></p>
<p>递归思路:</p>
<ol>
<li><strong>终止条件:</strong> <ul>
<li>若两个节点都为<code>null</code>, 说明之前的的节点都符合对称条件, 返回<code>true</code></li>
<li>若只有一个节点为<code>null</code>, 说明只有一个节点越过叶子节点, 不对称, 返回<code>false</code></li>
<li>若两个节点的值不相等, 返回<code>false</code>, 没什么好说的</li>
</ul>
</li>
<li>*<em>递归过程: *</em><ul>
<li>判断<code>L.left</code> 和 <code>R.right</code> 是否对称</li>
<li>判断<code>L.right</code>和<code>R.left</code>是否对称</li>
</ul>
</li>
<li>*<em>返回值: *</em> 返回值为布尔值, 将两个对称条件用<code>&amp;&amp;</code> 连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz28</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> || recur(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span> || left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(left.left, right.right) &amp;&amp; recur(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>jz32-Ⅰ.从上到下打印二叉树</title>
    <url>/2020/07/09/jz32-%E2%85%A0-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>例如:<br>给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure>

<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。</p>
<p>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/f824fdd8052ae4ee657365c98633480caf03c60e42e4661797618e318baf8664-Picture0.png" alt=""></p>
<p><strong>算法流程</strong>：</p>
<ol>
<li><p><strong>特例处理：</strong> 当树的根节点为空，则直接返回空列表 [] ；</p>
</li>
<li><p><strong>初始化：</strong> 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root]</code> ；</p>
</li>
<li><p><strong>BFS 循环：</strong> 当队列 <code>queue</code> 为空时跳出；</p>
<ol>
<li><strong>出队：</strong> 队首元素出队，记为 <code>node</code>；</li>
<li><strong>打印：</strong> 将 <code>node.val</code>添加至列表 <code>tmp</code>尾部；</li>
<li><strong>添加子节点：</strong> 若 <code>node</code>的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code>；</li>
</ol>
</li>
<li><p><strong>返回值：</strong> 返回打印结果列表<code>res</code>即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jz32</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            ans.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>)</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) &#123;</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前中后序遍历</title>
    <url>/2020/07/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>汇总二叉树的前, 中, 后序遍历.每种遍历都有经典的递归和迭代方法.</p>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left, res);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p><img src="http://qcxz71s06.bkt.clouddn.com/f1c189e18ab21142095be343b507a206_3.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    TreeNode curNode = root;</span><br><span class="line">    stack.push(curNode);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        curNode = stack.pop();</span><br><span class="line">        res.add(curNode.val);</span><br><span class="line">        <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(curNode.right);</span><br><span class="line">        <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(curNode.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归方法-1"><a href="#递归方法-1" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.left, res);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.right, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代方法-1"><a href="#迭代方法-1" class="headerlink" title="迭代方法"></a>迭代方法</h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="http://qcxz71s06.bkt.clouddn.com/f6e4510b7c3446075698d9fd10595f2d.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/55fc6e5a3a213807d281b9ed360e89f0.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/f9d089302bcccba69e83adf17ce98382.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/350a01b043f194dc409076b65bbbbb61.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/c1f7b568c46ace2815d7653b1a47e092.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/3fb26798163cecf6ed46ae823256809e.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/b564b85e0e54727ab791d94f63834209.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/9b3541ab2cefb2a16efe0929a2f173c3.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/6995c79bfc19b0fc7bdb6af3a2ede56d.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/27ae5a883182fbf7ed00897de3348f64.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/88de3e29515e65b31b1f6c776587163a.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/636fb34cd17e20b998b4e78c95a32066.png" alt=""></p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/14056baa203348c036a36cb2eddd217c.png" alt=""></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归方法-2"><a href="#递归方法-2" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left, res);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代方法-2"><a href="#迭代方法-2" class="headerlink" title="迭代方法"></a>迭代方法</h3><ol>
<li>前序遍历的过程是<code>中左右</code>。 <ul>
<li>将其转化成<code>中右左</code>。也就是压栈的过程中优先压入左子树，再压入右子树。</li>
</ul>
</li>
<li>然后将这个结果反过来，用<code>addFirst()</code>方法将元素输出到数组即可完成逆序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    stack.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode curNode = stack.pop();</span><br><span class="line">        res.addFirst(curNode.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(curNode.left);</span><br><span class="line">        <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.add(curNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>团灭四道搜索旋转排序数组题</title>
    <url>/2020/07/07/%E5%9B%A2%E7%81%AD%E5%9B%9B%E9%81%93%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在刷关于二分查找的算法题目时, 有一块内容是绕不过去的, 那就是旋转排序数组的题目. </p>
<p>我们知道, 在查找排序数组时往往采用二分查找的方法, 但是旋转排序数组只保留了区域性的排序, 这就让人比较头疼.通常的二分查找题目有两类, 一类是目标值查找, 即从数组中查找目标值, 返回其下标; 另一类考察的是边界, 这类题目更加灵活, 可能会考察第K大的数, 第一个重复出现的数等等.</p>
<p>结合了旋转数组之后, 就有了四道非常典型的题目, 他们是:</p>
<ul>
<li>LeetCode 33: <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></li>
<li>LeetCode 81: <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">搜索旋转排序数组 Ⅱ</a></li>
<li>LeetCode 153: <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></li>
<li>LeetCode 154: <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值 Ⅱ</a></li>
</ul>
<p>总体而言分别考察了目标值和最小值, 只是按是否存在重复的数又各拓展出一道题. 下面分别来解决.</p>
<hr>
<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>首先，<code>mid</code>将数组分成前后两段：</p>
<p>如果<code>nums[start]&lt;=nums[mid]</code>，则说明前半段是<strong>递增</strong>的</p>
<ul>
<li><p>如果<code>nums*[*start*]* &lt;= target &amp;&amp; target &lt; nums*[*mid*]</code>,目标值在前半段，使<code>end=mid-1</code>*</p>
</li>
<li><p>否则，目标值在后半段，使<code>start=mid+1</code>*</p>
</li>
</ul>
<p>否则，说明后半段是<strong>递增</strong>的</p>
<ul>
<li><p>如果<code>nums[mid] &lt; target &amp;&amp; target &lt;= nums[end]</code>,目标值在后半段，使<code>start=mid+1</code></p>
</li>
<li><p>否则，目标值在前半段，使<code>end=mid-1</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) &#123;</span><br><span class="line">                <span class="comment">// 说明数组在[0, mid]区间上是递增的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    <span class="comment">// 说明target在[left, mid-1]区间内</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 说明target在[mid+1, right]区间内</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明数组在[mid, right]区间上是递增的</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                    <span class="comment">// 说明target在区间[mid+1, right]内</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 说明target在区间[left, mid-1]内</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="81-搜索旋转排序数组-Ⅱ"><a href="#81-搜索旋转排序数组-Ⅱ" class="headerlink" title="81: 搜索旋转排序数组 Ⅱ"></a>81: 搜索旋转排序数组 Ⅱ</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h4><p>因为存在重复的元素, 因此在33题中判断前后段升降时遇到了特殊情况. 在33题中是通过<code>nums[mid] &gt;= nums[left]</code> 来判断前半段是否为增, 若存在重复元素, 则无法通过该方法判断例如 <code>10111</code> 的数组. 有两种判断方法:</p>
<ol>
<li>出现这种情况时<code>nums[left]</code> 和<code>nums[right]</code> 一定是相等的.<code>left++</code> 即可</li>
<li>将原来的判断条件分开来处理, 当<code>nums[mid] &gt; nums[left]</code>时, 还按33题的方法去做, 添加一个<code>nums[mid] = nums[left]</code>的处理方法: 也是<code>left++</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] == nums[mid]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="153-搜索旋转排序数组中的最小值"><a href="#153-搜索旋转排序数组中的最小值" class="headerlink" title="153.搜索旋转排序数组中的最小值"></a>153.搜索旋转排序数组中的最小值</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找-2"><a href="#二分查找-2" class="headerlink" title="二分查找"></a>二分查找</h4><p>因为不存在重复的数字, 所以只需要考虑大于和等于的情况, 比较对象为<code>nums[right]</code></p>
<ol>
<li><p>循环二分： 设置 <code>i</code>,<code>j</code> 指针分别指向<code>numbers</code> 数组左右两端，<code>m = (i + j) / 2</code> 为每次二分的中点（ “/“ 代表向下取整除法），可分为以下三种情况：</p>
<ol>
<li><p>当<code>numbers[m] &gt; numbers[j]</code>时： <code>m</code> 一定在 左排序数组 中，即旋转点 <code>x</code>一定在<code>[m + 1, j]</code>闭区间内，因此执行<code>i = m + 1</code>；</p>
</li>
<li><p>当 <code>numbers[m] &lt; numbers[j]</code>时： <code>m</code> 一定在 右排序数组 中，即旋转点 <code>x</code> 一定在<code>[i, m]</code> 闭区间内，因此执行<code>j = m</code>；</p>
</li>
</ol>
</li>
<li><p>返回值： 当<code>i = j</code>时跳出二分循环，并返回 <code>numbers[i]</code>即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="154-搜索旋转排序数组中的最小值-Ⅱ"><a href="#154-搜索旋转排序数组中的最小值-Ⅱ" class="headerlink" title="154.搜索旋转排序数组中的最小值 Ⅱ"></a>154.搜索旋转排序数组中的最小值 Ⅱ</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>注意数组中可能存在重复的元素。</p>
<p><strong>示例1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><h4 id="二分查找-3"><a href="#二分查找-3" class="headerlink" title="二分查找"></a>二分查找</h4><p>这道题与153题有着高度的相似,  依然是将<code>nums[mid]</code>与<code>nums[right]</code>相比较, 不过是多考虑一个等于的情况, 采取的措施是<code>right--</code>. </p>
<p>如下图所示，寻找旋转数组的最小元素即为寻找 右排序数组 的首个元素 <code>numbers[x]</code> ，称 <code>x</code> 为 旋转点</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/e4c293fbc50538a0af581f455a2d8ce4_2.png" alt=""></p>
<ol>
<li><p>循环二分： 设置 <code>i</code>,<code>j</code> 指针分别指向<code>numbers</code> 数组左右两端，<code>m = (i + j) / 2</code> 为每次二分的中点（ “/“ 代表向下取整除法），可分为以下三种情况：</p>
<ol>
<li><p>当<code>numbers[m] &gt; numbers[j]</code>时： <code>m</code> 一定在 左排序数组 中，即旋转点 <code>x</code>一定在<code>[m + 1, j]</code>闭区间内，因此执行<code>i = m + 1</code>；</p>
</li>
<li><p>当 <code>numbers[m] &lt; numbers[j]</code>时： <code>m</code> 一定在 右排序数组 中，即旋转点 <code>x</code> 一定在<code>[i, m]</code> 闭区间内，因此执行<code>j = m</code>；</p>
</li>
<li><p>当 <code>numbers[m] == numbers[j]</code>时： 无法判断 <code>m</code> 在哪个排序数组中，即无法判断旋转点<code>x</code> 在 <code>[i, m]</code> 还是 <code>[m + 1, j]</code> 区间中。解决方案： 执行<code>j = j - 1</code> 缩小判断范围.</p>
</li>
</ol>
</li>
<li><p>返回值： 当<code>i = j</code>时跳出二分循环，并返回 <code>numbers[i]</code>即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[m] &gt; numbers[j]) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[j]) j = m;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较来看<strong>153题</strong>的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>数组</tag>
        <tag>旋转排序数组</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2020/07/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 多线程的内容很重要, 第一遍没学好, 重新梳理总结一下. 把基础内容总结好之后, 会学习JUC并发编程的相关知识, 会一直总结学习下去. 这块内容我还是想深入学习的, 不只是记一些概念性的知识.</p>
<hr>
<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><h3 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h3><p>多线程简化理解为, 一条路上交通很拥挤, 通过开辟多个车道分流, 解决拥堵问题.</p>
<p>单线程调用方法和多线程的区别:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708130847.png" alt=""></p>
<p>很明显左边的效率低, 右边开辟新线程, 各走各的, 效率高.</p>
<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p>在操作系统中运行的程序就是进程, 比如QQ, 播放器, 游戏等</p>
<p>一个进程可以有多个线程, 如视频中同时听到声音, 看到图像, 看弹幕等等</p>
<p>需要注意的是, <strong>程序</strong>是指令和数据的有序集合, 是一个静态的概念, 执行程序的一次执行过程叫做<strong>进程</strong>, 这才是动态的概念</p>
<p>通常在一个进程中可以包含若干个线程, 线程是CPU调度和执行的单位</p>
<p><strong>核心概念:</strong></p>
<ul>
<li>在程序执行时, 即使没有创建线程, 后台也会有多个线程, 如主线程, gc线程;</li>
<li>main()称之为主线程, 为系统的入口, 用于执行整个程序</li>
<li>对同一份资源操作时, 会存在资源抢夺的问题, 需要加入并发控制</li>
<li>线程会带来额外的开销, 如CPU调度时间, 并发控制开销</li>
</ul>
<hr>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><h3 id="三种创建方式"><a href="#三种创建方式" class="headerlink" title="三种创建方式"></a>三种创建方式</h3><p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708232259.png" alt=""></p>
<h4 id="Thread方式"><a href="#Thread方式" class="headerlink" title="Thread方式"></a>Thread方式</h4><p><code>Thread</code>类实现了<code>Runnable</code>接口</p>
<ol>
<li>自定义线程类继承<code>Thread</code> 类</li>
<li>重写<code>run()</code> 方法, 编写线程执行体</li>
<li>创建线程对象, 调用<code>start()</code> 方法启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run 方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在看代码----"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main线程, 主线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程对象</span></span><br><span class="line">        TestThread testThread1 = <span class="keyword">new</span> TestThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用start()方法开启线程</span></span><br><span class="line">        testThread1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在学习多线程-----"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708233832.png"  />

<p>可以看到自定义线程和主线程的输出结果交错显示.</p>
<p>线程不一定立即执行, 由CPU安排调度. 这里如果把<code>start()</code> 方法替换成<code>run()</code> 的话, 就按顺序执行了.</p>
<p>下面写一个从网络同时下载三张图片, 再熟悉一下多线程的使用, 这里因为要处理IO流, 所以导入了<code>commons-io</code> 包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">// 网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread2</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebDownLoader webDownLoader = <span class="keyword">new</span> WebDownLoader();</span><br><span class="line">        webDownLoader.downloader(url, name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件名为: "</span>+ name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread2 t1 = <span class="keyword">new</span> TestThread2(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708232259.png"</span>, <span class="string">"1.png"</span></span><br><span class="line">                );</span><br><span class="line">        TestThread2 t2 = <span class="keyword">new</span> TestThread2(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708130847.png"</span>, <span class="string">"2.png"</span></span><br><span class="line">                );</span><br><span class="line">        TestThread2 t3 = <span class="keyword">new</span> TestThread2(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/46a8eb9c7e647c684c0b92d098727b9b.png"</span>, <span class="string">"3.png"</span></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下载器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebDownLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url), <span class="keyword">new</span> File(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"IO异常, downloader方法出现问题"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来分析一下这段代码, 将下载和存储的功能单独做成一个下载器的类, 这个是主要功能代码, 我们根据创建线程的流程可以知道待会要在重写的<code>run()</code> 方法中调用.</p>
<p>然后来按照流程创建自定义线程类, 要点是继承<code>Thread</code> 类, 重写<code>run()</code> 方法, 然后将功能代码写进<code>run()</code> 方法中. </p>
<p>在主线程中创建三个自定义线程对象, 他们各自负责下载一张图片, 然后使用<code>start()</code> 方法, 输出的结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下载了文件名为: 2.png</span><br><span class="line">下载了文件名为: 3.png</span><br><span class="line">下载了文件名为: 1.png</span><br></pre></td></tr></table></figure>

<p>可以看出多线程的效果.</p>
<h4 id="Runnable方法"><a href="#Runnable方法" class="headerlink" title="Runnable方法"></a>Runnable方法</h4><ol>
<li>实现MyRunnable类实现Runnable接口</li>
<li>实现<code>run()</code> 方法, 编写线程执行体</li>
<li>创建线程对象, 调用<code>start()</code> 方法启动线程</li>
</ol>
<blockquote>
<p><strong>避免单继承局限性, 灵活方便, 方便同一个对象被多个线程使用</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run 方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在看代码----"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main线程, 主线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程对象</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 创建线程对象, 通过线程对象来开启我们的线程, 这是个代理</span></span><br><span class="line"><span class="comment">//        Thread thread = new Thread(testThread3);</span></span><br><span class="line"><span class="comment">//        thread.start();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 简写方式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testThread3).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"我在学习多线程-----"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果与<code>Thread方法</code> 类似, 不再贴出, 需要注意的是, 在使用<code>start()</code> 方法开启新的线程时通过一个<code>Thread</code> 类的对象调用, 它被称为自定义线程的<strong>静态代理</strong>.</p>
<p>用实现<code>Runnable</code>接口的方法改写下载网络图片的示例, 只需要改动自定义线程类的名称以及调用方法即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(t1).start();</span><br><span class="line"><span class="keyword">new</span> Thread(t2).start();</span><br><span class="line"><span class="keyword">new</span> Thread(t3).start();</span><br></pre></td></tr></table></figure>

<h5 id="龟兔赛跑小例子"><a href="#龟兔赛跑小例子" class="headerlink" title="龟兔赛跑小例子"></a>龟兔赛跑小例子</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟龟兔赛跑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lxb0124</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-07-09 13:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Race</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 胜利者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String winner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟兔子休息</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"兔子"</span>) &amp;&amp; i % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断比赛是否结束</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = gameOver(i);</span><br><span class="line">            <span class="comment">// 如果比赛结束, 停止程序</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" ---&gt; 跑了 "</span> + i + <span class="string">" 步"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否完成比赛</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">gameOver</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否有胜利者</span></span><br><span class="line">        <span class="keyword">if</span> (winner != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (steps &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                winner = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(<span class="string">"winner is "</span> + winner + <span class="string">" !"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Race race = <span class="keyword">new</span> Race();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(race, <span class="string">"兔子"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(race, <span class="string">"乌龟"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Callable方法-了解即可"><a href="#Callable方法-了解即可" class="headerlink" title="Callable方法(了解即可)"></a>Callable方法(了解即可)</h4><ol>
<li><p>实现<code>Callable</code> 接口, 需要返回值类型</p>
</li>
<li><p>重写<code>call</code> 方法, 需要抛出异常</p>
</li>
<li><p>创建目标对象</p>
</li>
<li><p>创建执行服务:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService ser = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交执行:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Boolean&gt; result1 = ser.submit(t1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> r1 = result.get();</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭服务:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ser.shutdownNow;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>改写下载网络图片案例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">// 网络图片地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 保存的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebDownLoader webDownLoader = <span class="keyword">new</span> WebDownLoader();</span><br><span class="line">        webDownLoader.downloader(url, name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件名为: "</span>+ name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable t1 = <span class="keyword">new</span> TestCallable(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708232259.png"</span>, <span class="string">"1.png"</span></span><br><span class="line">        );</span><br><span class="line">        TestCallable t2 = <span class="keyword">new</span> TestCallable(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200708130847.png"</span>, <span class="string">"2.png"</span></span><br><span class="line">        );</span><br><span class="line">        TestCallable t3 = <span class="keyword">new</span> TestCallable(</span><br><span class="line">                <span class="string">"http://qcxz71s06.bkt.clouddn.com/46a8eb9c7e647c684c0b92d098727b9b.png"</span>, <span class="string">"3.png"</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行服务:</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; r1 = ser.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; r2 = ser.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; r3 = ser.submit(t3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        Boolean rs1 = r1.get();</span><br><span class="line">        Boolean rs2 = r2.get();</span><br><span class="line">        Boolean rs3 = r3.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        ser.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>callable的好处</strong></p>
<ol>
<li>可以定义返回值</li>
<li>可以抛出异常</li>
</ol>
<hr>
<h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><p>多个线程同时操作同一个对象</p>
<p>以买火车票为例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticketNums&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟延时</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 拿到了第"</span> + ticketNums-- + <span class="string">" 票"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestThread4 ticket = <span class="keyword">new</span> TestThread4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(ticket, <span class="string">"小明"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket, <span class="string">"老师"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticket, <span class="string">"黄牛"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析这段代码的功能, 首先是在自定义线程里设置了共享的资源, 然后开启三个线程对这个资源进行操作. 这里可能会有疑问: 为什么三个线程会对同一个资源进行操作呢? 这要注意我们只创建了一个自定义线程的对象<code>ticket</code> , 然后开启了三次也就是申请了三个代理, 所以只有一个共享资源. </p>
<p>输出结果为:</p>
<p><img src="http://qcxz71s06.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200709130233.png" alt=""></p>
<p>我们发现了问题: 拿第10张票来说, 三个线程都对其进行了操作, 这就出现了并发的问题.多个线程操作同一个资源的情况下, 线程不安全, 数据紊乱.</p>
<p>为什么龟兔赛跑的例子中没有出现并发问题呢? 这是因为龟兔赛跑中创建的<code>race</code> 对象模拟的是一个赛道, 在整个循环的框架中让线程进来, 所以不会存在冲突的问题.</p>
<hr>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><ol>
<li><p>真实对象和代理对象都要实现同一个接口</p>
</li>
<li><p>代理对象要代理真实角色</p>
</li>
</ol>
<p>这样做的好处是:</p>
<ol>
<li>代理对象可以做很多真实对象做不了的事情</li>
<li>真实对象专注做自己的事情</li>
</ol>
<p>下面通过代码深刻了解这一过程:</p>
<p>我们模拟婚庆公司代理举行婚礼的过程</p>
<p>首先创建一个<code>Marry</code>接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个真实对象的类<code>You</code>, 这个是真正要结婚的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真实角色, 你去结婚</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xxx要结婚了, 超开心"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义婚庆公司的类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理角色, 帮助你去结婚</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Marry target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="keyword">this</span>.target.HappyMarry();</span><br><span class="line">        afer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"结婚之前布置现场"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"结婚之后收尾款"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这两段代码的对比可以看到, 它们都重写的<code>HappyMarry()</code> 方法, 如果不用婚庆公司的话, 只能实现结婚这一个动作, 使用了代理之后, 不仅原来的功能可以实现(因为传入了<code>You</code>对象), 还可以添加额外的功能.</p>
<p>如果没有用到代理的话, 我们是这样调用的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        You you = <span class="keyword">new</span> You();</span><br><span class="line">        you.HappyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxx要结婚了, 超开心</span><br></pre></td></tr></table></figure>

<p>使用代理之后的话:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeddingCompany weddingCompany = <span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You());</span><br><span class="line">        weddingCompany.HappyMarry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结婚之前布置现场</span><br><span class="line">xxx要结婚了, 超开心</span><br><span class="line">结婚之后收尾款</span><br></pre></td></tr></table></figure>

<p>由婚庆公司的例子可以类比到线程的创建过程, 我们发现线程的创建过程也用到了静态代理的思想</p>
<p>我们将上面创建婚庆公司的对象代码简化一下, 并和线程创建代码写在一起对比:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You()).HappyMarry();</span><br><span class="line">   <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">"我爱多线程!"</span>)).start();</span><br></pre></td></tr></table></figure>

<p>这里<code>WeddingCompany</code> 和<code>Thread</code> 都是静态代理, 需要传入真实对象, 婚庆公司和<code>You</code> 都实现了<code>Marry</code> 接口; <code>Thread</code> 和 自定义线程类都实现了<code>Runnable</code> 接口.</p>
<p>然后最后调用的方法都是代理类中定义的方法.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
